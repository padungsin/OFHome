CCS PCH C Compiler, Version 5.064, 5967               16-Apr-17 22:18

               Filename:   D:\Works\Openfog\HomeControl\Firmware\Master\HomeControl_MQTT\HomeCtrlMQTT_mian.lst

               ROM used:   20280 bytes (31%)
                           Largest free fragment is 44228
               RAM used:   793 (20%) at main() level
                           1669 (43%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 30

*
00400:  GOTO   4F7E
*
00408:  MOVWF  04
0040A:  MOVFF  FD8,05
0040E:  MOVFF  FE0,06
00412:  MOVLB  0
00414:  MOVFF  FE9,0C
00418:  MOVFF  FEA,07
0041C:  MOVFF  FE1,08
00420:  MOVFF  FE2,09
00424:  MOVFF  FD9,0A
00428:  MOVFF  FDA,0B
0042C:  MOVFF  FF3,12
00430:  MOVFF  FF4,13
00434:  MOVFF  FFA,14
00438:  MOVFF  FF5,15
0043C:  MOVFF  FF6,16
00440:  MOVFF  FF7,17
00444:  MOVFF  00,0E
00448:  MOVFF  01,0F
0044C:  MOVFF  02,10
00450:  MOVFF  03,11
00454:  BTFSS  F9D.5
00456:  GOTO   0460
0045A:  BTFSC  F9E.5
0045C:  GOTO   0A92
00460:  BTFSS  FF2.5
00462:  GOTO   046C
00466:  BTFSC  FF2.2
00468:  GOTO   0EF6
0046C:  BTFSS  FA3.5
0046E:  GOTO   0478
00472:  BTFSC  FA4.5
00474:  GOTO   0B58
00478:  BTFSS  FF2.4
0047A:  GOTO   0484
0047E:  BTFSC  FF2.1
00480:  GOTO   09FE
00484:  MOVFF  0E,00
00488:  MOVFF  0F,01
0048C:  MOVFF  10,02
00490:  MOVFF  11,03
00494:  MOVFF  0C,FE9
00498:  MOVFF  07,FEA
0049C:  BSF    07.7
0049E:  MOVFF  08,FE1
004A2:  MOVFF  09,FE2
004A6:  MOVFF  0A,FD9
004AA:  MOVFF  0B,FDA
004AE:  MOVFF  12,FF3
004B2:  MOVFF  13,FF4
004B6:  MOVFF  14,FFA
004BA:  MOVFF  15,FF5
004BE:  MOVFF  16,FF6
004C2:  MOVFF  17,FF7
004C6:  MOVF   04,W
004C8:  MOVFF  06,FE0
004CC:  MOVFF  05,FD8
004D0:  RETFIE 0
.................... #include <18F46K22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
004D2:  CLRF   FF7
004D4:  ADDLW  E2
004D6:  MOVWF  FF6
004D8:  MOVLW  04
004DA:  ADDWFC FF7,F
004DC:  TBLRD*+
004DE:  MOVF   FF5,W
004E0:  RETURN 0
004E2:  DATA 3B,00
004E4:  CLRF   FF7
004E6:  ADDLW  F4
004E8:  MOVWF  FF6
004EA:  MOVLW  04
004EC:  ADDWFC FF7,F
004EE:  TBLRD*+
004F0:  MOVF   FF5,W
004F2:  RETURN 0
004F4:  DATA 3A,00
*
0050C:  TBLRD*+
0050E:  MOVFF  FF6,66D
00512:  MOVFF  FF7,66E
00516:  MOVF   FF5,W
00518:  BTFSS  F9E.4
0051A:  BRA    0518
0051C:  MOVWF  FAD
0051E:  MOVFF  66D,FF6
00522:  MOVFF  66E,FF7
00526:  MOVLB  6
00528:  DECFSZ x6C,F
0052A:  BRA    052E
0052C:  BRA    0532
0052E:  MOVLB  0
00530:  BRA    050C
00532:  MOVLB  0
00534:  RETURN 0
00536:  BTFSC  FD8.1
00538:  BRA    0542
0053A:  MOVLW  06
0053C:  MOVWF  FEA
0053E:  MOVLW  80
00540:  MOVWF  FE9
00542:  CLRF   00
00544:  CLRF   01
00546:  CLRF   02
00548:  CLRF   03
0054A:  MOVLB  6
0054C:  CLRF   x80
0054E:  CLRF   x81
00550:  CLRF   x82
00552:  CLRF   x83
00554:  MOVF   x7F,W
00556:  IORWF  x7E,W
00558:  IORWF  x7D,W
0055A:  IORWF  x7C,W
0055C:  BZ    05B6
0055E:  MOVLW  20
00560:  MOVWF  x84
00562:  BCF    FD8.0
00564:  RLCF   x78,F
00566:  RLCF   x79,F
00568:  RLCF   x7A,F
0056A:  RLCF   x7B,F
0056C:  RLCF   x80,F
0056E:  RLCF   x81,F
00570:  RLCF   x82,F
00572:  RLCF   x83,F
00574:  MOVF   x7F,W
00576:  SUBWF  x83,W
00578:  BNZ   058A
0057A:  MOVF   x7E,W
0057C:  SUBWF  x82,W
0057E:  BNZ   058A
00580:  MOVF   x7D,W
00582:  SUBWF  x81,W
00584:  BNZ   058A
00586:  MOVF   x7C,W
00588:  SUBWF  x80,W
0058A:  BNC   05AA
0058C:  MOVF   x7C,W
0058E:  SUBWF  x80,F
00590:  MOVF   x7D,W
00592:  BTFSS  FD8.0
00594:  INCFSZ x7D,W
00596:  SUBWF  x81,F
00598:  MOVF   x7E,W
0059A:  BTFSS  FD8.0
0059C:  INCFSZ x7E,W
0059E:  SUBWF  x82,F
005A0:  MOVF   x7F,W
005A2:  BTFSS  FD8.0
005A4:  INCFSZ x7F,W
005A6:  SUBWF  x83,F
005A8:  BSF    FD8.0
005AA:  RLCF   00,F
005AC:  RLCF   01,F
005AE:  RLCF   02,F
005B0:  RLCF   03,F
005B2:  DECFSZ x84,F
005B4:  BRA    0562
005B6:  MOVFF  680,FEF
005BA:  MOVFF  681,FEC
005BE:  MOVFF  682,FEC
005C2:  MOVFF  683,FEC
005C6:  MOVLB  0
005C8:  RETURN 0
005CA:  MOVF   FE9,W
005CC:  MOVLB  6
005CE:  MOVWF  x70
005D0:  MOVLW  3B
005D2:  MOVWF  x77
005D4:  MOVLW  9A
005D6:  MOVWF  x76
005D8:  MOVLW  CA
005DA:  MOVWF  x75
005DC:  CLRF   x74
005DE:  MOVLW  0A
005E0:  MOVWF  x72
005E2:  BSF    FD8.1
005E4:  MOVLW  06
005E6:  MOVWF  FEA
005E8:  MOVLW  6C
005EA:  MOVWF  FE9
005EC:  MOVFF  66F,67B
005F0:  MOVFF  66E,67A
005F4:  MOVFF  66D,679
005F8:  MOVFF  66C,678
005FC:  MOVFF  677,67F
00600:  MOVFF  676,67E
00604:  MOVFF  675,67D
00608:  MOVFF  674,67C
0060C:  MOVLB  0
0060E:  RCALL  0536
00610:  MOVF   01,W
00612:  MOVF   00,F
00614:  BNZ   063C
00616:  MOVLB  6
00618:  MOVF   x72,W
0061A:  XORLW  01
0061C:  BTFSS  FD8.2
0061E:  BRA    0624
00620:  MOVLB  0
00622:  BRA    063C
00624:  MOVF   x70,W
00626:  BZ    0640
00628:  ANDLW  0F
0062A:  SUBWF  x72,W
0062C:  BZ    0630
0062E:  BC    064C
00630:  BTFSC  x70.7
00632:  BRA    064C
00634:  BTFSC  x70.6
00636:  BRA    0640
00638:  MOVLW  20
0063A:  BRA    0642
0063C:  MOVLB  6
0063E:  CLRF   x70
00640:  MOVLW  30
00642:  ADDWF  00,F
00644:  MOVF   00,W
00646:  BTFSS  F9E.4
00648:  BRA    0646
0064A:  MOVWF  FAD
0064C:  BCF    FD8.1
0064E:  MOVFF  677,67B
00652:  MOVFF  676,67A
00656:  MOVFF  675,679
0065A:  MOVFF  674,678
0065E:  CLRF   x7F
00660:  CLRF   x7E
00662:  CLRF   x7D
00664:  MOVLW  0A
00666:  MOVWF  x7C
00668:  MOVLB  0
0066A:  RCALL  0536
0066C:  MOVFF  03,677
00670:  MOVFF  02,676
00674:  MOVFF  01,675
00678:  MOVFF  00,674
0067C:  MOVLB  6
0067E:  DECFSZ x72,F
00680:  BRA    05E2
00682:  MOVLB  0
00684:  GOTO   0952 (RETURN)
00688:  MOVFF  FEA,674
0068C:  MOVFF  FE9,673
00690:  MOVLB  6
00692:  SWAPF  x6D,W
00694:  IORLW  F0
00696:  MOVWF  x6F
00698:  ADDWF  x6F,F
0069A:  ADDLW  E2
0069C:  MOVWF  x70
0069E:  ADDLW  32
006A0:  MOVWF  x72
006A2:  MOVF   x6D,W
006A4:  ANDLW  0F
006A6:  ADDWF  x70,F
006A8:  ADDWF  x70,F
006AA:  ADDWF  x72,F
006AC:  ADDLW  E9
006AE:  MOVWF  x71
006B0:  ADDWF  x71,F
006B2:  ADDWF  x71,F
006B4:  SWAPF  x6C,W
006B6:  ANDLW  0F
006B8:  ADDWF  x71,F
006BA:  ADDWF  x72,F
006BC:  RLCF   x71,F
006BE:  RLCF   x72,F
006C0:  COMF   x72,F
006C2:  RLCF   x72,F
006C4:  MOVF   x6C,W
006C6:  ANDLW  0F
006C8:  ADDWF  x72,F
006CA:  RLCF   x6F,F
006CC:  MOVLW  07
006CE:  MOVWF  x6E
006D0:  MOVLW  0A
006D2:  DECF   x71,F
006D4:  ADDWF  x72,F
006D6:  BNC   06D2
006D8:  DECF   x70,F
006DA:  ADDWF  x71,F
006DC:  BNC   06D8
006DE:  DECF   x6F,F
006E0:  ADDWF  x70,F
006E2:  BNC   06DE
006E4:  DECF   x6E,F
006E6:  ADDWF  x6F,F
006E8:  BNC   06E4
006EA:  MOVLW  06
006EC:  MOVWF  FEA
006EE:  MOVLW  6E
006F0:  MOVWF  FE9
006F2:  MOVLW  07
006F4:  ANDWF  x73,W
006F6:  BCF    x73.6
006F8:  ADDWF  FE9,F
006FA:  MOVLW  00
006FC:  ADDWFC FEA,F
006FE:  MOVF   FE9,W
00700:  SUBLW  72
00702:  BNZ   070C
00704:  MOVF   FEA,W
00706:  SUBLW  06
00708:  BNZ   070C
0070A:  BSF    x73.6
0070C:  MOVF   FEF,W
0070E:  MOVWF  00
00710:  BNZ   0722
00712:  BTFSC  x73.6
00714:  BRA    0722
00716:  BTFSC  x73.4
00718:  BRA    0732
0071A:  BTFSC  x73.3
0071C:  BRA    0722
0071E:  MOVLW  20
00720:  BRA    0728
00722:  BSF    x73.3
00724:  BCF    x73.4
00726:  MOVLW  30
00728:  ADDWF  00,F
0072A:  MOVF   00,W
0072C:  BTFSS  F9E.4
0072E:  BRA    072C
00730:  MOVWF  FAD
00732:  MOVF   FEE,W
00734:  BTFSS  x73.6
00736:  BRA    06FE
00738:  MOVLB  0
0073A:  RETURN 0
0073C:  MOVLB  6
0073E:  MOVF   x73,W
00740:  CLRF   01
00742:  SUBWF  x72,W
00744:  BC    074C
00746:  MOVFF  672,00
0074A:  BRA    0764
0074C:  CLRF   00
0074E:  MOVLW  08
00750:  MOVWF  x74
00752:  RLCF   x72,F
00754:  RLCF   00,F
00756:  MOVF   x73,W
00758:  SUBWF  00,W
0075A:  BTFSC  FD8.0
0075C:  MOVWF  00
0075E:  RLCF   01,F
00760:  DECFSZ x74,F
00762:  BRA    0752
00764:  MOVLB  0
00766:  RETURN 0
00768:  MOVF   01,W
0076A:  MOVFF  66C,672
0076E:  MOVLW  64
00770:  MOVLB  6
00772:  MOVWF  x73
00774:  MOVLB  0
00776:  RCALL  073C
00778:  MOVFF  00,66C
0077C:  MOVF   01,W
0077E:  MOVLW  30
00780:  BNZ   0792
00782:  MOVLB  6
00784:  BTFSS  x6D.1
00786:  BRA    07A4
00788:  BTFSC  x6D.3
0078A:  BRA    07A4
0078C:  BTFSC  x6D.4
0078E:  MOVLW  20
00790:  BRA    079A
00792:  MOVLB  6
00794:  BCF    x6D.3
00796:  BCF    x6D.4
00798:  BSF    x6D.0
0079A:  ADDWF  01,F
0079C:  MOVF   01,W
0079E:  BTFSS  F9E.4
007A0:  BRA    079E
007A2:  MOVWF  FAD
007A4:  MOVFF  66C,672
007A8:  MOVLW  0A
007AA:  MOVWF  x73
007AC:  MOVLB  0
007AE:  RCALL  073C
007B0:  MOVFF  00,66C
007B4:  MOVF   01,W
007B6:  MOVLW  30
007B8:  BNZ   07CA
007BA:  MOVLB  6
007BC:  BTFSC  x6D.3
007BE:  BRA    07D6
007C0:  BTFSS  x6D.0
007C2:  BRA    07D6
007C4:  BTFSC  x6D.4
007C6:  MOVLW  20
007C8:  MOVLB  0
007CA:  ADDWF  01,F
007CC:  MOVF   01,W
007CE:  BTFSS  F9E.4
007D0:  BRA    07CE
007D2:  MOVWF  FAD
007D4:  MOVLB  6
007D6:  MOVLW  30
007D8:  ADDWF  x6C,F
007DA:  MOVF   x6C,W
007DC:  BTFSS  F9E.4
007DE:  BRA    07DC
007E0:  MOVWF  FAD
007E2:  MOVLB  0
007E4:  RETURN 0
*
00A2C:  DATA 0D,0A
00A2E:  DATA 49,52
00A30:  DATA 5F,53
00A32:  DATA 77,69
00A34:  DATA 74,63
00A36:  DATA 68,5F
00A38:  DATA 43,48
00A3A:  DATA 20,3D
00A3C:  DATA 20,25
00A3E:  DATA 75,00
00A40:  DATA 0A,0D
00A42:  DATA 49,52
00A44:  DATA 5F,44
00A46:  DATA 61,74
00A48:  DATA 61,20
00A4A:  DATA 3D,20
00A4C:  DATA 25,6C
00A4E:  DATA 75,0A
00A50:  DATA 00,00
00A52:  DATA 24,4D
00A54:  DATA 51,54
00A56:  DATA 54,59
00A58:  DATA 49,52
00A5A:  DATA 53,45
00A5C:  DATA 4E,44
00A5E:  DATA 2C,25
00A60:  DATA 6C,75
00A62:  DATA 2C,25
00A64:  DATA 6C,75
00A66:  DATA 2C,25
00A68:  DATA 6C,75
00A6A:  DATA 2C,25
00A6C:  DATA 6C,75
00A6E:  DATA 2C,25
00A70:  DATA 6C,75
00A72:  DATA 2C,25
00A74:  DATA 75,2C
00A76:  DATA 31,62
00A78:  DATA 00,00
*
00B08:  DATA 25,73
00B0A:  DATA 53,3B
00B0C:  DATA 4F,4B
00B0E:  DATA 2A,00
00B10:  DATA 24,4D
00B12:  DATA 51,53
00B14:  DATA 57,43
00B16:  DATA 52,3B
00B18:  DATA 25,75
00B1A:  DATA 3B,57
00B1C:  DATA 3B,25
00B1E:  DATA 63,3B
00B20:  DATA 25,75
00B22:  DATA 3B,25
00B24:  DATA 73,2A
00B26:  DATA 00,00
00B28:  DATA 24,4D
00B2A:  DATA 51,53
00B2C:  DATA 57,53
00B2E:  DATA 54,41
00B30:  DATA 54,55
00B32:  DATA 53,4E
00B34:  DATA 3B,25
00B36:  DATA 63,3B
00B38:  DATA 25,75
00B3A:  DATA 3B,25
00B3C:  DATA 75,2A
00B3E:  DATA 00,00
*
00BC6:  DATA 43,4D
00BC8:  DATA 44,3A
00BCA:  DATA 20,25
00BCC:  DATA 73,0A
00BCE:  DATA 00,00
00BD0:  DATA 4D,51
00BD2:  DATA 54,54
00BD4:  DATA 20,20
00BD6:  DATA 20,20
00BD8:  DATA 00,00
00BDA:  DATA 20,20
00BDC:  DATA 20,20
00BDE:  DATA 20,20
00BE0:  DATA 20,20
00BE2:  DATA 20,20
00BE4:  DATA 20,20
00BE6:  DATA 20,20
00BE8:  DATA 20,20
00BEA:  DATA 00,00
00BEC:  DATA 46,41
00BEE:  DATA 49,4C
00BF0:  DATA 20,20
00BF2:  DATA 20,20
00BF4:  DATA 00,00
00BF6:  DATA 20,20
00BF8:  DATA 20,20
00BFA:  DATA 20,20
00BFC:  DATA 20,20
00BFE:  DATA 20,20
00C00:  DATA 20,20
00C02:  DATA 20,20
00C04:  DATA 20,20
00C06:  DATA 00,00
00C08:  DATA 20,20
00C0A:  DATA 20,20
00C0C:  DATA 20,20
00C0E:  DATA 20,20
00C10:  DATA 20,20
00C12:  DATA 20,20
00C14:  DATA 20,20
00C16:  DATA 20,20
00C18:  DATA 00,00
00C1A:  DATA 45,32
00C1C:  DATA 00,00
00C1E:  DATA 57,69
00C20:  DATA 46,69
00C22:  DATA 20,53
00C24:  DATA 69,67
00C26:  DATA 6E,61
00C28:  DATA 6C,20
00C2A:  DATA 4C,6F
00C2C:  DATA 73,73
00C2E:  DATA 00,00
00C30:  DATA 53,77
00C32:  DATA 69,74
00C34:  DATA 63,68
00C36:  DATA 20,49
00C38:  DATA 6E,74
00C3A:  DATA 65,72
00C3C:  DATA 6E,61
00C3E:  DATA 6C,3A
00C40:  DATA 20,25
00C42:  DATA 75,0A
00C44:  DATA 00,00
00C46:  DATA 43,6F
00C48:  DATA 6E,74
00C4A:  DATA 72,6F
00C4C:  DATA 6C,20
00C4E:  DATA 4D,6F
00C50:  DATA 64,65
00C52:  DATA 3A,20
00C54:  DATA 25,63
00C56:  DATA 0A,00
00C58:  DATA 25,73
00C5A:  DATA 52,3B
00C5C:  DATA 25,75
00C5E:  DATA 3B,25
00C60:  DATA 63,3B
00C62:  DATA 31,3B
00C64:  DATA 25,73
00C66:  DATA 2A,00
00C68:  DATA 53,69
00C6A:  DATA 7A,65
00C6C:  DATA 20,25
00C6E:  DATA 75,0A
00C70:  DATA 00,00
00C72:  DATA 53,69
00C74:  DATA 7A,65
00C76:  DATA 20,25
00C78:  DATA 75,0A
00C7A:  DATA 00,00
00C7C:  DATA 53,69
00C7E:  DATA 7A,65
00C80:  DATA 20,25
00C82:  DATA 75,0A
00C84:  DATA 00,00
00C86:  DATA 25,73
00C88:  DATA 52,3B
00C8A:  DATA 25,75
00C8C:  DATA 3B,25
00C8E:  DATA 75,3B
00C90:  DATA 25,75
00C92:  DATA 3B,25
00C94:  DATA 63,3B
00C96:  DATA 25,75
00C98:  DATA 3B,25
00C9A:  DATA 75,3B
00C9C:  DATA 25,75
00C9E:  DATA 3B,25
00CA0:  DATA 73,3B
00CA2:  DATA 31,3B
00CA4:  DATA 25,73
00CA6:  DATA 2A,00
00CA8:  DATA 25,73
00CAA:  DATA 52,3B
00CAC:  DATA 25,75
00CAE:  DATA 3B,30
00CB0:  DATA 3B,25
00CB2:  DATA 73,2A
00CB4:  DATA 00,00
00CB6:  DATA 25,73
00CB8:  DATA 52,3B
00CBA:  DATA 25,75
00CBC:  DATA 3B,31
00CBE:  DATA 3B,25
00CC0:  DATA 73,2A
00CC2:  DATA 00,00
00CC4:  DATA 25,73
00CC6:  DATA 52,3B
00CC8:  DATA 25,75
00CCA:  DATA 3B,25
00CCC:  DATA 75,3B
00CCE:  DATA 25,75
00CD0:  DATA 3B,25
00CD2:  DATA 63,3B
00CD4:  DATA 25,75
00CD6:  DATA 3B,25
00CD8:  DATA 75,3B
00CDA:  DATA 25,75
00CDC:  DATA 3B,25
00CDE:  DATA 73,3B
00CE0:  DATA 31,3B
00CE2:  DATA 25,73
00CE4:  DATA 2A,00
00CE6:  DATA 50,72
00CE8:  DATA 6F,63
00CEA:  DATA 65,73
00CEC:  DATA 73,20
00CEE:  DATA 4F,54
00CF0:  DATA 41,20
00CF2:  DATA 2E,2E
00CF4:  DATA 2E,2E
00CF6:  DATA 00,00
00CF8:  DATA 55,70
00CFA:  DATA 6C,6F
00CFC:  DATA 61,64
00CFE:  DATA 20,4E
00D00:  DATA 65,77
00D02:  DATA 20,46
00D04:  DATA 2F,57
00D06:  DATA 20,20
00D08:  DATA 00,00
00D0A:  DATA 55,70
00D0C:  DATA 67,72
00D0E:  DATA 61,64
00D10:  DATA 65,20
00D12:  DATA 4E,65
00D14:  DATA 77,20
00D16:  DATA 46,69
00D18:  DATA 72,6D
00D1A:  DATA 77,61
00D1C:  DATA 72,65
00D1E:  DATA 20,50
00D20:  DATA 72,6F
00D22:  DATA 63,65
00D24:  DATA 73,73
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 24,41
00D2C:  DATA 43,52
00D2E:  DATA 2C,25
00D30:  DATA 32,2E
00D32:  DATA 32,66
00D34:  DATA 2C,25
00D36:  DATA 75,2C
00D38:  DATA 25,75
00D3A:  DATA 2C,2A
00D3C:  DATA 00,00
00D3E:  DATA 24,4D
00D40:  DATA 51,53
00D42:  DATA 57,43
00D44:  DATA 53,3B
00D46:  DATA 25,75
00D48:  DATA 3B,4E
00D4A:  DATA 3B,4D
00D4C:  DATA 41,53
00D4E:  DATA 54,45
00D50:  DATA 52,2A
00D52:  DATA 00,00
00D54:  DATA 24,4D
00D56:  DATA 51,53
00D58:  DATA 57,43
00D5A:  DATA 53,3B
00D5C:  DATA 25,75
00D5E:  DATA 3B,46
00D60:  DATA 3B,4D
00D62:  DATA 41,53
00D64:  DATA 54,45
00D66:  DATA 52,2A
00D68:  DATA 00,00
00D6A:  DATA 57,69
00D6C:  DATA 46,69
00D6E:  DATA 20,4C
00D70:  DATA 6F,73
00D72:  DATA 73,20
00D74:  DATA 00,00
00D76:  DATA 25,6C
00D78:  DATA 75,20
00D7A:  DATA 20,20
00D7C:  DATA 20,00
00D7E:  DATA 45,31
00D80:  DATA 20,00
00D82:  DATA 52,65
00D84:  DATA 73,65
00D86:  DATA 74,20
00D88:  DATA 57,69
00D8A:  DATA 46,69
00D8C:  DATA 20,20
00D8E:  DATA 20,20
00D90:  DATA 20,20
00D92:  DATA 00,00
00D94:  DATA 52,65
00D96:  DATA 73,65
00D98:  DATA 74,20
00D9A:  DATA 57,69
00D9C:  DATA 46,69
00D9E:  DATA 0A,00
00DA0:  DATA 3A,00
00DA2:  DATA 3A,00
00DA4:  DATA 3A,00
00DA6:  DATA 24,4D
00DA8:  DATA 51,53
00DAA:  DATA 57,43
00DAC:  DATA 53,3B
00DAE:  DATA 25,75
00DB0:  DATA 3B,25
00DB2:  DATA 63,3B
00DB4:  DATA 4D,41
00DB6:  DATA 53,54
00DB8:  DATA 45,52
00DBA:  DATA 2A,00
00DBC:  DATA 24,4D
00DBE:  DATA 51,53
00DC0:  DATA 57,43
00DC2:  DATA 4C,3B
00DC4:  DATA 25,75
00DC6:  DATA 3B,25
00DC8:  DATA 63,3B
00DCA:  DATA 4D,41
00DCC:  DATA 53,54
00DCE:  DATA 45,52
00DD0:  DATA 2A,00
00DD2:  DATA 24,4D
00DD4:  DATA 51,53
00DD6:  DATA 57,53
00DD8:  DATA 54,41
00DDA:  DATA 54,55
00DDC:  DATA 53,4E
00DDE:  DATA 3B,25
00DE0:  DATA 75,3B
00DE2:  DATA 31,2A
00DE4:  DATA 00,00
00DE6:  DATA 24,4D
00DE8:  DATA 51,53
00DEA:  DATA 57,53
00DEC:  DATA 54,41
00DEE:  DATA 54,55
00DF0:  DATA 53,4E
00DF2:  DATA 3B,25
00DF4:  DATA 75,3B
00DF6:  DATA 30,2A
00DF8:  DATA 00,00
00DFA:  DATA 20,54
00DFC:  DATA 3A,25
00DFE:  DATA 75,20
00E00:  DATA 00,00
00E02:  DATA 43,20
00E04:  DATA 20,00
00E06:  TBLRD*+
00E08:  MOVFF  FF6,671
00E0C:  MOVFF  FF7,672
00E10:  MOVF   FF5,W
00E12:  BTFSS  FA4.4
00E14:  BRA    0E12
00E16:  MOVWF  F73
00E18:  MOVFF  671,FF6
00E1C:  MOVFF  672,FF7
00E20:  MOVLB  6
00E22:  DECFSZ x70,F
00E24:  BRA    0E28
00E26:  BRA    0E2C
00E28:  MOVLB  0
00E2A:  BRA    0E06
00E2C:  MOVLB  0
00E2E:  RETURN 0
00E30:  MOVF   01,W
00E32:  MOVFF  670,672
00E36:  MOVLW  64
00E38:  MOVLB  6
00E3A:  MOVWF  x73
00E3C:  MOVLB  0
00E3E:  RCALL  073C
00E40:  MOVFF  00,670
00E44:  MOVF   01,W
00E46:  MOVLW  30
00E48:  BNZ   0E5A
00E4A:  MOVLB  6
00E4C:  BTFSS  x71.1
00E4E:  BRA    0E6C
00E50:  BTFSC  x71.3
00E52:  BRA    0E6C
00E54:  BTFSC  x71.4
00E56:  MOVLW  20
00E58:  BRA    0E62
00E5A:  MOVLB  6
00E5C:  BCF    x71.3
00E5E:  BCF    x71.4
00E60:  BSF    x71.0
00E62:  ADDWF  01,F
00E64:  MOVF   01,W
00E66:  BTFSS  FA4.4
00E68:  BRA    0E66
00E6A:  MOVWF  F73
00E6C:  MOVFF  670,672
00E70:  MOVLW  0A
00E72:  MOVWF  x73
00E74:  MOVLB  0
00E76:  RCALL  073C
00E78:  MOVFF  00,670
00E7C:  MOVF   01,W
00E7E:  MOVLW  30
00E80:  BNZ   0E92
00E82:  MOVLB  6
00E84:  BTFSC  x71.3
00E86:  BRA    0E9E
00E88:  BTFSS  x71.0
00E8A:  BRA    0E9E
00E8C:  BTFSC  x71.4
00E8E:  MOVLW  20
00E90:  MOVLB  0
00E92:  ADDWF  01,F
00E94:  MOVF   01,W
00E96:  BTFSS  FA4.4
00E98:  BRA    0E96
00E9A:  MOVWF  F73
00E9C:  MOVLB  6
00E9E:  MOVLW  30
00EA0:  ADDWF  x70,F
00EA2:  MOVF   x70,W
00EA4:  BTFSS  FA4.4
00EA6:  BRA    0EA4
00EA8:  MOVWF  F73
00EAA:  MOVLB  0
00EAC:  RETURN 0
00EAE:  MOVF   FEF,F
00EB0:  BZ    0ED2
00EB2:  MOVFF  FEA,671
00EB6:  MOVFF  FE9,670
00EBA:  MOVF   FEF,W
00EBC:  BTFSS  FA4.4
00EBE:  BRA    0EBC
00EC0:  MOVWF  F73
00EC2:  MOVFF  671,FEA
00EC6:  MOVFF  670,FE9
00ECA:  INCF   FE9,F
00ECC:  BTFSC  FD8.2
00ECE:  INCF   FEA,F
00ED0:  BRA    0EAE
00ED2:  RETURN 0
00ED4:  TBLRD*+
00ED6:  MOVF   FF5,F
00ED8:  BZ    0EF4
00EDA:  MOVFF  FF6,66D
00EDE:  MOVFF  FF7,66E
00EE2:  MOVF   FF5,W
00EE4:  BTFSS  FA4.4
00EE6:  BRA    0EE4
00EE8:  MOVWF  F73
00EEA:  MOVFF  66D,FF6
00EEE:  MOVFF  66E,FF7
00EF2:  BRA    0ED4
00EF4:  RETURN 0
*
01008:  DATA 24,4D
0100A:  DATA 51,53
0100C:  DATA 57,45
0100E:  DATA 52,52
01010:  DATA 3B,25
01012:  DATA 75,3B
01014:  DATA 25,73
01016:  DATA 2A,00
01018:  DATA 24,42
0101A:  DATA 4F,58
0101C:  DATA 4D,51
0101E:  DATA 54,54
01020:  DATA 2A,00
01022:  DATA 24,42
01024:  DATA 4F,58
01026:  DATA 52,54
01028:  DATA 43,2A
0102A:  DATA 00,00
0102C:  DATA 48,6F
0102E:  DATA 6D,65
01030:  DATA 43,6F
01032:  DATA 6E,74
01034:  DATA 72,6F
01036:  DATA 6C,20
01038:  DATA 56,34
0103A:  DATA 2E,30
0103C:  DATA 00,00
0103E:  DATA 0D,0A
01040:  DATA 48,6F
01042:  DATA 6D,65
01044:  DATA 20,43
01046:  DATA 6F,6E
01048:  DATA 74,72
0104A:  DATA 6F,6C
0104C:  DATA 20,50
0104E:  DATA 6C,75
01050:  DATA 73,20
01052:  DATA 2D,20
01054:  DATA 4D,51
01056:  DATA 54,54
01058:  DATA 20,56
0105A:  DATA 30,30
0105C:  DATA 2E,39
0105E:  DATA 30,0D
01060:  DATA 0A,00
*
01438:  TBLRD*+
0143A:  MOVF   FF5,F
0143C:  BZ    1456
0143E:  MOVFF  FF6,646
01442:  MOVFF  FF7,647
01446:  MOVFF  FF5,648
0144A:  RCALL  1408
0144C:  MOVFF  646,FF6
01450:  MOVFF  647,FF7
01454:  BRA    1438
01456:  RETURN 0
01458:  TBLRD*+
0145A:  MOVF   FF5,F
0145C:  BZ    1478
0145E:  MOVFF  FF6,646
01462:  MOVFF  FF7,647
01466:  MOVF   FF5,W
01468:  BTFSS  F9E.4
0146A:  BRA    1468
0146C:  MOVWF  FAD
0146E:  MOVFF  646,FF6
01472:  MOVFF  647,FF7
01476:  BRA    1458
01478:  RETURN 0
*
01498:  MOVLB  6
0149A:  MOVF   x47,W
0149C:  ANDLW  07
0149E:  MOVWF  00
014A0:  RRCF   x47,W
014A2:  MOVWF  01
014A4:  RRCF   01,F
014A6:  RRCF   01,F
014A8:  MOVLW  1F
014AA:  ANDWF  01,F
014AC:  MOVF   01,W
014AE:  ADDWF  x49,W
014B0:  MOVWF  FE9
014B2:  MOVLW  00
014B4:  ADDWFC x4A,W
014B6:  MOVWF  FEA
014B8:  CLRF   01
014BA:  INCF   01,F
014BC:  INCF   00,F
014BE:  BRA    14C2
014C0:  RLCF   01,F
014C2:  DECFSZ 00,F
014C4:  BRA    14C0
014C6:  MOVF   x48,F
014C8:  BZ    14D0
014CA:  MOVF   01,W
014CC:  IORWF  FEF,F
014CE:  BRA    14D6
014D0:  COMF   01,F
014D2:  MOVF   01,W
014D4:  ANDWF  FEF,F
014D6:  MOVLB  0
014D8:  RETURN 0
*
01CF4:  CLRF   00
01CF6:  CLRF   01
01CF8:  MOVLB  6
01CFA:  MOVF   x4F,W
01CFC:  BCF    FD8.0
01CFE:  BTFSC  x50.0
01D00:  ADDWF  00,F
01D02:  RRCF   00,F
01D04:  RRCF   01,F
01D06:  BTFSC  x50.1
01D08:  ADDWF  00,F
01D0A:  RRCF   00,F
01D0C:  RRCF   01,F
01D0E:  BTFSC  x50.2
01D10:  ADDWF  00,F
01D12:  RRCF   00,F
01D14:  RRCF   01,F
01D16:  BTFSC  x50.3
01D18:  ADDWF  00,F
01D1A:  RRCF   00,F
01D1C:  RRCF   01,F
01D1E:  BTFSC  x50.4
01D20:  ADDWF  00,F
01D22:  RRCF   00,F
01D24:  RRCF   01,F
01D26:  BTFSC  x50.5
01D28:  ADDWF  00,F
01D2A:  RRCF   00,F
01D2C:  RRCF   01,F
01D2E:  BTFSC  x50.6
01D30:  ADDWF  00,F
01D32:  RRCF   00,F
01D34:  RRCF   01,F
01D36:  BTFSC  x50.7
01D38:  ADDWF  00,F
01D3A:  RRCF   00,F
01D3C:  RRCF   01,F
01D3E:  MOVLB  0
01D40:  GOTO   1E14 (RETURN)
*
01ED6:  MOVF   FEF,F
01ED8:  BZ    1EFA
01EDA:  MOVFF  FEA,647
01EDE:  MOVFF  FE9,646
01EE2:  MOVF   FEF,W
01EE4:  BTFSS  F9E.4
01EE6:  BRA    1EE4
01EE8:  MOVWF  FAD
01EEA:  MOVFF  647,FEA
01EEE:  MOVFF  646,FE9
01EF2:  INCF   FE9,F
01EF4:  BTFSC  FD8.2
01EF6:  INCF   FEA,F
01EF8:  BRA    1ED6
01EFA:  RETURN 0
*
024EC:  MOVLB  6
024EE:  CLRF   x5E
024F0:  CLRF   x5F
024F2:  MOVLW  01
024F4:  MOVWF  x60
024F6:  CLRF   FDA
024F8:  CLRF   FD9
024FA:  MOVLW  06
024FC:  MOVWF  x63
024FE:  MOVLW  56
02500:  MOVWF  x62
02502:  MOVLW  06
02504:  MOVWF  FEA
02506:  MOVLW  5A
02508:  MOVWF  FE9
0250A:  MOVFF  663,FE2
0250E:  MOVFF  662,FE1
02512:  MOVFF  660,661
02516:  BCF    FD8.0
02518:  MOVF   FE5,W
0251A:  MULWF  FEE
0251C:  MOVF   FF3,W
0251E:  ADDWFC x5E,F
02520:  MOVF   FF4,W
02522:  ADDWFC x5F,F
02524:  DECFSZ x61,F
02526:  BRA    2516
02528:  MOVFF  65E,FDE
0252C:  MOVFF  65F,65E
02530:  CLRF   x5F
02532:  BTFSC  FD8.0
02534:  INCF   x5F,F
02536:  INCF   x62,F
02538:  BTFSC  FD8.2
0253A:  INCF   x63,F
0253C:  INCF   x60,F
0253E:  MOVF   x60,W
02540:  SUBLW  05
02542:  BNZ   2502
02544:  MOVLB  0
02546:  GOTO   2668 (RETURN)
0254A:  BTFSC  FD8.1
0254C:  BRA    2556
0254E:  MOVLW  06
02550:  MOVWF  FEA
02552:  MOVLW  66
02554:  MOVWF  FE9
02556:  MOVLB  6
02558:  MOVF   x61,W
0255A:  XORWF  x65,W
0255C:  ANDLW  80
0255E:  MOVWF  x6B
02560:  BTFSS  x61.7
02562:  BRA    257A
02564:  COMF   x5E,F
02566:  COMF   x5F,F
02568:  COMF   x60,F
0256A:  COMF   x61,F
0256C:  INCF   x5E,F
0256E:  BTFSC  FD8.2
02570:  INCF   x5F,F
02572:  BTFSC  FD8.2
02574:  INCF   x60,F
02576:  BTFSC  FD8.2
02578:  INCF   x61,F
0257A:  BTFSS  x65.7
0257C:  BRA    2594
0257E:  COMF   x62,F
02580:  COMF   x63,F
02582:  COMF   x64,F
02584:  COMF   x65,F
02586:  INCF   x62,F
02588:  BTFSC  FD8.2
0258A:  INCF   x63,F
0258C:  BTFSC  FD8.2
0258E:  INCF   x64,F
02590:  BTFSC  FD8.2
02592:  INCF   x65,F
02594:  CLRF   00
02596:  CLRF   01
02598:  CLRF   02
0259A:  CLRF   03
0259C:  CLRF   x66
0259E:  CLRF   x67
025A0:  CLRF   x68
025A2:  CLRF   x69
025A4:  MOVF   x65,W
025A6:  IORWF  x64,W
025A8:  IORWF  x63,W
025AA:  IORWF  x62,W
025AC:  BZ    2606
025AE:  MOVLW  20
025B0:  MOVWF  x6A
025B2:  BCF    FD8.0
025B4:  RLCF   x5E,F
025B6:  RLCF   x5F,F
025B8:  RLCF   x60,F
025BA:  RLCF   x61,F
025BC:  RLCF   x66,F
025BE:  RLCF   x67,F
025C0:  RLCF   x68,F
025C2:  RLCF   x69,F
025C4:  MOVF   x65,W
025C6:  SUBWF  x69,W
025C8:  BNZ   25DA
025CA:  MOVF   x64,W
025CC:  SUBWF  x68,W
025CE:  BNZ   25DA
025D0:  MOVF   x63,W
025D2:  SUBWF  x67,W
025D4:  BNZ   25DA
025D6:  MOVF   x62,W
025D8:  SUBWF  x66,W
025DA:  BNC   25FA
025DC:  MOVF   x62,W
025DE:  SUBWF  x66,F
025E0:  MOVF   x63,W
025E2:  BTFSS  FD8.0
025E4:  INCFSZ x63,W
025E6:  SUBWF  x67,F
025E8:  MOVF   x64,W
025EA:  BTFSS  FD8.0
025EC:  INCFSZ x64,W
025EE:  SUBWF  x68,F
025F0:  MOVF   x65,W
025F2:  BTFSS  FD8.0
025F4:  INCFSZ x65,W
025F6:  SUBWF  x69,F
025F8:  BSF    FD8.0
025FA:  RLCF   00,F
025FC:  RLCF   01,F
025FE:  RLCF   02,F
02600:  RLCF   03,F
02602:  DECFSZ x6A,F
02604:  BRA    25B2
02606:  BTFSS  x6B.7
02608:  BRA    2620
0260A:  COMF   00,F
0260C:  COMF   01,F
0260E:  COMF   02,F
02610:  COMF   03,F
02612:  INCF   00,F
02614:  BTFSC  FD8.2
02616:  INCF   01,F
02618:  BTFSC  FD8.2
0261A:  INCF   02,F
0261C:  BTFSC  FD8.2
0261E:  INCF   03,F
02620:  MOVFF  666,FEF
02624:  MOVFF  667,FEC
02628:  MOVFF  668,FEC
0262C:  MOVFF  669,FEC
02630:  MOVLB  0
02632:  RETURN 0
*
02972:  MOVLB  6
02974:  MOVF   x54,W
02976:  BTFSC  FD8.2
02978:  BRA    2A5C
0297A:  MOVWF  00
0297C:  MOVF   x58,W
0297E:  BTFSC  FD8.2
02980:  BRA    2A5C
02982:  ADDWF  00,F
02984:  BNC   298E
02986:  MOVLW  81
02988:  ADDWF  00,F
0298A:  BC    2A5C
0298C:  BRA    2996
0298E:  MOVLW  7F
02990:  SUBWF  00,F
02992:  BNC   2A5C
02994:  BZ    2A5C
02996:  MOVFF  655,65C
0299A:  MOVF   x59,W
0299C:  XORWF  x5C,F
0299E:  BSF    x55.7
029A0:  BSF    x59.7
029A2:  MOVF   x57,W
029A4:  MULWF  x5B
029A6:  MOVFF  FF4,65E
029AA:  MOVF   x56,W
029AC:  MULWF  x5A
029AE:  MOVFF  FF4,03
029B2:  MOVFF  FF3,65D
029B6:  MULWF  x5B
029B8:  MOVF   FF3,W
029BA:  ADDWF  x5E,F
029BC:  MOVF   FF4,W
029BE:  ADDWFC x5D,F
029C0:  MOVLW  00
029C2:  ADDWFC 03,F
029C4:  MOVF   x57,W
029C6:  MULWF  x5A
029C8:  MOVF   FF3,W
029CA:  ADDWF  x5E,F
029CC:  MOVF   FF4,W
029CE:  ADDWFC x5D,F
029D0:  MOVLW  00
029D2:  CLRF   02
029D4:  ADDWFC 03,F
029D6:  ADDWFC 02,F
029D8:  MOVF   x55,W
029DA:  MULWF  x5B
029DC:  MOVF   FF3,W
029DE:  ADDWF  x5D,F
029E0:  MOVF   FF4,W
029E2:  ADDWFC 03,F
029E4:  MOVLW  00
029E6:  ADDWFC 02,F
029E8:  MOVF   x55,W
029EA:  MULWF  x5A
029EC:  MOVF   FF3,W
029EE:  ADDWF  03,F
029F0:  MOVF   FF4,W
029F2:  ADDWFC 02,F
029F4:  MOVLW  00
029F6:  CLRF   01
029F8:  ADDWFC 01,F
029FA:  MOVF   x57,W
029FC:  MULWF  x59
029FE:  MOVF   FF3,W
02A00:  ADDWF  x5D,F
02A02:  MOVF   FF4,W
02A04:  ADDWFC 03,F
02A06:  MOVLW  00
02A08:  ADDWFC 02,F
02A0A:  ADDWFC 01,F
02A0C:  MOVF   x56,W
02A0E:  MULWF  x59
02A10:  MOVF   FF3,W
02A12:  ADDWF  03,F
02A14:  MOVF   FF4,W
02A16:  ADDWFC 02,F
02A18:  MOVLW  00
02A1A:  ADDWFC 01,F
02A1C:  MOVF   x55,W
02A1E:  MULWF  x59
02A20:  MOVF   FF3,W
02A22:  ADDWF  02,F
02A24:  MOVF   FF4,W
02A26:  ADDWFC 01,F
02A28:  INCF   00,F
02A2A:  BTFSC  01.7
02A2C:  BRA    2A38
02A2E:  RLCF   x5D,F
02A30:  RLCF   03,F
02A32:  RLCF   02,F
02A34:  RLCF   01,F
02A36:  DECF   00,F
02A38:  MOVLW  00
02A3A:  BTFSS  x5D.7
02A3C:  BRA    2A52
02A3E:  INCF   03,F
02A40:  ADDWFC 02,F
02A42:  ADDWFC 01,F
02A44:  MOVF   01,W
02A46:  BNZ   2A52
02A48:  MOVF   02,W
02A4A:  BNZ   2A52
02A4C:  MOVF   03,W
02A4E:  BNZ   2A52
02A50:  INCF   00,F
02A52:  BTFSC  x5C.7
02A54:  BSF    01.7
02A56:  BTFSS  x5C.7
02A58:  BCF    01.7
02A5A:  BRA    2A64
02A5C:  CLRF   00
02A5E:  CLRF   01
02A60:  CLRF   02
02A62:  CLRF   03
02A64:  MOVLB  0
02A66:  GOTO   2ADA (RETURN)
02A6A:  MOVLB  6
02A6C:  MOVF   x54,W
02A6E:  SUBLW  B6
02A70:  MOVWF  x54
02A72:  CLRF   03
02A74:  MOVFF  655,658
02A78:  BSF    x55.7
02A7A:  BCF    FD8.0
02A7C:  RRCF   x55,F
02A7E:  RRCF   x56,F
02A80:  RRCF   x57,F
02A82:  RRCF   03,F
02A84:  RRCF   02,F
02A86:  RRCF   01,F
02A88:  RRCF   00,F
02A8A:  DECFSZ x54,F
02A8C:  BRA    2A7A
02A8E:  BTFSS  x58.7
02A90:  BRA    2AA8
02A92:  COMF   00,F
02A94:  COMF   01,F
02A96:  COMF   02,F
02A98:  COMF   03,F
02A9A:  INCF   00,F
02A9C:  BTFSC  FD8.2
02A9E:  INCF   01,F
02AA0:  BTFSC  FD8.2
02AA2:  INCF   02,F
02AA4:  BTFSC  FD8.2
02AA6:  INCF   03,F
02AA8:  MOVLB  0
02AAA:  GOTO   2B04 (RETURN)
02AAE:  MOVF   FE9,W
02AB0:  MOVLB  6
02AB2:  MOVWF  x4C
02AB4:  MOVF   x4B,W
02AB6:  MOVWF  x4E
02AB8:  BZ    2AF0
02ABA:  MOVFF  64A,657
02ABE:  MOVFF  649,656
02AC2:  MOVFF  648,655
02AC6:  MOVFF  647,654
02ACA:  CLRF   x5B
02ACC:  CLRF   x5A
02ACE:  MOVLW  20
02AD0:  MOVWF  x59
02AD2:  MOVLW  82
02AD4:  MOVWF  x58
02AD6:  MOVLB  0
02AD8:  BRA    2972
02ADA:  MOVFF  03,64A
02ADE:  MOVFF  02,649
02AE2:  MOVFF  01,648
02AE6:  MOVFF  00,647
02AEA:  MOVLB  6
02AEC:  DECFSZ x4E,F
02AEE:  BRA    2ABA
02AF0:  MOVFF  64A,657
02AF4:  MOVFF  649,656
02AF8:  MOVFF  648,655
02AFC:  MOVFF  647,654
02B00:  MOVLB  0
02B02:  BRA    2A6A
02B04:  MOVFF  03,64A
02B08:  MOVFF  02,649
02B0C:  MOVFF  01,648
02B10:  MOVFF  00,647
02B14:  MOVLB  6
02B16:  BTFSS  x4A.7
02B18:  BRA    2B34
02B1A:  DECF   x4C,F
02B1C:  BSF    x4C.5
02B1E:  COMF   x47,F
02B20:  COMF   x48,F
02B22:  COMF   x49,F
02B24:  COMF   x4A,F
02B26:  INCF   x47,F
02B28:  BTFSC  FD8.2
02B2A:  INCF   x48,F
02B2C:  BTFSC  FD8.2
02B2E:  INCF   x49,F
02B30:  BTFSC  FD8.2
02B32:  INCF   x4A,F
02B34:  MOVLW  3B
02B36:  MOVWF  x53
02B38:  MOVLW  9A
02B3A:  MOVWF  x52
02B3C:  MOVLW  CA
02B3E:  MOVWF  x51
02B40:  CLRF   x50
02B42:  MOVLW  0A
02B44:  MOVWF  x4E
02B46:  MOVF   x4B,W
02B48:  BTFSC  FD8.2
02B4A:  INCF   x4C,F
02B4C:  BSF    FD8.1
02B4E:  MOVLW  06
02B50:  MOVWF  FEA
02B52:  MOVLW  47
02B54:  MOVWF  FE9
02B56:  CLRF   19
02B58:  BTFSC  FF2.7
02B5A:  BSF    19.7
02B5C:  BCF    FF2.7
02B5E:  MOVFF  64A,67B
02B62:  MOVFF  649,67A
02B66:  MOVFF  648,679
02B6A:  MOVFF  647,678
02B6E:  MOVFF  653,67F
02B72:  MOVFF  652,67E
02B76:  MOVFF  651,67D
02B7A:  MOVFF  650,67C
02B7E:  MOVLB  0
02B80:  CALL   0536
02B84:  BTFSC  19.7
02B86:  BSF    FF2.7
02B88:  MOVF   01,W
02B8A:  MOVF   00,F
02B8C:  BNZ   2BB4
02B8E:  MOVLB  6
02B90:  INCF   x4B,W
02B92:  SUBWF  x4E,W
02B94:  BTFSS  FD8.2
02B96:  BRA    2B9C
02B98:  MOVLB  0
02B9A:  BRA    2BB4
02B9C:  MOVF   x4C,W
02B9E:  BZ    2BBA
02BA0:  ANDLW  0F
02BA2:  SUBWF  x4E,W
02BA4:  BZ    2BA8
02BA6:  BC    2C20
02BA8:  BTFSC  x4C.7
02BAA:  BRA    2C20
02BAC:  BTFSC  x4C.6
02BAE:  BRA    2BBA
02BB0:  MOVLW  20
02BB2:  BRA    2C16
02BB4:  MOVLW  20
02BB6:  MOVLB  6
02BB8:  ANDWF  x4C,F
02BBA:  BTFSS  x4C.5
02BBC:  BRA    2BD8
02BBE:  BCF    x4C.5
02BC0:  MOVF   x4B,W
02BC2:  BTFSS  FD8.2
02BC4:  DECF   x4C,F
02BC6:  MOVF   00,W
02BC8:  MOVWF  x4C
02BCA:  MOVLW  2D
02BCC:  BTFSS  FA4.4
02BCE:  BRA    2BCC
02BD0:  MOVWF  F73
02BD2:  MOVF   x4C,W
02BD4:  MOVWF  00
02BD6:  CLRF   x4C
02BD8:  MOVF   x4B,W
02BDA:  SUBWF  x4E,W
02BDC:  BNZ   2BF4
02BDE:  MOVF   00,W
02BE0:  MOVWF  x4C
02BE2:  MOVLW  2E
02BE4:  BTFSS  FA4.4
02BE6:  BRA    2BE4
02BE8:  MOVWF  F73
02BEA:  MOVF   x4C,W
02BEC:  MOVWF  00
02BEE:  MOVLW  20
02BF0:  ANDWF  x4C,F
02BF2:  MOVLW  00
02BF4:  MOVLW  30
02BF6:  BTFSS  x4C.5
02BF8:  BRA    2C16
02BFA:  BCF    x4C.5
02BFC:  MOVF   x4B,W
02BFE:  BTFSS  FD8.2
02C00:  DECF   x4C,F
02C02:  MOVF   00,W
02C04:  MOVWF  x4C
02C06:  MOVLW  2D
02C08:  BTFSS  FA4.4
02C0A:  BRA    2C08
02C0C:  MOVWF  F73
02C0E:  MOVF   x4C,W
02C10:  MOVWF  00
02C12:  CLRF   x4C
02C14:  MOVLW  30
02C16:  ADDWF  00,F
02C18:  MOVF   00,W
02C1A:  BTFSS  FA4.4
02C1C:  BRA    2C1A
02C1E:  MOVWF  F73
02C20:  BCF    FD8.1
02C22:  CLRF   19
02C24:  BTFSC  FF2.7
02C26:  BSF    19.7
02C28:  BCF    FF2.7
02C2A:  MOVFF  653,67B
02C2E:  MOVFF  652,67A
02C32:  MOVFF  651,679
02C36:  MOVFF  650,678
02C3A:  CLRF   x7F
02C3C:  CLRF   x7E
02C3E:  CLRF   x7D
02C40:  MOVLW  0A
02C42:  MOVWF  x7C
02C44:  MOVLB  0
02C46:  CALL   0536
02C4A:  BTFSC  19.7
02C4C:  BSF    FF2.7
02C4E:  MOVFF  03,653
02C52:  MOVFF  02,652
02C56:  MOVFF  01,651
02C5A:  MOVFF  00,650
02C5E:  MOVLB  6
02C60:  DECFSZ x4E,F
02C62:  BRA    2B4C
02C64:  MOVLB  0
02C66:  GOTO   4A08 (RETURN)
*
04DA4:  MOVF   FE9,W
04DA6:  MOVLB  3
04DA8:  MOVWF  x1D
04DAA:  MOVLW  3B
04DAC:  MOVWF  x24
04DAE:  MOVLW  9A
04DB0:  MOVWF  x23
04DB2:  MOVLW  CA
04DB4:  MOVWF  x22
04DB6:  CLRF   x21
04DB8:  MOVLW  0A
04DBA:  MOVWF  x1F
04DBC:  BSF    FD8.1
04DBE:  MOVLW  03
04DC0:  MOVWF  FEA
04DC2:  MOVLW  19
04DC4:  MOVWF  FE9
04DC6:  CLRF   19
04DC8:  BTFSC  FF2.7
04DCA:  BSF    19.7
04DCC:  BCF    FF2.7
04DCE:  MOVFF  31C,67B
04DD2:  MOVFF  31B,67A
04DD6:  MOVFF  31A,679
04DDA:  MOVFF  319,678
04DDE:  MOVFF  324,67F
04DE2:  MOVFF  323,67E
04DE6:  MOVFF  322,67D
04DEA:  MOVFF  321,67C
04DEE:  MOVLB  0
04DF0:  CALL   0536
04DF4:  BTFSC  19.7
04DF6:  BSF    FF2.7
04DF8:  MOVF   01,W
04DFA:  MOVF   00,F
04DFC:  BNZ   4E24
04DFE:  MOVLB  3
04E00:  MOVF   x1F,W
04E02:  XORLW  01
04E04:  BTFSS  FD8.2
04E06:  BRA    4E0C
04E08:  MOVLB  0
04E0A:  BRA    4E24
04E0C:  MOVF   x1D,W
04E0E:  BZ    4E28
04E10:  ANDLW  0F
04E12:  SUBWF  x1F,W
04E14:  BZ    4E18
04E16:  BC    4E38
04E18:  BTFSC  x1D.7
04E1A:  BRA    4E38
04E1C:  BTFSC  x1D.6
04E1E:  BRA    4E28
04E20:  MOVLW  20
04E22:  BRA    4E2A
04E24:  MOVLB  3
04E26:  CLRF   x1D
04E28:  MOVLW  30
04E2A:  ADDWF  00,F
04E2C:  MOVFF  00,648
04E30:  MOVLB  0
04E32:  CALL   1408
04E36:  MOVLB  3
04E38:  BCF    FD8.1
04E3A:  CLRF   19
04E3C:  BTFSC  FF2.7
04E3E:  BSF    19.7
04E40:  BCF    FF2.7
04E42:  MOVFF  324,67B
04E46:  MOVFF  323,67A
04E4A:  MOVFF  322,679
04E4E:  MOVFF  321,678
04E52:  MOVLB  6
04E54:  CLRF   x7F
04E56:  CLRF   x7E
04E58:  CLRF   x7D
04E5A:  MOVLW  0A
04E5C:  MOVWF  x7C
04E5E:  MOVLB  0
04E60:  CALL   0536
04E64:  BTFSC  19.7
04E66:  BSF    FF2.7
04E68:  MOVFF  03,324
04E6C:  MOVFF  02,323
04E70:  MOVFF  01,322
04E74:  MOVFF  00,321
04E78:  MOVLB  3
04E7A:  DECFSZ x1F,F
04E7C:  BRA    4DBC
04E7E:  MOVLB  0
04E80:  GOTO   4EF6 (RETURN)
04E84:  TBLRD*+
04E86:  MOVFF  FF6,31A
04E8A:  MOVFF  FF7,31B
04E8E:  MOVFF  FF5,648
04E92:  CALL   1408
04E96:  MOVFF  31A,FF6
04E9A:  MOVFF  31B,FF7
04E9E:  MOVLB  3
04EA0:  DECFSZ x19,F
04EA2:  BRA    4EA6
04EA4:  BRA    4EAA
04EA6:  MOVLB  0
04EA8:  BRA    4E84
04EAA:  MOVLB  0
04EAC:  GOTO   4F08 (RETURN)
....................  
.................... #list 
....................  
.................... //#fuses HS,NOWDT,PROTECT,NODEBUG  // fuses  configurados          //for 18f452 ,NOBROWNOUT ,PUT 
.................... #device ADC=10                    // Set ADC 10 Bit 
....................  
.................... // ทำการ Setup fuse bit  เพื่อกำหนดการเริ่มต้นของ MCU 
.................... #FUSES NOWDT                     //No Watch Dog Timer 
.................... #FUSES WDT128                    //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSH                        //HS + 4x PLL 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... //#FUSES NOOSCSEN                  //Oscillator switching is disabled, main oscillator is source 
.................... #FUSES NOBROWNOUT                //No brownout reset 
.................... //#FUSES BORV20                   z //Brownout reset at 2.0V 
.................... #FUSES NOPUT                     //No Power Up Timer 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                   //No Debug mode for ICD 
.................... //#FUSES LVP                     //Low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads*/ 
....................  
.................... #use delay(clock=20000000,RESTART_WDT)           // oscillator for Boot Loader - กำหนดคล็อกของ MCU ให้ทำงานที่ 20 MHz 
*
01062:  MOVLW  06
01064:  MOVWF  FEA
01066:  MOVLW  4B
01068:  MOVWF  FE9
0106A:  MOVF   FEF,W
0106C:  BZ    1090
0106E:  MOVLW  06
01070:  MOVWF  01
01072:  MOVLW  BF
01074:  MOVWF  00
01076:  CLRWDT
01078:  DECFSZ 00,F
0107A:  BRA    1076
0107C:  DECFSZ 01,F
0107E:  BRA    1072
01080:  MOVLW  7A
01082:  MOVWF  00
01084:  DECFSZ 00,F
01086:  BRA    1084
01088:  BRA    108A
0108A:  CLRWDT
0108C:  DECFSZ FEF,F
0108E:  BRA    106E
01090:  RETURN 0
....................  
.................... #priority int_TIMER1,rda,rtcc,int_TIMER2,ad,rda2,int_TIMER3 
....................  
.................... //#use delay(clock=20000000) 
.................... #use rs232(baud=9600 ,xmit=pin_C6,rcv=pin_C7,stream=WIFI,errors)			// กำหนด Boudrate สำหรับ RS-232 
*
00A7A:  BTFSS  F9E.5
00A7C:  BRA    0A7A
00A7E:  MOVFF  FAB,1A
00A82:  MOVFF  FAE,01
00A86:  BTFSS  1A.1
00A88:  BRA    0A8E
00A8A:  BCF    FAB.4
00A8C:  BSF    FAB.4
00A8E:  GOTO   0A94 (RETURN)
.................... #use rs232(baud=57600 ,xmit=pin_D6,rcv=pin_D7,stream=ESP8266,errors)			//  
*
00B40:  BTFSS  FA4.5
00B42:  BRA    0B40
00B44:  MOVFF  F71,1A
00B48:  MOVFF  F74,01
00B4C:  BTFSS  1A.1
00B4E:  BRA    0B54
00B50:  BCF    F71.4
00B52:  BSF    F71.4
00B54:  GOTO   0B5A (RETURN)
....................  
.................... /* ------------------------------------------------------------------------- */ 
.................... /* map reset vector and interrupt vector                                     */ 
.................... /* 0x000-0x3FF is used by the bootloader. The bootloader maps the original   */ 
.................... /* reset vector (0x000) to 0x400 and the interrupt vector (0x008) to 0x408.  */ 
.................... /* ------------------------------------------------------------------------- */ 
.................... #build (reset=0x400, interrupt=0x408)										// เริ่มต้น reste vector ให้ไปที่ address 0x400 และอินเตอร์รัพเริ่มที่ address 0x408 
.................... /* ------------------------------------------------------------------------- */ 
.................... /* reserve boot block area                                                   */ 
.................... /* This memory range is used by the bootloader, so the application must not  */ 
.................... /* use this area.                                                            */ 
.................... /* ------------------------------------------------------------------------- */ 
.................... #org 0, 0x3FF {}															//เริ่มทำงานในส่วนโปรแกรม เมมโมรี่ที่ แอดเดรส 0 ไปจนถึง 0x3FF 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
01C7C:  MOVLB  6
01C7E:  MOVFF  646,FE9
01C82:  MOVFF  647,FEA
01C86:  MOVFF  FEF,64A
01C8A:  MOVFF  649,03
01C8E:  MOVFF  648,FE9
01C92:  MOVFF  649,FEA
01C96:  MOVF   FEF,W
01C98:  SUBWF  x4A,W
01C9A:  BNZ   1CC6
....................       if (*s1 == '\0') 
01C9C:  MOVFF  647,03
01CA0:  MOVFF  646,FE9
01CA4:  MOVFF  03,FEA
01CA8:  MOVF   FEF,F
01CAA:  BNZ   1CB2
....................          return(0); 
01CAC:  MOVLW  00
01CAE:  MOVWF  01
01CB0:  BRA    1CF0
01CB2:  MOVFF  647,03
01CB6:  MOVF   x46,W
01CB8:  INCF   x46,F
01CBA:  BTFSC  FD8.2
01CBC:  INCF   x47,F
01CBE:  INCF   x48,F
01CC0:  BTFSC  FD8.2
01CC2:  INCF   x49,F
01CC4:  BRA    1C7E
....................    return((*s1 < *s2) ? -1: 1); 
01CC6:  MOVFF  647,03
01CCA:  MOVFF  646,FE9
01CCE:  MOVFF  647,FEA
01CD2:  MOVFF  FEF,64A
01CD6:  MOVFF  649,03
01CDA:  MOVFF  648,FE9
01CDE:  MOVFF  649,FEA
01CE2:  MOVF   FEF,W
01CE4:  SUBWF  x4A,W
01CE6:  BC    1CEC
01CE8:  MOVLW  FF
01CEA:  BRA    1CEE
01CEC:  MOVLW  01
01CEE:  MOVWF  01
01CF0:  MOVLB  0
01CF2:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
01A3A:  MOVFF  648,03
01A3E:  MOVLB  6
01A40:  MOVFF  647,FE9
01A44:  MOVFF  648,FEA
01A48:  MOVF   x49,W
01A4A:  SUBWF  FEF,W
01A4C:  BZ    1A72
....................       if (*s == '\0') 
01A4E:  MOVFF  648,03
01A52:  MOVFF  647,FE9
01A56:  MOVFF  648,FEA
01A5A:  MOVF   FEF,F
01A5C:  BNZ   1A66
....................          return(0); 
01A5E:  MOVLW  00
01A60:  MOVWF  01
01A62:  MOVWF  02
01A64:  BRA    1A7A
01A66:  INCF   x47,F
01A68:  BTFSC  FD8.2
01A6A:  INCF   x48,F
01A6C:  MOVLB  0
01A6E:  BRA    1A3A
01A70:  MOVLB  6
....................    return(s); 
01A72:  MOVFF  647,01
01A76:  MOVFF  648,02
01A7A:  MOVLB  0
01A7C:  RETURN 0
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
01B0E:  MOVFF  64F,653
01B12:  MOVFF  64E,652
01B16:  MOVFF  653,03
01B1A:  MOVLB  6
01B1C:  MOVFF  652,FE9
01B20:  MOVFF  653,FEA
01B24:  MOVF   FEF,F
01B26:  BZ    1B7C
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
01B28:  MOVFF  651,655
01B2C:  MOVFF  650,654
01B30:  MOVFF  655,03
01B34:  MOVFF  654,FE9
01B38:  MOVFF  655,FEA
01B3C:  MOVF   FEF,F
01B3E:  BZ    1B70
....................          if (*sc1 == *sc2) 
01B40:  MOVFF  652,FE9
01B44:  MOVFF  653,FEA
01B48:  MOVFF  FEF,656
01B4C:  MOVFF  655,03
01B50:  MOVFF  654,FE9
01B54:  MOVFF  655,FEA
01B58:  MOVF   FEF,W
01B5A:  SUBWF  x56,W
01B5C:  BNZ   1B68
....................             return(sc1); 
01B5E:  MOVFF  652,01
01B62:  MOVFF  653,02
01B66:  BRA    1B82
01B68:  INCF   x54,F
01B6A:  BTFSC  FD8.2
01B6C:  INCF   x55,F
01B6E:  BRA    1B30
01B70:  INCF   x52,F
01B72:  BTFSC  FD8.2
01B74:  INCF   x53,F
01B76:  MOVLB  0
01B78:  BRA    1B16
01B7A:  MOVLB  6
....................    return(0); 
01B7C:  MOVLW  00
01B7E:  MOVWF  01
01B80:  MOVWF  02
01B82:  MOVLB  0
01B84:  GOTO   1C2A (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
01A7E:  MOVFF  64F,653
01A82:  MOVFF  64E,652
01A86:  MOVFF  653,03
01A8A:  MOVLB  6
01A8C:  MOVFF  652,FE9
01A90:  MOVFF  653,FEA
01A94:  MOVF   FEF,F
01A96:  BZ    1AF8
....................       for (sc2 = s2; ; sc2++) 
01A98:  MOVFF  651,655
01A9C:  MOVFF  650,654
....................     if (*sc2 == '\0') 
01AA0:  MOVFF  655,03
01AA4:  MOVFF  654,FE9
01AA8:  MOVFF  655,FEA
01AAC:  MOVF   FEF,F
01AAE:  BNZ   1AC4
....................        return(sc1 - s1); 
01AB0:  MOVF   x4E,W
01AB2:  SUBWF  x52,W
01AB4:  MOVWF  00
01AB6:  MOVF   x4F,W
01AB8:  SUBWFB x53,W
01ABA:  MOVWF  03
01ABC:  MOVFF  00,01
01AC0:  BRA    1B08
01AC2:  BRA    1AE4
....................          else if (*sc1 == *sc2) 
01AC4:  MOVFF  652,FE9
01AC8:  MOVFF  653,FEA
01ACC:  MOVFF  FEF,656
01AD0:  MOVFF  655,03
01AD4:  MOVFF  654,FE9
01AD8:  MOVFF  655,FEA
01ADC:  MOVF   FEF,W
01ADE:  SUBWF  x56,W
01AE0:  BNZ   1AE4
....................             break; 
01AE2:  BRA    1AEC
01AE4:  INCF   x54,F
01AE6:  BTFSC  FD8.2
01AE8:  INCF   x55,F
01AEA:  BRA    1AA0
01AEC:  INCF   x52,F
01AEE:  BTFSC  FD8.2
01AF0:  INCF   x53,F
01AF2:  MOVLB  0
01AF4:  BRA    1A86
01AF6:  MOVLB  6
....................    return(sc1 - s1); 
01AF8:  MOVF   x4E,W
01AFA:  SUBWF  x52,W
01AFC:  MOVWF  00
01AFE:  MOVF   x4F,W
01B00:  SUBWFB x53,W
01B02:  MOVWF  03
01B04:  MOVFF  00,01
01B08:  MOVLB  0
01B0A:  GOTO   1BF4 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
027EC:  MOVFF  647,03
027F0:  MOVLB  6
027F2:  MOVFF  646,FE9
027F6:  MOVFF  647,FEA
027FA:  MOVF   FEF,F
027FC:  BZ    2870
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
027FE:  MOVFF  647,64B
02802:  MOVFF  646,64A
02806:  MOVFF  649,64D
0280A:  MOVFF  648,64C
0280E:  MOVFF  64D,03
02812:  MOVFF  64C,FE9
02816:  MOVFF  64D,FEA
0281A:  MOVF   FEF,F
0281C:  BZ    284A
0281E:  MOVFF  64A,FE9
02822:  MOVFF  64B,FEA
02826:  MOVFF  FEF,64E
0282A:  MOVFF  64D,03
0282E:  MOVFF  64C,FE9
02832:  MOVFF  64D,FEA
02836:  MOVF   FEF,W
02838:  SUBWF  x4E,W
0283A:  BNZ   284A
0283C:  INCF   x4A,F
0283E:  BTFSC  FD8.2
02840:  INCF   x4B,F
02842:  INCF   x4C,F
02844:  BTFSC  FD8.2
02846:  INCF   x4D,F
02848:  BRA    280E
....................  
....................       if (*t == '\0') 
0284A:  MOVFF  64D,03
0284E:  MOVFF  64C,FE9
02852:  MOVFF  03,FEA
02856:  MOVF   FEF,F
02858:  BNZ   2864
....................          return s1; 
0285A:  MOVFF  646,01
0285E:  MOVFF  647,02
02862:  BRA    2876
....................       ++s1; 
02864:  INCF   x46,F
02866:  BTFSC  FD8.2
02868:  INCF   x47,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0286A:  MOVLB  0
0286C:  BRA    27EC
0286E:  MOVLB  6
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
02870:  MOVLW  00
02872:  MOVWF  01
02874:  MOVWF  02
02876:  MOVLB  0
02878:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
01B88:  MOVFF  64F,651
01B8C:  MOVFF  64E,650
01B90:  MOVFF  651,03
01B94:  MOVLB  6
01B96:  MOVFF  650,FE9
01B9A:  MOVFF  651,FEA
01B9E:  MOVF   FEF,F
01BA0:  BZ    1BAE
01BA2:  INCF   x50,F
01BA4:  BTFSC  FD8.2
01BA6:  INCF   x51,F
01BA8:  MOVLB  0
01BAA:  BRA    1B90
01BAC:  MOVLB  6
....................    return(sc - s); 
01BAE:  MOVF   x4E,W
01BB0:  SUBWF  x50,W
01BB2:  MOVWF  00
01BB4:  MOVF   x4F,W
01BB6:  SUBWFB x51,W
01BB8:  MOVWF  03
01BBA:  MOVFF  00,01
01BBE:  MOVWF  02
01BC0:  MOVLB  0
01BC2:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
01BC4:  MOVLB  6
01BC6:  MOVF   x46,W
01BC8:  IORWF  x47,W
01BCA:  BZ    1BD4
01BCC:  MOVFF  647,03
01BD0:  MOVF   x46,W
01BD2:  BRA    1BDA
01BD4:  MOVFF  1C,03
01BD8:  MOVF   1B,W
01BDA:  MOVWF  x4A
01BDC:  MOVFF  03,64B
....................    beg += strspn(beg, s2); 
01BE0:  MOVFF  64B,64F
01BE4:  MOVFF  64A,64E
01BE8:  MOVFF  649,651
01BEC:  MOVFF  648,650
01BF0:  MOVLB  0
01BF2:  BRA    1A7E
01BF4:  MOVF   01,W
01BF6:  MOVLB  6
01BF8:  ADDWF  x4A,F
01BFA:  MOVLW  00
01BFC:  ADDWFC x4B,F
....................    if (*beg == '\0') 
01BFE:  MOVFF  64B,03
01C02:  MOVFF  64A,FE9
01C06:  MOVFF  64B,FEA
01C0A:  MOVF   FEF,F
01C0C:  BNZ   1C16
....................       return(0); 
01C0E:  MOVLW  00
01C10:  MOVWF  01
01C12:  MOVWF  02
01C14:  BRA    1C78
....................        
....................    end = strpbrk(beg, s2); 
01C16:  MOVFF  64B,64F
01C1A:  MOVFF  64A,64E
01C1E:  MOVFF  649,651
01C22:  MOVFF  648,650
01C26:  MOVLB  0
01C28:  BRA    1B0E
01C2A:  MOVFF  02,64D
01C2E:  MOVFF  01,64C
....................    if (end != '\0') 
01C32:  MOVLB  6
01C34:  MOVF   x4C,F
01C36:  BNZ   1C3C
01C38:  MOVF   x4D,F
01C3A:  BZ    1C56
....................    { 
....................       *end = '\0'; 
01C3C:  MOVFF  64C,FE9
01C40:  MOVFF  64D,FEA
01C44:  CLRF   FEF
....................       end++; 
01C46:  INCF   x4C,F
01C48:  BTFSC  FD8.2
01C4A:  INCF   x4D,F
....................       save = end; 
01C4C:  MOVFF  64D,1C
01C50:  MOVFF  64C,1B
....................    } 
01C54:  BRA    1C70
....................    else 
....................       save = beg + strlen(beg); 
01C56:  MOVFF  64B,64F
01C5A:  MOVFF  64A,64E
01C5E:  MOVLB  0
01C60:  RCALL  1B88
01C62:  MOVF   01,W
01C64:  MOVLB  6
01C66:  ADDWF  x4A,W
01C68:  MOVWF  1B
01C6A:  MOVF   02,W
01C6C:  ADDWFC x4B,W
01C6E:  MOVWF  1C
....................     
....................    return(beg); 
01C70:  MOVFF  64A,01
01C74:  MOVFF  64B,02
01C78:  MOVLB  0
01C7A:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
01D44:  MOVLB  6
01D46:  CLRF   x4D
....................    sign = 0; 
01D48:  CLRF   x4B
....................    base = 10; 
01D4A:  MOVLW  0A
01D4C:  MOVWF  x4C
....................    result = 0; 
01D4E:  CLRF   x4A
....................  
....................    if (!s) 
01D50:  MOVF   x48,W
01D52:  IORWF  x49,W
01D54:  BNZ   1D5C
....................       return 0; 
01D56:  MOVLW  00
01D58:  MOVWF  01
01D5A:  BRA    1ED2
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
01D5C:  MOVF   x4D,W
01D5E:  INCF   x4D,F
01D60:  ADDWF  x48,W
01D62:  MOVWF  FE9
01D64:  MOVLW  00
01D66:  ADDWFC x49,W
01D68:  MOVWF  FEA
01D6A:  MOVFF  FEF,64E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
01D6E:  MOVF   x4E,W
01D70:  SUBLW  2D
01D72:  BNZ   1D8C
....................    { 
....................       sign = 1;         // Set the sign to negative 
01D74:  MOVLW  01
01D76:  MOVWF  x4B
....................       c = s[index++]; 
01D78:  MOVF   x4D,W
01D7A:  INCF   x4D,F
01D7C:  ADDWF  x48,W
01D7E:  MOVWF  FE9
01D80:  MOVLW  00
01D82:  ADDWFC x49,W
01D84:  MOVWF  FEA
01D86:  MOVFF  FEF,64E
....................    } 
01D8A:  BRA    1DA4
....................    else if (c == '+') 
01D8C:  MOVF   x4E,W
01D8E:  SUBLW  2B
01D90:  BNZ   1DA4
....................    { 
....................       c = s[index++]; 
01D92:  MOVF   x4D,W
01D94:  INCF   x4D,F
01D96:  ADDWF  x48,W
01D98:  MOVWF  FE9
01D9A:  MOVLW  00
01D9C:  ADDWFC x49,W
01D9E:  MOVWF  FEA
01DA0:  MOVFF  FEF,64E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
01DA4:  MOVF   x4E,W
01DA6:  SUBLW  2F
01DA8:  BTFSC  FD8.0
01DAA:  BRA    1EC2
01DAC:  MOVF   x4E,W
01DAE:  SUBLW  39
01DB0:  BTFSS  FD8.0
01DB2:  BRA    1EC2
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
01DB4:  MOVF   x4E,W
01DB6:  SUBLW  30
01DB8:  BNZ   1DF6
01DBA:  MOVF   x4D,W
01DBC:  ADDWF  x48,W
01DBE:  MOVWF  FE9
01DC0:  MOVLW  00
01DC2:  ADDWFC x49,W
01DC4:  MOVWF  FEA
01DC6:  MOVF   FEF,W
01DC8:  SUBLW  78
01DCA:  BZ    1DDE
01DCC:  MOVF   x4D,W
01DCE:  ADDWF  x48,W
01DD0:  MOVWF  FE9
01DD2:  MOVLW  00
01DD4:  ADDWFC x49,W
01DD6:  MOVWF  FEA
01DD8:  MOVF   FEF,W
01DDA:  SUBLW  58
01DDC:  BNZ   1DF6
....................       { 
....................          base = 16; 
01DDE:  MOVLW  10
01DE0:  MOVWF  x4C
....................          index++; 
01DE2:  INCF   x4D,F
....................          c = s[index++]; 
01DE4:  MOVF   x4D,W
01DE6:  INCF   x4D,F
01DE8:  ADDWF  x48,W
01DEA:  MOVWF  FE9
01DEC:  MOVLW  00
01DEE:  ADDWFC x49,W
01DF0:  MOVWF  FEA
01DF2:  MOVFF  FEF,64E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
01DF6:  MOVF   x4C,W
01DF8:  SUBLW  0A
01DFA:  BNZ   1E34
....................       { 
....................          while (c >= '0' && c <= '9') 
01DFC:  MOVF   x4E,W
01DFE:  SUBLW  2F
01E00:  BC    1E32
01E02:  MOVF   x4E,W
01E04:  SUBLW  39
01E06:  BNC   1E32
....................          { 
....................             result = 10*result + (c - '0'); 
01E08:  MOVLW  0A
01E0A:  MOVWF  x4F
01E0C:  MOVFF  64A,650
01E10:  MOVLB  0
01E12:  BRA    1CF4
01E14:  MOVLW  30
01E16:  MOVLB  6
01E18:  SUBWF  x4E,W
01E1A:  ADDWF  01,W
01E1C:  MOVWF  x4A
....................             c = s[index++]; 
01E1E:  MOVF   x4D,W
01E20:  INCF   x4D,F
01E22:  ADDWF  x48,W
01E24:  MOVWF  FE9
01E26:  MOVLW  00
01E28:  ADDWFC x49,W
01E2A:  MOVWF  FEA
01E2C:  MOVFF  FEF,64E
01E30:  BRA    1DFC
....................          } 
....................       } 
01E32:  BRA    1EC2
....................       else if (base == 16)    // The number is a hexa number 
01E34:  MOVF   x4C,W
01E36:  SUBLW  10
01E38:  BNZ   1EC2
....................       { 
....................          c = toupper(c); 
01E3A:  MOVF   x4E,W
01E3C:  SUBLW  60
01E3E:  BC    1E4C
01E40:  MOVF   x4E,W
01E42:  SUBLW  7A
01E44:  BNC   1E4C
01E46:  MOVF   x4E,W
01E48:  ANDLW  DF
01E4A:  BRA    1E4E
01E4C:  MOVF   x4E,W
01E4E:  MOVWF  x4E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
01E50:  MOVF   x4E,W
01E52:  SUBLW  2F
01E54:  BC    1E5C
01E56:  MOVF   x4E,W
01E58:  SUBLW  39
01E5A:  BC    1E68
01E5C:  MOVF   x4E,W
01E5E:  SUBLW  40
01E60:  BC    1EC2
01E62:  MOVF   x4E,W
01E64:  SUBLW  46
01E66:  BNC   1EC2
....................          { 
....................             if (c >= '0' && c <= '9') 
01E68:  MOVF   x4E,W
01E6A:  SUBLW  2F
01E6C:  BC    1E86
01E6E:  MOVF   x4E,W
01E70:  SUBLW  39
01E72:  BNC   1E86
....................                result = (result << 4) + (c - '0'); 
01E74:  SWAPF  x4A,W
01E76:  MOVWF  x4F
01E78:  MOVLW  F0
01E7A:  ANDWF  x4F,F
01E7C:  MOVLW  30
01E7E:  SUBWF  x4E,W
01E80:  ADDWF  x4F,W
01E82:  MOVWF  x4A
01E84:  BRA    1E98
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
01E86:  SWAPF  x4A,W
01E88:  MOVWF  x4F
01E8A:  MOVLW  F0
01E8C:  ANDWF  x4F,F
01E8E:  MOVLW  41
01E90:  SUBWF  x4E,W
01E92:  ADDLW  0A
01E94:  ADDWF  x4F,W
01E96:  MOVWF  x4A
....................  
....................             c = s[index++]; 
01E98:  MOVF   x4D,W
01E9A:  INCF   x4D,F
01E9C:  ADDWF  x48,W
01E9E:  MOVWF  FE9
01EA0:  MOVLW  00
01EA2:  ADDWFC x49,W
01EA4:  MOVWF  FEA
01EA6:  MOVFF  FEF,64E
....................             c = toupper(c); 
01EAA:  MOVF   x4E,W
01EAC:  SUBLW  60
01EAE:  BC    1EBC
01EB0:  MOVF   x4E,W
01EB2:  SUBLW  7A
01EB4:  BNC   1EBC
01EB6:  MOVF   x4E,W
01EB8:  ANDLW  DF
01EBA:  BRA    1EBE
01EBC:  MOVF   x4E,W
01EBE:  MOVWF  x4E
01EC0:  BRA    1E50
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
01EC2:  DECFSZ x4B,W
01EC4:  BRA    1ECE
01EC6:  MOVF   x4C,W
01EC8:  SUBLW  0A
01ECA:  BNZ   1ECE
....................        result = -result; 
01ECC:  NEGF   x4A
....................  
....................    return(result); 
01ECE:  MOVFF  64A,01
01ED2:  MOVLB  0
01ED4:  RETURN 0
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
02634:  MOVLB  6
02636:  CLRF   x51
02638:  CLRF   x50
0263A:  CLRF   x4F
0263C:  MOVLW  01
0263E:  MOVWF  x4E
02640:  CLRF   x53
02642:  CLRF   x54
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
02644:  BTFSS  x4A.7
02646:  BRA    267A
....................          sign=1;        // Check for negative number 
02648:  MOVLW  01
0264A:  MOVWF  x53
....................          num*=-1; 
0264C:  MOVFF  64A,659
02650:  MOVFF  649,658
02654:  MOVFF  648,657
02658:  MOVFF  647,656
0265C:  SETF   x5D
0265E:  SETF   x5C
02660:  SETF   x5B
02662:  SETF   x5A
02664:  MOVLB  0
02666:  BRA    24EC
02668:  MOVFF  03,64A
0266C:  MOVFF  02,649
02670:  MOVFF  01,648
02674:  MOVFF  00,647
02678:  MOVLB  6
....................      } 
....................  
....................      while(temp>0) { 
0267A:  MOVF   x4E,F
0267C:  BNZ   268A
0267E:  MOVF   x4F,F
02680:  BNZ   268A
02682:  MOVF   x50,F
02684:  BNZ   268A
02686:  MOVF   x51,F
02688:  BZ    275E
....................          temp=(num/base); 
0268A:  BCF    FD8.1
0268C:  MOVFF  64A,661
02690:  MOVFF  649,660
02694:  MOVFF  648,65F
02698:  MOVFF  647,65E
0269C:  CLRF   x65
0269E:  CLRF   x64
026A0:  CLRF   x63
026A2:  MOVFF  64B,662
026A6:  MOVLB  0
026A8:  RCALL  254A
026AA:  MOVFF  03,651
026AE:  MOVFF  02,650
026B2:  MOVFF  01,64F
026B6:  MOVFF  00,64E
....................          s[cnt]=(num%base)+'0';    // Conversion 
026BA:  MOVLB  6
026BC:  MOVF   x54,W
026BE:  ADDWF  x4C,W
026C0:  MOVWF  01
026C2:  MOVLW  00
026C4:  ADDWFC x4D,W
026C6:  MOVWF  03
026C8:  MOVFF  01,656
026CC:  MOVWF  x57
026CE:  MOVFF  FEA,659
026D2:  MOVFF  FE9,658
026D6:  BSF    FD8.1
026D8:  MOVLW  06
026DA:  MOVWF  FEA
026DC:  MOVLW  5A
026DE:  MOVWF  FE9
026E0:  MOVFF  64A,661
026E4:  MOVFF  649,660
026E8:  MOVFF  648,65F
026EC:  MOVFF  647,65E
026F0:  CLRF   x65
026F2:  CLRF   x64
026F4:  CLRF   x63
026F6:  MOVFF  64B,662
026FA:  MOVLB  0
026FC:  RCALL  254A
026FE:  MOVFF  659,FEA
02702:  MOVFF  658,FE9
02706:  MOVLW  30
02708:  MOVLB  6
0270A:  ADDWF  x5A,W
0270C:  MOVWF  00
0270E:  MOVLW  00
02710:  ADDWFC x5B,W
02712:  MOVLW  00
02714:  ADDWFC x5C,W
02716:  MOVLW  00
02718:  ADDWFC x5D,W
0271A:  MOVFF  657,FEA
0271E:  MOVFF  656,FE9
02722:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
02726:  MOVF   x54,W
02728:  ADDWF  x4C,W
0272A:  MOVWF  FE9
0272C:  MOVLW  00
0272E:  ADDWFC x4D,W
02730:  MOVWF  FEA
02732:  MOVF   FEF,W
02734:  SUBLW  39
02736:  BC    274A
....................             s[cnt]+=0x7; 
02738:  MOVF   x54,W
0273A:  ADDWF  x4C,W
0273C:  MOVWF  FE9
0273E:  MOVLW  00
02740:  ADDWFC x4D,W
02742:  MOVWF  FEA
02744:  MOVLW  07
02746:  ADDWF  FEF,W
02748:  MOVWF  FEF
....................  
....................          cnt++; 
0274A:  INCF   x54,F
....................          num=temp; 
0274C:  MOVFF  651,64A
02750:  MOVFF  650,649
02754:  MOVFF  64F,648
02758:  MOVFF  64E,647
0275C:  BRA    267A
....................      } 
....................  
....................      if(sign==1) { 
0275E:  DECFSZ x53,W
02760:  BRA    2774
....................          s[cnt]=0x2D;      // Negative sign 
02762:  MOVF   x54,W
02764:  ADDWF  x4C,W
02766:  MOVWF  FE9
02768:  MOVLW  00
0276A:  ADDWFC x4D,W
0276C:  MOVWF  FEA
0276E:  MOVLW  2D
02770:  MOVWF  FEF
....................          cnt++; 
02772:  INCF   x54,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
02774:  CLRF   x52
02776:  BCF    FD8.0
02778:  RRCF   x54,W
0277A:  SUBWF  x52,W
0277C:  BC    27D2
....................  
....................          c=s[i]; 
0277E:  MOVF   x52,W
02780:  ADDWF  x4C,W
02782:  MOVWF  FE9
02784:  MOVLW  00
02786:  ADDWFC x4D,W
02788:  MOVWF  FEA
0278A:  MOVFF  FEF,655
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0278E:  MOVF   x52,W
02790:  ADDWF  x4C,W
02792:  MOVWF  01
02794:  MOVLW  00
02796:  ADDWFC x4D,W
02798:  MOVWF  03
0279A:  MOVF   x52,W
0279C:  SUBWF  x54,W
0279E:  ADDLW  FF
027A0:  ADDWF  x4C,W
027A2:  MOVWF  FE9
027A4:  MOVLW  00
027A6:  ADDWFC x4D,W
027A8:  MOVWF  FEA
027AA:  MOVFF  FEF,658
027AE:  MOVFF  03,FEA
027B2:  MOVFF  01,FE9
027B6:  MOVFF  658,FEF
....................          s[cnt-i-1]=c; 
027BA:  MOVF   x52,W
027BC:  SUBWF  x54,W
027BE:  ADDLW  FF
027C0:  ADDWF  x4C,W
027C2:  MOVWF  FE9
027C4:  MOVLW  00
027C6:  ADDWFC x4D,W
027C8:  MOVWF  FEA
027CA:  MOVFF  655,FEF
027CE:  INCF   x52,F
027D0:  BRA    2776
....................      } 
....................      s[cnt]='\0';     // End the string 
027D2:  MOVF   x54,W
027D4:  ADDWF  x4C,W
027D6:  MOVWF  FE9
027D8:  MOVLW  00
027DA:  ADDWFC x4D,W
027DC:  MOVWF  FEA
027DE:  CLRF   FEF
....................      return s; 
027E0:  MOVFF  64C,01
027E4:  MOVFF  64D,02
027E8:  MOVLB  0
027EA:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "HCMQTT_Header.h" 
.................... //Home Control Project Header 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #BYTE PA=5 
.................... #BYTE PB=6 
.................... #BYTE PC=7 
.................... #BYTE PD=8 
.................... #BYTE PE=9 
....................  
....................  
....................  
.................... #define Alert1			PIN_A1 
.................... #define Alert2			PIN_A2 
.................... #define Alert3 			PIN_A3 
....................  
.................... #define SIREN   		PIN_A4			//Output 
....................  
.................... #define WIFI_RESET   	PIN_E0 
.................... #define ESP8266_RESET   PIN_E1 
.................... #define ESP8266_Connect PIN_E2			//Input 
....................  
.................... #define OP1			PIN_D0 
.................... #define OP2			PIN_D1 
.................... #define OP3			PIN_D2 
.................... #define OP4			PIN_C3 
.................... #define OP5			PIN_C4 
.................... #define OP6			PIN_C5 
.................... #define OP7			PIN_D4 
.................... #define OP8			PIN_D5 
....................  
.................... #define COMMAND_SIZE 500 
.................... #define INTERNAL 'I' 
.................... #define WIRELESS 'W' 
.................... #define LIVOLO 'L' 
....................  
.................... #define SWITCH_ON 'N' 
.................... #define SWITCH_OFF 'F' 
.................... #define SWITCH_TOGGLE 'T' 
....................  
....................  
.................... int internalSwitch[6] = {PIN_D0, PIN_D1, PIN_D2, PIN_C3,PIN_C4, PIN_C5}; 
.................... int internalSwitchStatus[10] = {0,0,0,0,0,0,0,0,0,0}; 
.................... int wirelessSwitchStatus[10] = {0,0,0,0,0,0,0,0,0,0}; 
.................... int livoloSwitchStatus[10] = {0,0,0,0,0,0,0,0,0,0}; 
....................  
.................... int saveInternalSwitchStatusAddress[10] = {21,22,23,24,25,26,27,28,29,30}; 
.................... int saveWirelessSwitchStatusAddress[10] = {31,32,33,34,35,36,37,38,39,40}; 
.................... int saveLivoloSwitchStatusAddress[10] = {41,42,43,44,45,46,47,48,49,50}; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... int16 lastTrigDate[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... int8 waitingSlaveCounter[10] = {0,0,0,0,0,0,0,0,0,0}; 
.................... char* uuids[20] ; 
.................... //BYTE SW_flag[NO_OF_SW] = {0,0,0,0,0,0,0,0}; 
....................  
.................... int i; 
.................... int32 connection_cnt = 0; 
....................  
.................... int16 Request_Update_Info = 0; 
.................... int1 MQTTConnect_Flag = true; 
.................... int1 UpdateRTC_flag = true; 
....................  
.................... //Variable Temp_DS1820 
.................... //==================== 
.................... int temp; 
.................... unsigned long raw_temp; 
.................... char temp_Display[2]; 
.................... float temperature;  
....................  
.................... float voltage = 0; 
....................  
.................... int1 Boot_Flag = false; 
.................... int1 WaitingWireless_Flag = false; 
.................... int1 Siren_Flag = false; 
.................... int Siren_cnt = 0; 
....................  
.................... long Alert1_Cnt = 0; 
.................... long Alert2_Cnt = 0; 
.................... long Alert3_Cnt = 0; 
....................  
.................... int Alert1_Flag = false; 
.................... int Alert2_Flag = false; 
.................... int Alert3_Flag = false; 
.................... int1 HomeLock_Flag = false; 
.................... int1 DoAlert_Flag = false; 
....................  
....................  
....................  
.................... int timerEnableEEPROM[20] = {501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520}; 
.................... int timerSwitchNumberEEPROM[20] = {521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540}; 
.................... int timerDeviceTypeEEPROM[20] = {541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560}; 
.................... int timerControlModeEEPROM[20] = {561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580}; 
.................... int timerHourEEPROM[20] = {581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600}; 
.................... int timerMinuteEEPROM[20] = {601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620}; 
.................... int timerRecurrentEEPROM[20] = {621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640}; 
.................... //{641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660}; 
.................... //{661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680}; 
.................... //{681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700}; 
.................... //{701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720}; 
....................  
....................  
.................... char activeTimerSwitch[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
....................  
....................  
....................  
.................... char day_Display[2]; 
.................... char mth_Display[2]; 
.................... char year_Display[2]; 
....................  
.................... char hour_Display[2]; 
.................... char min_Display[2]; 
.................... char sec_Display[2]; 
....................  
.................... int SETSW_Secure[10]; 
....................  
.................... #define FWVERSIONADDR1 1 
.................... #define FWVERSIONADDR2 2 
.................... #define FWVERSIONADDR3 3 
.................... #define FWVERSIONADDR4 4 
.................... #define FWVERSIONADDR5 5 
....................  
.................... //=================================== 
.................... //Reserve Address for IR Save 61 - 84 
.................... //=================================== 
....................  
.................... #define HomeSecureAddress	95 
.................... //=================================== 
.................... //Reserve Address for SETSWSC 100 - 110 
.................... //=================================== 
.................... #define SETSWSCAddress 100 
....................  
.................... #define TempHighAddress		115 
....................  
.................... #define VLOWAddress			116 
.................... #define VLOWPointAddress	117 
....................  
.................... #define VHIGHAddress		118 
.................... #define VHIGHPointAddress	119 
....................  
.................... #define UPGRADE_ADDRESS		255 
....................  
.................... #include "LCD_I2C_20x4.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // This is the simple CCS program for I2C (PCF8574T) lcd module  
.................... // Auther: Pumrin S. 
.................... // Pin map:  
.................... // PCF8574T > 20x4 LCD 
.................... //   P0     >   RS 
.................... //   P1     >   R/W 
.................... //   P2     >   E 
.................... //   P3     >   NC 
.................... //   P4     >   D4 
.................... //   P5     >   D5 
.................... //   P6     >   D6 
.................... //   P7     >   D7 
.................... // Note: The SCL and SDA pins should be pull-up resister allway.  
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #use I2C (master, sda = PIN_B4, scl = PIN_D3) 
*
01092:  MOVLW  08
01094:  MOVWF  01
01096:  MOVLW  05
01098:  MOVWF  00
0109A:  DECFSZ 00,F
0109C:  BRA    109A
0109E:  BCF    F8C.3
010A0:  BCF    F95.3
010A2:  MOVLW  06
010A4:  MOVWF  00
010A6:  DECFSZ 00,F
010A8:  BRA    10A6
010AA:  MOVLB  6
010AC:  RLCF   x4C,F
010AE:  BCF    F8A.4
010B0:  BTFSC  FD8.0
010B2:  BSF    F93.4
010B4:  BTFSS  FD8.0
010B6:  BCF    F93.4
010B8:  BSF    F95.3
010BA:  BTFSS  F83.3
010BC:  BRA    10BA
010BE:  DECFSZ 01,F
010C0:  BRA    10C4
010C2:  BRA    10C8
010C4:  MOVLB  0
010C6:  BRA    1096
010C8:  MOVLW  05
010CA:  MOVWF  00
010CC:  DECFSZ 00,F
010CE:  BRA    10CC
010D0:  BCF    F8C.3
010D2:  BCF    F95.3
010D4:  NOP   
010D6:  BSF    F93.4
010D8:  MOVLW  06
010DA:  MOVWF  00
010DC:  DECFSZ 00,F
010DE:  BRA    10DC
010E0:  MOVLW  06
010E2:  MOVWF  00
010E4:  DECFSZ 00,F
010E6:  BRA    10E4
010E8:  BSF    F95.3
010EA:  BTFSS  F83.3
010EC:  BRA    10EA
010EE:  CLRF   01
010F0:  MOVLW  06
010F2:  MOVWF  00
010F4:  DECFSZ 00,F
010F6:  BRA    10F4
010F8:  BTFSC  F81.4
010FA:  BSF    01.0
010FC:  BCF    F8C.3
010FE:  BCF    F95.3
01100:  BCF    F8A.4
01102:  BCF    F93.4
01104:  MOVLB  0
01106:  RETURN 0
....................  
.................... #define LCDADDR        0x70 // default slave address 
.................... #define ON             0x08  
.................... #define OFF            0x00 
....................  
.................... #define LCD_SET_BIT(x)    fetch_data(x) 
....................  
.................... byte LCD_ADDR=0x4e; //I2C slave address for Funduino LCD module  
....................  
.................... //*** START LCD Command *** 
.................... #define  LCD_CLEAR_SCREEN   0B00000001 
.................... #define  LCD_RETURN_HOME    0B00000010 
....................  
.................... //Entry mode set (BIT2=1) 
.................... #define  LCD_ENTRY_MODE     0B00000100 
.................... #define  INCREMENTS_LCD     0B00000010 
.................... #define  DECREMENTS_LCD     0B00000000 
.................... #define  NO_SCROLL_LCD      0B00000000 
.................... #define  SCROLL_LCD         0B00000001 
....................  
.................... //Display ON/OFF (BIT3=1) 
.................... #define  DISPLAY_LCD        0B00001000 
.................... #define  LCD_ON             0B00000100 
.................... #define  LCD_OFF            0B00000000 
.................... #define  LCD_CURSOR_ON      0B00000010 
.................... #define  LCD_CURSOR_OFF     0B00000000 
.................... #define  LCD_BLINK_ON       0B00000001 
.................... #define  LCD_BLINK_OFF      0B00000000 
....................  
.................... //Scroll Display/Shift Cursor (BIT4=1) 
.................... #define  LCD_SCROLL_SHIFT   0B00010000 
.................... #define  LCD_SHIFT_CURSOR   0B00000000 
.................... #define  LCD_SHIFT_DISPLAY  0B00001000 
.................... #define  LCD_SHIFT_LEFT     0B00000000 
.................... #define  LCD_SHIFT_RIGHT    0B00000100 
....................  
.................... //Function set (BIT5=1) 
.................... #define  LCD_FUNCTION_SET   0B00100000 
.................... #define  LCD4BIT_MODE       0B00000000 
.................... #define  LCD8BIT_MODE       0B00010000 
.................... #define  LCD_LINE1          0B00000000 
.................... #define  LCD_LINE2          0B00001000 
.................... #define  LCD_FONT_5X7       0B00000000 
.................... #define  LCD_FONT_5X10      0B00000100 
....................  
.................... //Move To CGRAM Address (BIT6=1) 
.................... #define  LCD_CGRAM_ADDRESS  0B01000000 
....................  
.................... //Move To DDRAM Address (BIT7=1) 
.................... #define  LCD_DDRAM_ADDRESS  0B10000000 
....................  
.................... //*** END LCD Command *** 
....................  
.................... // Prepare x,y address byte 
.................... //line1=80h, line2=C0h line3=94h, line4=D4h 
.................... //   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 
.................... //1 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 
.................... //2 C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 
.................... //3 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 
.................... //4 D4 D5 D6 D7 D8 D9 DA DB DC DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 
....................  
.................... byte line_1[20]={0x80,0x81,0x82,0x83,0x84, 
....................                  0x85,0x86,0x87,0x88,0x89, 
....................                  0x8A,0x8B,0x8C,0x8D,0x8E,  
....................                  0x8F,0x90,0x91,0x92,0x93}; 
.................... byte line_2[20]={0xC0,0xC1,0xC2,0xC3,0xC4, 
....................                  0xC5,0xC6,0xC7,0xC8,0xC9, 
....................                  0xCA,0xCB,0xCC,0xCD,0xCE, 
....................                  0xCF,0xD0,0xD1,0xD2,0xD3}; 
.................... byte line_3[20]={0x94,0x95,0x96,0x97,0x98, 
....................                  0x99,0x9A,0x9B,0x9C,0x9D, 
....................                  0x9E,0x9F,0xA0,0xA1,0xA2, 
....................                  0xA3,0xA4,0xA5,0xA6,0xA7};   
.................... byte line_4[20]={0xD4,0xD5,0xD6,0xD7,0xD8, 
....................                  0xD9,0xDA,0xDB,0xDC,0xDE, 
....................                  0xDF,0xE0,0xE1,0xE2,0xE3, 
....................                  0xE4,0xE5,0xE6,0xE7,0xE8}; 
....................  
.................... //Transmittion data 
.................... void transceiver(unsigned char data) 
....................    { 
....................          
....................         i2c_start(); 
01108:  BSF    F93.4
0110A:  MOVLW  05
0110C:  MOVWF  00
0110E:  DECFSZ 00,F
01110:  BRA    110E
01112:  BSF    F95.3
01114:  MOVLW  06
01116:  MOVWF  00
01118:  DECFSZ 00,F
0111A:  BRA    1118
0111C:  BCF    F8A.4
0111E:  BCF    F93.4
01120:  MOVLW  05
01122:  MOVWF  00
01124:  DECFSZ 00,F
01126:  BRA    1124
01128:  BCF    F8C.3
0112A:  BCF    F95.3
....................         i2c_write(LCD_ADDR); //the slave addresse 
0112C:  MOVFF  194,64C
01130:  RCALL  1092
....................         i2c_write(data);     
01132:  MOVFF  64B,64C
01136:  RCALL  1092
....................         i2c_stop(); 
01138:  BCF    F93.4
0113A:  NOP   
0113C:  BSF    F95.3
0113E:  BTFSS  F83.3
01140:  BRA    113E
01142:  MOVLW  05
01144:  MOVWF  00
01146:  DECFSZ 00,F
01148:  BRA    1146
0114A:  BRA    114C
0114C:  NOP   
0114E:  BSF    F93.4
01150:  MOVLW  05
01152:  MOVWF  00
01154:  DECFSZ 00,F
01156:  BRA    1154
01158:  RETURN 0
....................    } 
....................  
.................... //Clocking the LCD's enable pin during transmit data 
.................... void fetch_data(unsigned char data) 
....................    { 
....................         data=data|0b00000100;//set pin E is a 1 
0115A:  MOVLB  6
0115C:  BSF    x4A.2
....................         transceiver(data); 
0115E:  MOVFF  64A,64B
01162:  MOVLB  0
01164:  RCALL  1108
....................         delay_ms(1); 
01166:  MOVLW  01
01168:  MOVLB  6
0116A:  MOVWF  x4B
0116C:  MOVLB  0
0116E:  RCALL  1062
....................         data=data-4;//toggle E back to 0 
01170:  MOVLW  04
01172:  MOVLB  6
01174:  SUBWF  x4A,F
....................         transceiver(data); 
01176:  MOVFF  64A,64B
0117A:  MOVLB  0
0117C:  RCALL  1108
....................         delay_ms(1); 
0117E:  MOVLW  01
01180:  MOVLB  6
01182:  MOVWF  x4B
01184:  MOVLB  0
01186:  RCALL  1062
01188:  RETURN 0
....................  
....................    } 
....................  
.................... void lcd_init() 
.................... { 
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         LCD_SET_BIT(0x00); 
0118A:  MOVLB  6
0118C:  CLRF   x4A
0118E:  MOVLB  0
01190:  RCALL  115A
....................         LCD_SET_BIT(0x10); 
01192:  MOVLW  10
01194:  MOVLB  6
01196:  MOVWF  x4A
01198:  MOVLB  0
0119A:  RCALL  115A
....................         LCD_SET_BIT(0x00); 
0119C:  MOVLB  6
0119E:  CLRF   x4A
011A0:  MOVLB  0
011A2:  RCALL  115A
....................         LCD_SET_BIT(0x00); 
011A4:  MOVLB  6
011A6:  CLRF   x4A
011A8:  MOVLB  0
011AA:  RCALL  115A
....................         LCD_SET_BIT(0x10); 
011AC:  MOVLW  10
011AE:  MOVLB  6
011B0:  MOVWF  x4A
011B2:  MOVLB  0
011B4:  RCALL  115A
....................            //First state in 8 bit mode 
....................         LCD_SET_BIT(0x30); 
011B6:  MOVLW  30
011B8:  MOVLB  6
011BA:  MOVWF  x4A
011BC:  MOVLB  0
011BE:  RCALL  115A
....................         LCD_SET_BIT(0x30); 
011C0:  MOVLW  30
011C2:  MOVLB  6
011C4:  MOVWF  x4A
011C6:  MOVLB  0
011C8:  RCALL  115A
....................            //Then set to 4-bit mode 
....................         LCD_SET_BIT(0x30); 
011CA:  MOVLW  30
011CC:  MOVLB  6
011CE:  MOVWF  x4A
011D0:  MOVLB  0
011D2:  RCALL  115A
....................         LCD_SET_BIT(0x20); 
011D4:  MOVLW  20
011D6:  MOVLB  6
011D8:  MOVWF  x4A
011DA:  MOVLB  0
011DC:  RCALL  115A
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         LCD_SET_BIT(0x20); 
011DE:  MOVLW  20
011E0:  MOVLB  6
011E2:  MOVWF  x4A
011E4:  MOVLB  0
011E6:  RCALL  115A
....................         LCD_SET_BIT(0x80); 
011E8:  MOVLW  80
011EA:  MOVLB  6
011EC:  MOVWF  x4A
011EE:  MOVLB  0
011F0:  RCALL  115A
....................            //no need cursor on (0Ch) 
....................         LCD_SET_BIT(0x00); 
011F2:  MOVLB  6
011F4:  CLRF   x4A
011F6:  MOVLB  0
011F8:  RCALL  115A
....................         LCD_SET_BIT(0xC0); 
011FA:  MOVLW  C0
011FC:  MOVLB  6
011FE:  MOVWF  x4A
01200:  MOVLB  0
01202:  RCALL  115A
....................            //the cursor moves to the left (06 h) 
....................         LCD_SET_BIT(0x00); 
01204:  MOVLB  6
01206:  CLRF   x4A
01208:  MOVLB  0
0120A:  RCALL  115A
....................         LCD_SET_BIT(0x60); 
0120C:  MOVLW  60
0120E:  MOVLB  6
01210:  MOVWF  x4A
01212:  MOVLB  0
01214:  RCALL  115A
....................            //clears the display 
....................         LCD_SET_BIT(0x00); 
01216:  MOVLB  6
01218:  CLRF   x4A
0121A:  MOVLB  0
0121C:  RCALL  115A
....................         LCD_SET_BIT(0x10); 
0121E:  MOVLW  10
01220:  MOVLB  6
01222:  MOVWF  x4A
01224:  MOVLB  0
01226:  RCALL  115A
01228:  GOTO   52E0 (RETURN)
.................... } 
....................  
.................... void lcd_clear() 
.................... { 
....................     LCD_SET_BIT(0x00); 
....................     LCD_SET_BIT(0x10); 
.................... } 
....................  
.................... // Need the backlight lid. 
.................... void lcd_backlight(byte state) 
.................... { 
....................   LCD_SET_BIT(0x00); 
....................   LCD_SET_BIT(state); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void display(char in_data) 
.................... { 
....................         char data; 
....................         data=in_data&0xF0; 
*
01408:  MOVLB  6
0140A:  MOVF   x48,W
0140C:  ANDLW  F0
0140E:  MOVWF  x49
....................         data=data+1; //set RS pin to 1 
01410:  MOVLW  01
01412:  ADDWF  x49,F
....................         fetch_data(data); 
01414:  MOVFF  649,64A
01418:  MOVLB  0
0141A:  RCALL  115A
....................         data=in_data&0x0F; 
0141C:  MOVLB  6
0141E:  MOVF   x48,W
01420:  ANDLW  0F
01422:  MOVWF  x49
....................         data=data<<4; 
01424:  SWAPF  x49,F
01426:  MOVLW  F0
01428:  ANDWF  x49,F
....................         data=data+1; //set RS pin to 1 
0142A:  MOVLW  01
0142C:  ADDWF  x49,F
....................         fetch_data(data); 
0142E:  MOVFF  649,64A
01432:  MOVLB  0
01434:  RCALL  115A
01436:  RETURN 0
....................  
.................... } 
....................  
.................... //Make the x/y pointer  
.................... void lcd_goto_xy(byte x, byte y) 
.................... { 
....................   byte ptr1, ptr2; 
....................    
....................   fetch_data(0x10); 
*
01302:  MOVLW  10
01304:  MOVLB  6
01306:  MOVWF  x4A
01308:  MOVLB  0
0130A:  RCALL  115A
....................   fetch_data(0x00); 
0130C:  MOVLB  6
0130E:  CLRF   x4A
01310:  MOVLB  0
01312:  RCALL  115A
....................  
....................   switch(y) 
01314:  MOVLB  6
01316:  MOVF   x47,W
01318:  XORLW  01
0131A:  MOVLB  0
0131C:  BZ    132C
0131E:  XORLW  03
01320:  BZ    1358
01322:  XORLW  01
01324:  BZ    1384
01326:  XORLW  07
01328:  BZ    13B0
0132A:  BRA    13DE
....................   { 
....................    case 1: 
....................           ptr1=line_1[x]&0xF0;// stamp the high bit 
0132C:  CLRF   03
0132E:  MOVLB  6
01330:  MOVF   x46,W
01332:  ADDLW  95
01334:  MOVWF  FE9
01336:  MOVLW  01
01338:  ADDWFC 03,W
0133A:  MOVWF  FEA
0133C:  MOVF   FEF,W
0133E:  ANDLW  F0
01340:  MOVWF  x48
....................           ptr2=line_1[x]&0x0F;// stamp the low bit 
01342:  CLRF   03
01344:  MOVF   x46,W
01346:  ADDLW  95
01348:  MOVWF  FE9
0134A:  MOVLW  01
0134C:  ADDWFC 03,W
0134E:  MOVWF  FEA
01350:  MOVF   FEF,W
01352:  ANDLW  0F
01354:  MOVWF  x49
....................          
....................      break; 
01356:  BRA    13F2
....................  
....................    case 2: 
....................           ptr1=line_2[x]&0xF0; 
01358:  CLRF   03
0135A:  MOVLB  6
0135C:  MOVF   x46,W
0135E:  ADDLW  A9
01360:  MOVWF  FE9
01362:  MOVLW  01
01364:  ADDWFC 03,W
01366:  MOVWF  FEA
01368:  MOVF   FEF,W
0136A:  ANDLW  F0
0136C:  MOVWF  x48
....................           ptr2=line_2[x]&0x0F; 
0136E:  CLRF   03
01370:  MOVF   x46,W
01372:  ADDLW  A9
01374:  MOVWF  FE9
01376:  MOVLW  01
01378:  ADDWFC 03,W
0137A:  MOVWF  FEA
0137C:  MOVF   FEF,W
0137E:  ANDLW  0F
01380:  MOVWF  x49
....................           
....................      break; 
01382:  BRA    13F2
....................  
....................    case 3: 
....................           ptr1=line_3[x]&0xF0; 
01384:  CLRF   03
01386:  MOVLB  6
01388:  MOVF   x46,W
0138A:  ADDLW  BD
0138C:  MOVWF  FE9
0138E:  MOVLW  01
01390:  ADDWFC 03,W
01392:  MOVWF  FEA
01394:  MOVF   FEF,W
01396:  ANDLW  F0
01398:  MOVWF  x48
....................           ptr2=line_3[x]&0x0F; 
0139A:  CLRF   03
0139C:  MOVF   x46,W
0139E:  ADDLW  BD
013A0:  MOVWF  FE9
013A2:  MOVLW  01
013A4:  ADDWFC 03,W
013A6:  MOVWF  FEA
013A8:  MOVF   FEF,W
013AA:  ANDLW  0F
013AC:  MOVWF  x49
....................            
....................      break; 
013AE:  BRA    13F2
....................  
....................    case 4: 
....................           ptr1=line_4[x]&0xF0; 
013B0:  CLRF   03
013B2:  MOVLB  6
013B4:  MOVF   x46,W
013B6:  ADDLW  D1
013B8:  MOVWF  FE9
013BA:  MOVLW  01
013BC:  ADDWFC 03,W
013BE:  MOVWF  FEA
013C0:  MOVF   FEF,W
013C2:  ANDLW  F0
013C4:  MOVWF  x48
....................           ptr2=line_4[x]&0x0F; 
013C6:  CLRF   03
013C8:  MOVF   x46,W
013CA:  ADDLW  D1
013CC:  MOVWF  FE9
013CE:  MOVLW  01
013D0:  ADDWFC 03,W
013D2:  MOVWF  FEA
013D4:  MOVF   FEF,W
013D6:  ANDLW  0F
013D8:  MOVWF  x49
....................           
....................      break; 
013DA:  BRA    13F2
013DC:  MOVLB  0
....................  
....................    default: 
....................           fetch_data(0x80); 
013DE:  MOVLW  80
013E0:  MOVLB  6
013E2:  MOVWF  x4A
013E4:  MOVLB  0
013E6:  RCALL  115A
....................           fetch_data(0x00); 
013E8:  MOVLB  6
013EA:  CLRF   x4A
013EC:  MOVLB  0
013EE:  RCALL  115A
....................      break; 
013F0:  MOVLB  6
....................       
....................   } 
....................           ptr2=ptr2<<4; 
013F2:  SWAPF  x49,F
013F4:  MOVLW  F0
013F6:  ANDWF  x49,F
....................           fetch_data(ptr1); 
013F8:  MOVFF  648,64A
013FC:  MOVLB  0
013FE:  RCALL  115A
....................           fetch_data(ptr2);           
01400:  MOVFF  649,64A
01404:  RCALL  115A
01406:  RETURN 0
.................... }  
....................  
.................... #include "DS1302.c"								//นำเข้า ไลบารี DS1302 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define RTC_SCLK PIN_B5							// Demo board 
.................... #define RTC_IO   PIN_B3 
.................... #define RTC_RST  PIN_B2 
....................  
.................... BYTE day,mth,year,dow,hour,min,sec; 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
0122C:  MOVLB  6
0122E:  CLRF   x51
01230:  MOVF   x51,W
01232:  SUBLW  07
01234:  BNC   124A
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
01236:  BCF    FD8.0
01238:  RRCF   x50,F
0123A:  BC    1240
0123C:  BCF    F8A.3
0123E:  BRA    1242
01240:  BSF    F8A.3
....................       output_high(RTC_SCLK); 
01242:  BSF    F8A.5
....................       output_low(RTC_SCLK); 
01244:  BCF    F8A.5
01246:  INCF   x51,F
01248:  BRA    1230
....................    } 
0124A:  MOVLB  0
0124C:  RETURN 0
.................... } 
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
0124E:  BSF    F8A.2
....................    write_ds1302_byte(cmd); 
01250:  MOVFF  64E,650
01254:  RCALL  122C
....................    write_ds1302_byte(data); 
01256:  MOVFF  64F,650
0125A:  RCALL  122C
....................    output_low(RTC_RST); 
0125C:  BCF    F8A.2
0125E:  RETURN 0
.................... } 
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
01260:  BSF    F8A.2
....................    write_ds1302_byte(cmd); 
01262:  MOVFF  31D,650
01266:  RCALL  122C
....................     
....................    input(RTC_IO); 
....................    delay_us(1); 
01268:  CLRWDT
0126A:  BRA    126C
0126C:  BRA    126E
....................           
....................    for(i=0;i<=7;++i) { 
0126E:  MOVLB  3
01270:  CLRF   x1E
01272:  MOVF   x1E,W
01274:  SUBLW  07
01276:  BNC   12A4
....................       shift_right(&data,1,input(RTC_IO)); 
01278:  BTFSC  F81.3
0127A:  BRA    1280
0127C:  BCF    FD8.0
0127E:  BRA    1282
01280:  BSF    FD8.0
01282:  RRCF   x1F,F
....................       output_high(RTC_SCLK); 
01284:  BSF    F8A.5
....................       delay_us(2); 
01286:  CLRWDT
01288:  MOVLW  02
0128A:  MOVWF  00
0128C:  DECFSZ 00,F
0128E:  BRA    128C
01290:  BRA    1292
....................       output_low(RTC_SCLK); 
01292:  BCF    F8A.5
....................       delay_us(2); 
01294:  CLRWDT
01296:  MOVLW  02
01298:  MOVWF  00
0129A:  DECFSZ 00,F
0129C:  BRA    129A
0129E:  BRA    12A0
012A0:  INCF   x1E,F
012A2:  BRA    1272
....................    } 
....................    output_low(RTC_RST); 
012A4:  BCF    F8A.2
....................  
....................    return(data); 
012A6:  MOVFF  31F,01
012AA:  MOVLB  0
012AC:  RETURN 0
.................... } 
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
012AE:  BCF    F8A.2
....................    delay_us(2); 
012B0:  CLRWDT
012B2:  MOVLW  02
012B4:  MOVWF  00
012B6:  DECFSZ 00,F
012B8:  BRA    12B6
012BA:  BRA    12BC
....................    output_low(RTC_SCLK); 
012BC:  BCF    F8A.5
....................    write_ds1302(0x8e,0); 
012BE:  MOVLW  8E
012C0:  MOVLB  6
012C2:  MOVWF  x4E
012C4:  CLRF   x4F
012C6:  MOVLB  0
012C8:  RCALL  124E
....................    write_ds1302(0x90,0xa4); 
012CA:  MOVLW  90
012CC:  MOVLB  6
012CE:  MOVWF  x4E
012D0:  MOVLW  A4
012D2:  MOVWF  x4F
012D4:  MOVLB  0
012D6:  RCALL  124E
....................    x=read_ds1302(0x81); 
012D8:  MOVLW  81
012DA:  MOVLB  3
012DC:  MOVWF  x1D
012DE:  MOVLB  0
012E0:  RCALL  1260
012E2:  MOVFF  01,319
....................    if((x & 0x80)!=0) 
012E6:  MOVLB  3
012E8:  MOVF   x19,W
012EA:  ANDLW  80
012EC:  BZ    12FC
....................      write_ds1302(0x80,0); 
012EE:  MOVLW  80
012F0:  MOVLB  6
012F2:  MOVWF  x4E
012F4:  CLRF   x4F
012F6:  MOVLB  0
012F8:  RCALL  124E
012FA:  MOVLB  3
012FC:  MOVLB  0
012FE:  GOTO   52E4 (RETURN)
.................... } 
....................  
.................... byte get_bcd(BYTE data) 
*
0287A:  CLRF   19
0287C:  BTFSC  FF2.7
0287E:  BSF    19.7
02880:  BCF    FF2.7
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
02882:  MOVFF  64D,672
02886:  MOVLW  0A
02888:  MOVLB  6
0288A:  MOVWF  x73
0288C:  MOVLB  0
0288E:  CALL   073C
02892:  BTFSC  19.7
02894:  BSF    FF2.7
02896:  MOVFF  01,64E
....................    nibl=data-(nibh*10); 
0289A:  MOVLB  6
0289C:  MOVF   x4E,W
0289E:  MULLW  0A
028A0:  MOVF   FF3,W
028A2:  SUBWF  x4D,W
028A4:  MOVWF  x4F
....................  
....................    return((nibh<<4)|nibl); 
028A6:  SWAPF  x4E,W
028A8:  MOVWF  00
028AA:  MOVLW  F0
028AC:  ANDWF  00,F
028AE:  MOVF   00,W
028B0:  IORWF  x4F,W
028B2:  MOVWF  01
028B4:  MOVLB  0
028B6:  RETURN 0
.................... } 
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
*
04A72:  MOVFF  31E,31F
....................    data=(i>>4)*10; 
04A76:  MOVLB  3
04A78:  SWAPF  x1F,W
04A7A:  MOVWF  00
04A7C:  MOVLW  0F
04A7E:  ANDWF  00,F
04A80:  MOVF   00,W
04A82:  MULLW  0A
04A84:  MOVFF  FF3,31E
....................    data=data+(i<<4>>4); 
04A88:  SWAPF  x1F,W
04A8A:  MOVWF  00
04A8C:  MOVLW  F0
04A8E:  ANDWF  00,F
04A90:  MOVF   00,W
04A92:  SWAPF  00,F
04A94:  MOVLW  0F
04A96:  ANDWF  00,F
04A98:  MOVF   00,W
04A9A:  ADDWF  x1E,F
....................  
....................    return data; 
04A9C:  MOVFF  31E,01
04AA0:  MOVLB  0
04AA2:  RETURN 0
.................... } 
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min , BYTE sec) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
028B8:  MOVFF  646,64D
028BC:  RCALL  287A
028BE:  MOVFF  01,64D
028C2:  MOVLW  86
028C4:  MOVLB  6
028C6:  MOVWF  x4E
028C8:  MOVFF  01,64F
028CC:  MOVLB  0
028CE:  CALL   124E
....................    write_ds1302(0x88,get_bcd(mth)); 
028D2:  MOVFF  647,64D
028D6:  RCALL  287A
028D8:  MOVFF  01,64D
028DC:  MOVLW  88
028DE:  MOVLB  6
028E0:  MOVWF  x4E
028E2:  MOVFF  01,64F
028E6:  MOVLB  0
028E8:  CALL   124E
....................    write_ds1302(0x8c,get_bcd(year)); 
028EC:  MOVFF  648,64D
028F0:  RCALL  287A
028F2:  MOVFF  01,64D
028F6:  MOVLW  8C
028F8:  MOVLB  6
028FA:  MOVWF  x4E
028FC:  MOVFF  01,64F
02900:  MOVLB  0
02902:  CALL   124E
....................    write_ds1302(0x8a,get_bcd(dow)); 
02906:  MOVFF  649,64D
0290A:  RCALL  287A
0290C:  MOVFF  01,64D
02910:  MOVLW  8A
02912:  MOVLB  6
02914:  MOVWF  x4E
02916:  MOVFF  01,64F
0291A:  MOVLB  0
0291C:  CALL   124E
....................    write_ds1302(0x84,get_bcd(hr)); 
02920:  MOVFF  64A,64D
02924:  RCALL  287A
02926:  MOVFF  01,64D
0292A:  MOVLW  84
0292C:  MOVLB  6
0292E:  MOVWF  x4E
02930:  MOVFF  01,64F
02934:  MOVLB  0
02936:  CALL   124E
....................    write_ds1302(0x82,get_bcd(min)); 
0293A:  MOVFF  64B,64D
0293E:  RCALL  287A
02940:  MOVFF  01,64D
02944:  MOVLW  82
02946:  MOVLB  6
02948:  MOVWF  x4E
0294A:  MOVFF  01,64F
0294E:  MOVLB  0
02950:  CALL   124E
....................    write_ds1302(0x80,get_bcd(sec)); 
02954:  MOVFF  64C,64D
02958:  RCALL  287A
0295A:  MOVFF  01,64D
0295E:  MOVLW  80
02960:  MOVLB  6
02962:  MOVWF  x4E
02964:  MOVFF  01,64F
02968:  MOVLB  0
0296A:  CALL   124E
0296E:  GOTO   497C (RETURN)
.................... } 
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
04AA4:  MOVLW  87
04AA6:  MOVLB  3
04AA8:  MOVWF  x1D
04AAA:  MOVLB  0
04AAC:  CALL   1260
04AB0:  MOVFF  01,319
04AB4:  MOVFF  01,31E
04AB8:  RCALL  4A72
04ABA:  MOVFF  01,1E5
....................    mth = rm_bcd(read_ds1302(0x89)); 
04ABE:  MOVLW  89
04AC0:  MOVLB  3
04AC2:  MOVWF  x1D
04AC4:  MOVLB  0
04AC6:  CALL   1260
04ACA:  MOVFF  01,319
04ACE:  MOVFF  01,31E
04AD2:  RCALL  4A72
04AD4:  MOVFF  01,1E6
....................    year = rm_bcd(read_ds1302(0x8d)); 
04AD8:  MOVLW  8D
04ADA:  MOVLB  3
04ADC:  MOVWF  x1D
04ADE:  MOVLB  0
04AE0:  CALL   1260
04AE4:  MOVFF  01,319
04AE8:  MOVFF  01,31E
04AEC:  RCALL  4A72
04AEE:  MOVFF  01,1E7
....................    dow = rm_bcd(read_ds1302(0x8b)); 
04AF2:  MOVLW  8B
04AF4:  MOVLB  3
04AF6:  MOVWF  x1D
04AF8:  MOVLB  0
04AFA:  CALL   1260
04AFE:  MOVFF  01,319
04B02:  MOVFF  01,31E
04B06:  RCALL  4A72
04B08:  MOVFF  01,1E8
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
04B0C:  MOVLW  85
04B0E:  MOVLB  3
04B10:  MOVWF  x1D
04B12:  MOVLB  0
04B14:  CALL   1260
04B18:  MOVFF  01,319
04B1C:  MOVFF  01,31E
04B20:  RCALL  4A72
04B22:  MOVFF  01,1E9
....................    min = rm_bcd(read_ds1302(0x83)); 
04B26:  MOVLW  83
04B28:  MOVLB  3
04B2A:  MOVWF  x1D
04B2C:  MOVLB  0
04B2E:  CALL   1260
04B32:  MOVFF  01,319
04B36:  MOVFF  01,31E
04B3A:  RCALL  4A72
04B3C:  MOVFF  01,1EA
....................    sec = rm_bcd(read_ds1302(0x81)); 
04B40:  MOVLW  81
04B42:  MOVLB  3
04B44:  MOVWF  x1D
04B46:  MOVLB  0
04B48:  CALL   1260
04B4C:  MOVFF  01,319
04B50:  MOVFF  01,31E
04B54:  RCALL  4A72
04B56:  MOVFF  01,1EB
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
....................  
.................... #include "IRRemote.c"							//นำเข้า ไลบารี่ IR Remot 
.................... #define IR_TX 		PIN_C1 
....................  
.................... #define IR_INPUT 	PIN_B0         // the IR-Decoder has to be connected to an interrupt pin  
.................... #define IR_SIGNAL (!input(IR_INPUT))  // invert signal from IR-Receiver  
....................  
.................... #DEFINE IRTXON      set_tris_C(0b10000000); 
.................... #DEFINE IRTXOFF     set_tris_C(0b10000010); 
....................  
.................... int32 IR_Data; 
.................... int32 IR_Code; 
....................  
.................... int1 IR_Input_State = FALSE; 
.................... unsigned long bitcount; 
.................... int PULSE_MAX = 50; 
.................... int PULSE = 0; 
....................  
.................... int1 DoneLowState = true;	 
.................... int1 DoneHighState = true; 
.................... int1 DoneSignalLow = true; 
.................... int1 DoneHighWide = true; 
.................... int1 DoneHighNarrow = true; 
....................  
.................... int16 WaitHeadLowEdge; 
.................... int16 WaitHeadHighEdge; 
.................... int16 WaitSignalLow; 
.................... int16 WaitHighWide; 
.................... int16 WaitHighNarrow; 
....................  
.................... int1 Waiting_IR = true; 
.................... int1 Detect_IR_Flag = false; 
.................... int16 Waiting_IR_Count = 0; 
.................... int IR_Switch_CH; 
....................  
.................... long y; 
....................  
.................... int16 highEdge,lowEdge; 
.................... int16 HeadLowEdge,HeadHighEdge; 
....................  
.................... int16 Signal_high_wide; 
.................... int16 Signal_high_narrow; 
.................... int16 Signal_low; 
....................  
.................... #define REM_ADDRESS_DEFINE 61 
.................... int16 REM_ADDRESS;		//Strat at @61 
....................  
.................... int IR_Data_Read[5]; 
.................... int IR_LOAD_DATA[33]; 
.................... int32 IR_CH[8]; 
....................  
.................... void ir_get_fall(void); 
.................... void IR_Read(); 
.................... void IR_Send(); 
....................  
.................... #int_EXT  
.................... EXT_isr()  
.................... {  
.................... 	ir_get_fall(); 
*
009FE:  RCALL  04F6
....................  
.................... 	if(lowEdge > 20000 ) 
00A00:  MOVLB  2
00A02:  MOVF   x0B,W
00A04:  SUBLW  4D
00A06:  BC    0A24
00A08:  XORLW  FF
00A0A:  BNZ   0A12
00A0C:  MOVF   x0A,W
00A0E:  SUBLW  20
00A10:  BC    0A24
.................... 	{ 
.................... //    	output_high(LED2); 
....................  
.................... 	    HeadLowEdge = lowEdge; 
00A12:  MOVFF  20B,20D
00A16:  MOVFF  20A,20C
.................... 		IR_Input_State = TRUE; 
00A1A:  MOVLB  0
00A1C:  BSF    xC4.7
.................... 		disable_interrupts(INT_EXT); 
00A1E:  BCF    FF2.4
....................  
.................... 		IR_Read(); 
00A20:  BRA    07E6
00A22:  MOVLB  2
.................... 	} 
00A24:  BCF    FF2.1
00A26:  MOVLB  0
00A28:  GOTO   0484
.................... }  
.................... //====================================================================================== 
.................... void ir_get_fall(void 
.................... { 
.................... 		set_timer1(0); 
*
004F6:  CLRF   FCF
004F8:  CLRF   FCE
.................... 		while(IR_SIGNAL);          // wait for signal to go low  
004FA:  BTFSS  F81.0
004FC:  BRA    04FA
.................... 		lowEdge = get_timer1(); 
004FE:  MOVF   FCE,W
00500:  MOVLB  2
00502:  MOVWF  x0A
00504:  MOVFF  FCF,20B
00508:  MOVLB  0
0050A:  RETURN 0
.................... } 
.................... /*/====================================================================================== 
.................... void ir_get_rise(void) 
.................... { 
.................... 		set_timer1(0); 
.................... 		while(!IR_SIGNAL);          // wait for signal to go high    // RC2, CCP1, pin 17	 
.................... 		highEdge = get_timer1(); 
....................  
.................... }*/ 
....................  
.................... //======================================================================================= 
.................... void Load_IR_DATA() 
.................... { 
.................... 	REM_ADDRESS = REM_ADDRESS_DEFINE ; 
....................  
.................... 	for(int y=0; y<8; y++) 
.................... 	{ 
.................... 		for(i=0; i<4; i++) 
.................... 		{ 
.................... 			IR_LOAD_DATA[( y*4 ) + i ] = read_eeprom (REM_ADDRESS + ( y*4 ) + i); 
.................... 			//fprintf(WIFI,"\r\nIR_LOAD_DATA[%u] = read_eeprom (%lu) ,Data( %u )",(( y*4 ) + i), REM_ADDRESS + ( y*4 ) + i ,IR_LOAD_DATA[( y*4 ) + i ]);		//Debug 
.................... 		} 
.................... 	} 
....................  
.................... 	for(i=0; i<8; i++) 
.................... 	{ 
.................... 		IR_CH[i] = make32(IR_LOAD_DATA[( i*4 )+3],IR_LOAD_DATA[( i*4 )+2],IR_LOAD_DATA[( i*4 )+1],IR_LOAD_DATA[( i*4 )]); 
.................... 		delay_ms(10); 
.................... 		//fprintf(WIFI,"\n\rIR_CH[%u] = %lu",i,IR_CH[i]);		//Debug 
.................... 	} 
....................  
.................... } 
....................  
.................... //======================================================================================= 
.................... void IR_Save() 
.................... { 
.................... 	fprintf(WIFI,"\r\nIR_Switch_CH = %u",IR_Switch_CH); 
.................... 	REM_ADDRESS = REM_ADDRESS_DEFINE + ( IR_Switch_CH - 1 ) * 4;  
....................  
.................... 	for(i=0; i<4; i++) 
.................... 	{ 
.................... 		write_eeprom (REM_ADDRESS + i, IR_Data_Read[i]); 
.................... 		delay_ms(10); 
.................... 		//fprintf(WIFI,"\r\nIR_Save REM_ADDRESS = %lu , IR_Data_Read[%u] = %u",REM_ADDRESS + i,i,IR_Data_Read[i]); 
.................... 	} 
....................  
.................... 	Detect_IR_Flag = false; 
....................  
.................... 	Load_IR_DATA(); 
.................... } 
.................... //======================================================================================= 
.................... void Clear_IR_Save() 
.................... { 
.................... 	for(int y=0; y<8; y++) 
.................... 	{ 
.................... 		for(i=0; i<4; i++) 
.................... 		{ 
.................... 			write_eeprom (REM_ADDRESS_DEFINE + (y*4) + i, 0xFF); 
.................... 			delay_ms(10); 
.................... 			//fprintf(WIFI,"\r\nREM_ADDRESS = %lu , IR_Data_Read[%u] = 0xFF",((REM_ADDRESS + y*4)+i),i);		//Debug 
.................... 		} 
.................... 	} 
.................... 		 
.................... 	reset_cpu(); 
.................... } 
....................  
.................... //======================================================================================= 
.................... void IR_Read() 
.................... { 
.................... 			set_timer1(0); 
*
007E6:  CLRF   FCF
007E8:  CLRF   FCE
.................... 			while(!IR_SIGNAL);          // wait for signal to go high    // RC2, CCP1, pin 17 
007EA:  BTFSC  F81.0
007EC:  BRA    07EA
.................... 			HeadHighEdge = get_timer1(); 
007EE:  MOVF   FCE,W
007F0:  MOVLB  2
007F2:  MOVWF  x0E
007F4:  MOVFF  FCF,20F
....................  
.................... 			PULSE = 0; 
007F8:  MOVLB  1
007FA:  CLRF   xF7
.................... 			for(bitcount=0;bitcount<PULSE_MAX;bitcount++) 
007FC:  CLRF   xF5
007FE:  CLRF   xF4
00800:  MOVF   xF5,F
00802:  BTFSS  FD8.2
00804:  BRA    0900
00806:  MOVF   xF6,W
00808:  SUBWF  xF4,W
0080A:  BTFSC  FD8.0
0080C:  BRA    0900
.................... 			{ 
.................... 				ir_get_fall();	 
0080E:  MOVLB  0
00810:  RCALL  04F6
.................... 				Signal_low = lowEdge; 
00812:  MOVFF  20B,215
00816:  MOVFF  20A,214
....................  
.................... 				set_timer1(0); 
0081A:  CLRF   FCF
0081C:  CLRF   FCE
.................... 				while(!IR_SIGNAL) 
0081E:  BTFSS  F81.0
00820:  BRA    0844
.................... 				{ 
.................... 					if(get_timer1() > 57000)          // wait for signal to go high    // RC2, CCP1, pin 17 
00822:  MOVF   FCE,W
00824:  MOVFF  FCF,03
00828:  MOVLB  6
0082A:  MOVWF  x6C
0082C:  MOVF   FCF,W
0082E:  MOVWF  x6D
00830:  SUBLW  DD
00832:  BC    0840
00834:  XORLW  FF
00836:  BNZ   083E
00838:  MOVF   x6C,W
0083A:  SUBLW  A8
0083C:  BC    0840
.................... 					{ 
.................... 						goto StopRead;	 
0083E:  BRA    0902
.................... 					} 
00840:  MOVLB  0
00842:  BRA    081E
.................... 				} 
.................... 				 
.................... 				highEdge = get_timer1(); 
00844:  MOVF   FCE,W
00846:  MOVLB  2
00848:  MOVWF  x08
0084A:  MOVFF  FCF,209
.................... 				if(highEdge > 5000) 
0084E:  MOVF   x09,W
00850:  SUBLW  12
00852:  BC    089E
00854:  XORLW  FF
00856:  BNZ   085E
00858:  MOVF   x08,W
0085A:  SUBLW  88
0085C:  BC    089E
.................... 				{ 
.................... 					bit_set(IR_Data, bitcount); 
0085E:  CLRF   03
00860:  CLRF   02
00862:  CLRF   01
00864:  MOVLW  01
00866:  MOVWF  00
00868:  MOVLB  1
0086A:  MOVF   xF4,W
0086C:  MOVLB  6
0086E:  MOVWF  x6C
00870:  BZ    0880
00872:  BCF    FD8.0
00874:  RLCF   00,F
00876:  RLCF   01,F
00878:  RLCF   02,F
0087A:  RLCF   03,F
0087C:  DECFSZ x6C,F
0087E:  BRA    0872
00880:  MOVF   00,W
00882:  MOVLB  1
00884:  IORWF  xEC,F
00886:  MOVF   01,W
00888:  IORWF  xED,F
0088A:  MOVF   02,W
0088C:  IORWF  xEE,F
0088E:  MOVF   03,W
00890:  IORWF  xEF,F
.................... 					Signal_high_wide = highEdge; 
00892:  MOVFF  209,211
00896:  MOVFF  208,210
.................... 				} 
0089A:  BRA    08F2
0089C:  MOVLB  2
.................... 				else if(highEdge < 5000) 
0089E:  MOVF   x09,W
008A0:  SUBLW  13
008A2:  BNC   08F4
008A4:  BNZ   08AC
008A6:  MOVF   x08,W
008A8:  SUBLW  87
008AA:  BNC   08F4
.................... 				{ 
.................... 					bit_clear(IR_Data, bitcount); 
008AC:  CLRF   03
008AE:  CLRF   02
008B0:  CLRF   01
008B2:  MOVLW  01
008B4:  MOVWF  00
008B6:  MOVLB  1
008B8:  MOVF   xF4,W
008BA:  MOVLB  6
008BC:  MOVWF  x6C
008BE:  BZ    08CE
008C0:  BCF    FD8.0
008C2:  RLCF   00,F
008C4:  RLCF   01,F
008C6:  RLCF   02,F
008C8:  RLCF   03,F
008CA:  DECFSZ x6C,F
008CC:  BRA    08C0
008CE:  MOVLW  FF
008D0:  XORWF  00,F
008D2:  XORWF  01,F
008D4:  XORWF  02,F
008D6:  XORWF  03,F
008D8:  MOVF   00,W
008DA:  MOVLB  1
008DC:  ANDWF  xEC,F
008DE:  MOVF   01,W
008E0:  ANDWF  xED,F
008E2:  MOVF   02,W
008E4:  ANDWF  xEE,F
008E6:  MOVF   03,W
008E8:  ANDWF  xEF,F
.................... 					Signal_high_narrow = highEdge;	 
008EA:  MOVFF  209,213
008EE:  MOVFF  208,212
008F2:  MOVLB  2
.................... 				} 
....................  
.................... 				PULSE++; 
008F4:  MOVLB  1
008F6:  INCF   xF7,F
008F8:  INCF   xF4,F
008FA:  BTFSC  FD8.2
008FC:  INCF   xF5,F
008FE:  BRA    0800
00900:  MOVLB  6
....................  
.................... 			} 
.................... StopRead: delay_us(1); 
00902:  CLRWDT
00904:  BRA    0906
00906:  BRA    0908
.................... 		  delay_us(1); 
00908:  CLRWDT
0090A:  BRA    090C
0090C:  BRA    090E
....................  
.................... 		  	IR_Data_Read[3] = make8(IR_Data,3);  
0090E:  MOVFF  1EF,21B
00912:  MOVLB  2
.................... 			IR_Data_Read[2] = make8(IR_Data,2);  
00914:  MOVFF  1EE,21A
00918:  MOVLB  2
.................... 			IR_Data_Read[1] = make8(IR_Data,1);  
0091A:  MOVFF  1ED,219
0091E:  MOVLB  2
.................... 			IR_Data_Read[0] = make8(IR_Data,0);  
00920:  MOVFF  1EC,218
00924:  MOVLB  2
....................  
.................... 			Detect_IR_Flag = true; 
00926:  MOVLB  1
00928:  BSF    xF8.6
....................  
.................... 			fprintf(WIFI,"\n\rIR_Data = %lu\n",IR_Data);		//DEBUG 
0092A:  MOVLW  40
0092C:  MOVWF  FF6
0092E:  MOVLW  0A
00930:  MOVWF  FF7
00932:  MOVLW  0C
00934:  MOVLB  6
00936:  MOVWF  x6C
00938:  MOVLB  0
0093A:  RCALL  050C
0093C:  MOVLW  41
0093E:  MOVWF  FE9
00940:  MOVFF  1EF,66F
00944:  MOVFF  1EE,66E
00948:  MOVFF  1ED,66D
0094C:  MOVFF  1EC,66C
00950:  BRA    05CA
00952:  MOVLW  0A
00954:  BTFSS  F9E.4
00956:  BRA    0954
00958:  MOVWF  FAD
.................... 			fprintf(WIFI,"$MQTTYIRSEND,%lu,%lu,%lu,%lu,%lu,%u,1b",HeadLowEdge,HeadHighEdge,Signal_high_wide,Signal_high_narrow,Signal_low,PULSE); 
0095A:  MOVLW  52
0095C:  MOVWF  FF6
0095E:  MOVLW  0A
00960:  MOVWF  FF7
00962:  MOVLW  0D
00964:  MOVLB  6
00966:  MOVWF  x6C
00968:  MOVLB  0
0096A:  RCALL  050C
0096C:  MOVLW  10
0096E:  MOVWF  FE9
00970:  MOVFF  20D,66D
00974:  MOVFF  20C,66C
00978:  RCALL  0688
0097A:  MOVLW  2C
0097C:  BTFSS  F9E.4
0097E:  BRA    097C
00980:  MOVWF  FAD
00982:  MOVLW  10
00984:  MOVWF  FE9
00986:  MOVFF  20F,66D
0098A:  MOVFF  20E,66C
0098E:  RCALL  0688
00990:  MOVLW  2C
00992:  BTFSS  F9E.4
00994:  BRA    0992
00996:  MOVWF  FAD
00998:  MOVLW  10
0099A:  MOVWF  FE9
0099C:  MOVFF  211,66D
009A0:  MOVFF  210,66C
009A4:  RCALL  0688
009A6:  MOVLW  2C
009A8:  BTFSS  F9E.4
009AA:  BRA    09A8
009AC:  MOVWF  FAD
009AE:  MOVLW  10
009B0:  MOVWF  FE9
009B2:  MOVFF  213,66D
009B6:  MOVFF  212,66C
009BA:  RCALL  0688
009BC:  MOVLW  2C
009BE:  BTFSS  F9E.4
009C0:  BRA    09BE
009C2:  MOVWF  FAD
009C4:  MOVLW  10
009C6:  MOVWF  FE9
009C8:  MOVFF  215,66D
009CC:  MOVFF  214,66C
009D0:  RCALL  0688
009D2:  MOVLW  2C
009D4:  BTFSS  F9E.4
009D6:  BRA    09D4
009D8:  MOVWF  FAD
009DA:  MOVFF  1F7,66C
009DE:  MOVLW  1B
009E0:  MOVLB  6
009E2:  MOVWF  x6D
009E4:  MOVLB  0
009E6:  RCALL  0768
009E8:  MOVLW  75
009EA:  MOVWF  FF6
009EC:  MOVLW  0A
009EE:  MOVWF  FF7
009F0:  MOVLW  03
009F2:  MOVLB  6
009F4:  MOVWF  x6C
009F6:  MOVLB  0
009F8:  RCALL  050C
009FA:  GOTO   0A22 (RETURN)
....................  
.................... 			//enable_interrupts(INT_EXT);// turn on interrupts 
....................  
.................... } 
.................... //======================================================================================= 
.................... void IR_Decode_Data() 
.................... { 
.................... 	 
....................  
.................... 			Detect_IR_Flag = false; 
.................... 			IR_Input_State = FALSE; 
.................... 			enable_interrupts(INT_EXT);// turn on interrupts 
....................  
.................... } 
....................  
.................... //======================================================================================= 
.................... void LowSignalGen() 
.................... { 
.................... 			DoneSignalLow = true; 
.................... 			set_timer1(0); 
.................... 			while(DoneSignalLow) 
.................... 			{ 
.................... 				IRTXON;								// Enable IR TX 
.................... 				if(get_timer1() >= Signal_low) 
.................... 				{ 
.................... 					WaitSignalLow = get_timer1(); 
.................... 					DoneSignalLow = false; 
.................... 				} 
.................... 			} 
.................... } 
.................... //======================================================================================= 
.................... void HighWideGen() 
.................... { 
.................... 			DoneHighWide = true; 
.................... 			set_timer1(0); 
.................... 			while(DoneHighWide)	 
.................... 			{ 
.................... 				IRTXOFF; 
.................... 				if(get_timer1() >= Signal_high_wide) 
.................... 				{ 
.................... 					WaitHighWide = get_timer1(); 
.................... 					DoneHighWide = false; 
.................... 				} 
.................... 			} 
.................... } 
.................... //======================================================================================= 
.................... void HighNarrowGen() 
.................... { 
.................... 			DoneHighNarrow = true; 
.................... 			set_timer1(0); 
.................... 			while(DoneHighNarrow)	 
.................... 			{ 
.................... 				IRTXOFF; 
.................... 				if(get_timer1() >= Signal_high_narrow) 
.................... 				{ 
.................... 					WaitHighNarrow = get_timer1(); 
.................... 					DoneHighNarrow = false; 
.................... 				} 
.................... 			} 
.................... } 
.................... //======================================================================================= 
.................... void IR_Send() 
.................... { 
.................... 		      setup_ccp2(CCP_PWM); 
.................... 		      set_pwm2_duty(50);   //50% Duty Cycle 
.................... 		      setup_timer_2(T2_DIV_BY_1,134,1);//37100 Hz 
....................  
.................... 			  DoneLowState = true;	 
.................... 			  set_timer1(0);		   
....................               while(DoneLowState) 
.................... 			  {  
.................... 				IRTXON;  
.................... 				if(get_timer1() >= HeadLowEdge) 
.................... 				{ 
.................... 					//fprintf(WIFI,"\r\nWait_HeadLowEdge = %lu",get_timer1()); 
.................... 					WaitHeadLowEdge = get_timer1(); 
.................... 					DoneLowState = false; 
.................... 				} 
.................... 			  } 
.................... 			   
.................... 			  DoneHighState = true; 
.................... 			  set_timer1(0);				 
.................... 			  while(DoneHighState) 
.................... 			  {  
.................... 				IRTXOFF;  
.................... 				if(get_timer1() >= HeadHighEdge) 
.................... 				{ 
.................... 					WaitHeadHighEdge = get_timer1(); 
.................... 					DoneHighState = false; 
.................... 				} 
.................... 			  } 
....................  
.................... 			  for(bitcount=0; bitcount<PULSE; bitcount++) 
.................... 			  {			  
.................... 				 if(bit_test(IR_code,bitcount))		//Signal_Bit 1 
.................... 				 { 
.................... 				    LowSignalGen(); 
.................... 					HighWideGen(); 
.................... 				 } 
.................... 				 else 
.................... 				 { 
.................... 				    LowSignalGen(); 
.................... 					HighNarrowGen(); 
.................... 				 }	  
.................... 			  } 
....................  
.................... 			  // stop bit ***** 
.................... 		      LowSignalGen(); 
....................  
.................... 			  IRTXOFF; 
....................  
.................... 			  //fprintf(WIFI,"\r\nWaitHeadLowEdge = %lu",WaitHeadLowEdge); 
.................... 			  //fprintf(WIFI,"\r\nWaitHeadHighEdge = %lu",WaitHeadHighEdge); 
.................... 			  //fprintf(WIFI,"\r\nWaitHighWide = %lu",WaitHighWide); 
.................... 			  //fprintf(WIFI,"\r\nWaitHighNarrow = %lu",WaitHighNarrow); 
.................... 			  //fprintf(WIFI,"\r\nWaitSignalLow = %lu",WaitSignalLow); 
....................  
.................... } 
.................... //====================================================================================== 
....................  
....................  
.................... #include "WiFi_linker.c"						//นำเข้า ไลบารี่ WiFi Linker 
.................... int1 WIFI_Flag = false; 
....................  
....................  
.................... //replace above 
.................... char *wifiPtr; 
.................... char *wifiIndex; 
.................... int1 wifiReading = false; 
....................  
.................... //====================================================================================================== 
.................... //												Receive Data from U2 Process 
.................... #INT_RDA 
.................... void SeriaInput() 
*
00A92:  BRA    0A7A
00A94:  MOVFF  01,66C
.................... { 
....................    
.................... 	//get character from wifi Module 
.................... 	char wifiChar = getchar(); 
....................  
.................... 	//if get $ then start read command for processing 
.................... 	if(wifiChar == '$' || wifiChar == '&'){ 
00A98:  MOVLB  6
00A9A:  MOVF   x6C,W
00A9C:  SUBLW  24
00A9E:  BZ    0AA6
00AA0:  MOVF   x6C,W
00AA2:  SUBLW  26
00AA4:  BNZ   0AC6
.................... 		//pointer need to be reset before start storing 
.................... 		wifiIndex = wifiPtr; 
00AA6:  MOVFF  25F,261
00AAA:  MOVFF  25E,260
.................... 		*wifiIndex = wifiChar; 
00AAE:  MOVLB  2
00AB0:  MOVFF  260,FE9
00AB4:  MOVFF  261,FEA
00AB8:  MOVFF  66C,FEF
.................... 		wifiIndex++; 
00ABC:  INCF   x60,F
00ABE:  BTFSC  FD8.2
00AC0:  INCF   x61,F
.................... 		wifiReading = true; 
00AC2:  BSF    x62.0
.................... 	}else if(wifiReading == true){ 
00AC4:  BRA    0B00
00AC6:  MOVLB  2
00AC8:  BTFSS  x62.0
00ACA:  BRA    0B00
.................... 		*wifiIndex = wifiChar; 
00ACC:  MOVFF  260,FE9
00AD0:  MOVFF  261,FEA
00AD4:  MOVFF  66C,FEF
.................... 		wifiIndex++; 
00AD8:  INCF   x60,F
00ADA:  BTFSC  FD8.2
00ADC:  INCF   x61,F
.................... 		if(wifiChar == '*'){ 
00ADE:  MOVLB  6
00AE0:  MOVF   x6C,W
00AE2:  SUBLW  2A
00AE4:  BNZ   0AFE
.................... 			*wifiIndex = 0; 
00AE6:  MOVLB  2
00AE8:  MOVFF  260,FE9
00AEC:  MOVFF  261,FEA
00AF0:  CLRF   FEF
.................... 			wifiReading = false; 
00AF2:  BCF    x62.0
.................... 			WaitingWireless_Flag = false; 
00AF4:  MOVLB  0
00AF6:  BCF    xC4.3
.................... 			WIFI_Flag = true; 
00AF8:  MOVLB  1
00AFA:  BSF    xF8.7
00AFC:  MOVLB  6
00AFE:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
00B00:  BCF    F9E.5
00B02:  MOVLB  0
00B04:  GOTO   0484
.................... }  
....................  
.................... //======================================================================================================== 
.................... //  
.................... void Clear_Receive() 
.................... { 
.................... 	wifiIndex = wifiPtr; 
*
01EFC:  MOVFF  25F,261
01F00:  MOVFF  25E,260
.................... 	WIFI_Flag = false; 
01F04:  MOVLB  1
01F06:  BCF    xF8.7
01F08:  MOVLB  0
01F0A:  RETURN 0
....................  
.................... } 
.................... //======================================================================================================== 
.................... // 
.................... void WiFi_Receive() 
.................... { 
....................  
.................... 	int correct_data;								// สำหรับการคัดกรองข้อมูลที่ถูกต้องใส่ไว้ใน Memory 
.................... 	int datastart; 
....................  
....................  
.................... 	char tempCommand[COMMAND_SIZE], delimeter[2]; 
.................... 	char *command; 
....................  
.................... //for general switch 
.................... 	int8 switchNumber; 
.................... 	int8 switchControlMode; 
....................  
.................... 	char *ptr; 
.................... 	char *searchResultPtr; 
.................... 	char *uuid; 
....................  
.................... 	//Response from slave 
.................... 	char *responseCommandSwitch = "$MQSWCSR"; 
01F0C:  MOVLW  24
01F0E:  MOVLB  5
01F10:  MOVWF  x1D
01F12:  MOVLW  4D
01F14:  MOVWF  x1E
01F16:  MOVLW  51
01F18:  MOVWF  x1F
01F1A:  MOVLW  53
01F1C:  MOVWF  x20
01F1E:  MOVLW  57
01F20:  MOVWF  x21
01F22:  MOVLW  43
01F24:  MOVWF  x22
01F26:  MOVLW  53
01F28:  MOVWF  x23
01F2A:  MOVLW  52
01F2C:  MOVWF  x24
01F2E:  CLRF   x25
01F30:  MOVLW  05
01F32:  MOVWF  x1C
01F34:  MOVLW  1D
01F36:  MOVWF  x1B
.................... 	char *nofifySlaveStatus = "$MQSWSTATUSSN"; 
01F38:  MOVLW  24
01F3A:  MOVWF  x28
01F3C:  MOVLW  4D
01F3E:  MOVWF  x29
01F40:  MOVLW  51
01F42:  MOVWF  x2A
01F44:  MOVLW  53
01F46:  MOVWF  x2B
01F48:  MOVLW  57
01F4A:  MOVWF  x2C
01F4C:  MOVLW  53
01F4E:  MOVWF  x2D
01F50:  MOVLW  54
01F52:  MOVWF  x2E
01F54:  MOVLW  41
01F56:  MOVWF  x2F
01F58:  MOVLW  54
01F5A:  MOVWF  x30
01F5C:  MOVLW  55
01F5E:  MOVWF  x31
01F60:  MOVLW  53
01F62:  MOVWF  x32
01F64:  MOVWF  x33
01F66:  MOVLW  4E
01F68:  MOVWF  x34
01F6A:  CLRF   x35
01F6C:  MOVLW  05
01F6E:  MOVWF  x27
01F70:  MOVLW  28
01F72:  MOVWF  x26
.................... 	char *slaveCheckLink = "$SCHECKLINK"; 
01F74:  MOVLW  24
01F76:  MOVWF  x38
01F78:  MOVLW  53
01F7A:  MOVWF  x39
01F7C:  MOVLW  43
01F7E:  MOVWF  x3A
01F80:  MOVLW  48
01F82:  MOVWF  x3B
01F84:  MOVLW  45
01F86:  MOVWF  x3C
01F88:  MOVLW  43
01F8A:  MOVWF  x3D
01F8C:  MOVLW  4B
01F8E:  MOVWF  x3E
01F90:  MOVLW  4C
01F92:  MOVWF  x3F
01F94:  MOVLW  49
01F96:  MOVWF  x40
01F98:  MOVLW  4E
01F9A:  MOVWF  x41
01F9C:  MOVLW  4B
01F9E:  MOVWF  x42
01FA0:  CLRF   x43
01FA2:  MOVLW  05
01FA4:  MOVWF  x37
01FA6:  MOVLW  38
01FA8:  MOVWF  x36
....................  
.................... 	char switchType; 
.................... 	int switchStatus; 
....................  
.................... 	int success; 
....................  
.................... 	correct_data = 0; 
01FAA:  MOVLB  3
01FAC:  CLRF   x19
.................... 	datastart = 0; 
01FAE:  CLRF   x1A
....................  
....................  
.................... 	//fprintf(ESP8266,"WIFI CMD: %s*\n", wifiPtr); 
....................  
....................  
.................... 	strcpy(tempCommand, wifiPtr);               // copy the string to temp string 
01FB0:  MOVLW  03
01FB2:  MOVWF  FEA
01FB4:  MOVLW  1B
01FB6:  MOVWF  FE9
01FB8:  MOVFF  25F,FE2
01FBC:  MOVFF  25E,FE1
01FC0:  MOVF   FE7,F
01FC2:  MOVFF  FE6,FEE
01FC6:  BNZ   1FC0
....................    	strcpy(delimeter,";");  
01FC8:  MOVLW  05
01FCA:  MOVWF  FEA
01FCC:  MOVLW  0F
01FCE:  MOVWF  FE9
01FD0:  MOVLW  00
01FD2:  MOVLB  0
01FD4:  CALL   04D2
01FD8:  TBLRD*-
01FDA:  TBLRD*+
01FDC:  MOVF   FF5,W
01FDE:  MOVWF  FEE
01FE0:  IORLW  00
01FE2:  BNZ   1FDA
....................  
.................... 	 
....................  
.................... 	//remove * 
.................... 	searchResultPtr = strchr(tempCommand, '*'); 
01FE4:  MOVLW  03
01FE6:  MOVLB  6
01FE8:  MOVWF  x48
01FEA:  MOVLW  1B
01FEC:  MOVWF  x47
01FEE:  MOVLW  2A
01FF0:  MOVWF  x49
01FF2:  MOVLB  0
01FF4:  RCALL  1A3A
01FF6:  MOVFF  02,518
01FFA:  MOVFF  01,517
.................... 	if(searchResultPtr != NULL){ 
01FFE:  MOVLB  5
02000:  MOVF   x17,F
02002:  BNZ   2008
02004:  MOVF   x18,F
02006:  BZ    2012
.................... 		searchResultPtr[0]=0; 
02008:  MOVFF  517,FE9
0200C:  MOVFF  518,FEA
02010:  CLRF   FEF
.................... 	} 
....................  
.................... 	command = strtok(tempCommand,delimeter); 
02012:  MOVLW  03
02014:  MOVLB  6
02016:  MOVWF  x47
02018:  MOVLW  1B
0201A:  MOVWF  x46
0201C:  MOVLW  05
0201E:  MOVWF  x49
02020:  MOVLW  0F
02022:  MOVWF  x48
02024:  MOVLB  0
02026:  RCALL  1BC4
02028:  MOVFF  02,512
0202C:  MOVFF  01,511
.................... 	if(command != 0){ 
02030:  MOVLB  5
02032:  MOVF   x11,F
02034:  BNZ   203C
02036:  MOVF   x12,F
02038:  BTFSC  FD8.2
0203A:  BRA    24D4
....................  
.................... 		if(strcmp(command, slaveCheckLink) == 0){ 
0203C:  MOVFF  512,647
02040:  MOVFF  511,646
02044:  MOVFF  537,649
02048:  MOVFF  536,648
0204C:  MOVLB  0
0204E:  RCALL  1C7C
02050:  MOVF   01,F
02052:  BNZ   20B2
.................... 			switchNumber = atoi(strtok(0,delimeter)); 
02054:  MOVLB  6
02056:  CLRF   x47
02058:  CLRF   x46
0205A:  MOVLW  05
0205C:  MOVWF  x49
0205E:  MOVLW  0F
02060:  MOVWF  x48
02062:  MOVLB  0
02064:  RCALL  1BC4
02066:  MOVFF  02,548
0206A:  MOVFF  01,547
0206E:  MOVFF  02,649
02072:  MOVFF  01,648
02076:  RCALL  1D44
02078:  MOVFF  01,513
.................... 			fprintf(WIFI,"%sS;OK*",command); 
0207C:  MOVFF  512,FEA
02080:  MOVFF  511,FE9
02084:  RCALL  1ED6
02086:  MOVLW  0A
02088:  MOVWF  FF6
0208A:  MOVLW  0B
0208C:  MOVWF  FF7
0208E:  CLRF   19
02090:  BTFSC  FF2.7
02092:  BSF    19.7
02094:  BCF    FF2.7
02096:  MOVLW  05
02098:  MOVLB  6
0209A:  MOVWF  x6C
0209C:  MOVLB  0
0209E:  CALL   050C
020A2:  BTFSC  19.7
020A4:  BSF    FF2.7
....................  
.................... 			//debug 
.................... 			//fprintf(ESP8266,"%sS;OK*",command); 
.................... 	 
.................... 			ptr = NULL; 
020A6:  MOVLB  5
020A8:  CLRF   x16
020AA:  CLRF   x15
.................... 			Clear_Receive(); 
020AC:  MOVLB  0
020AE:  RCALL  1EFC
.................... 			return; 
020B0:  BRA    24D8
.................... 		} 
....................  
.................... 		////$MQSWCSR;switchNumber;switchControlMode;success;uuid 
.................... 		if(strcmp(command, responseCommandSwitch) == 0){ 
020B2:  MOVFF  512,647
020B6:  MOVFF  511,646
020BA:  MOVFF  51C,649
020BE:  MOVFF  51B,648
020C2:  RCALL  1C7C
020C4:  MOVF   01,F
020C6:  BTFSS  FD8.2
020C8:  BRA    22D8
....................  
.................... 			switchNumber = atoi(strtok(0,delimeter)); 
020CA:  MOVLB  6
020CC:  CLRF   x47
020CE:  CLRF   x46
020D0:  MOVLW  05
020D2:  MOVWF  x49
020D4:  MOVLW  0F
020D6:  MOVWF  x48
020D8:  MOVLB  0
020DA:  RCALL  1BC4
020DC:  MOVFF  02,548
020E0:  MOVFF  01,547
020E4:  MOVFF  02,649
020E8:  MOVFF  01,648
020EC:  RCALL  1D44
020EE:  MOVFF  01,513
.................... 			waitingSlaveCounter[switchNumber-1] = 0; 
020F2:  MOVLW  01
020F4:  MOVLB  5
020F6:  SUBWF  x13,W
020F8:  CLRF   03
020FA:  ADDLW  8B
020FC:  MOVWF  FE9
020FE:  MOVLW  00
02100:  ADDWFC 03,W
02102:  MOVWF  FEA
02104:  CLRF   FEF
.................... 	 
.................... 			ptr = strtok(0,delimeter); 
02106:  MOVLB  6
02108:  CLRF   x47
0210A:  CLRF   x46
0210C:  MOVLW  05
0210E:  MOVWF  x49
02110:  MOVLW  0F
02112:  MOVWF  x48
02114:  MOVLB  0
02116:  RCALL  1BC4
02118:  MOVFF  02,516
0211C:  MOVFF  01,515
.................... 			switchControlMode = ptr[0]; 
02120:  MOVLB  5
02122:  MOVFF  515,FE9
02126:  MOVFF  516,FEA
0212A:  MOVFF  FEF,514
.................... 			success = atoi(strtok(0,delimeter)); 
0212E:  MOVLB  6
02130:  CLRF   x47
02132:  CLRF   x46
02134:  MOVLW  05
02136:  MOVWF  x49
02138:  MOVLW  0F
0213A:  MOVWF  x48
0213C:  MOVLB  0
0213E:  RCALL  1BC4
02140:  MOVFF  02,548
02144:  MOVFF  01,547
02148:  MOVFF  02,649
0214C:  MOVFF  01,648
02150:  RCALL  1D44
02152:  MOVFF  01,546
.................... 			uuid = strtok(0,delimeter); 
02156:  MOVLB  6
02158:  CLRF   x47
0215A:  CLRF   x46
0215C:  MOVLW  05
0215E:  MOVWF  x49
02160:  MOVLW  0F
02162:  MOVWF  x48
02164:  MOVLB  0
02166:  RCALL  1BC4
02168:  MOVFF  02,51A
0216C:  MOVFF  01,519
.................... 			 
.................... 			//fprintf(WIFI,"Switch: %u Response: %u\n",switchNumber, success); 
....................  
.................... 			if(success == 1){ 
02170:  MOVLB  5
02172:  DECFSZ x46,W
02174:  BRA    21C4
.................... 				if(switchControlMode == SWITCH_ON){ 
02176:  MOVF   x14,W
02178:  SUBLW  4E
0217A:  BNZ   2192
.................... 					wirelessSwitchStatus[switchNumber-1] = 1; 
0217C:  MOVLW  01
0217E:  SUBWF  x13,W
02180:  CLRF   03
02182:  ADDLW  31
02184:  MOVWF  FE9
02186:  MOVLW  00
02188:  ADDWFC 03,W
0218A:  MOVWF  FEA
0218C:  MOVLW  01
0218E:  MOVWF  FEF
.................... 				}else if(switchControlMode == SWITCH_OFF){ 
02190:  BRA    21C4
02192:  MOVF   x14,W
02194:  SUBLW  46
02196:  BNZ   21AC
.................... 					wirelessSwitchStatus[switchNumber-1] = 0; 
02198:  MOVLW  01
0219A:  SUBWF  x13,W
0219C:  CLRF   03
0219E:  ADDLW  31
021A0:  MOVWF  FE9
021A2:  MOVLW  00
021A4:  ADDWFC 03,W
021A6:  MOVWF  FEA
021A8:  CLRF   FEF
.................... 				}else if(switchControlMode == SWITCH_TOGGLE){ 
021AA:  BRA    21C4
021AC:  MOVF   x14,W
021AE:  SUBLW  54
021B0:  BNZ   21C4
.................... 					wirelessSwitchStatus[switchNumber-1] = 0; 
021B2:  MOVLW  01
021B4:  SUBWF  x13,W
021B6:  CLRF   03
021B8:  ADDLW  31
021BA:  MOVWF  FE9
021BC:  MOVLW  00
021BE:  ADDWFC 03,W
021C0:  MOVWF  FEA
021C2:  CLRF   FEF
.................... 				} 
.................... 			} 
.................... 			//$MQSWCR;switchNumber;switchControlMode;success;uuid 
.................... 			fprintf(ESP8266,"$MQSWCR;%u;W;%c;%u;%s*", switchNumber, switchControlMode, success, uuid); 
021C4:  MOVLW  10
021C6:  MOVWF  FF6
021C8:  MOVLW  0B
021CA:  MOVWF  FF7
021CC:  CLRF   19
021CE:  BTFSC  FF2.7
021D0:  BSF    19.7
021D2:  BCF    FF2.7
021D4:  MOVLW  08
021D6:  MOVLB  6
021D8:  MOVWF  x70
021DA:  MOVLB  0
021DC:  CALL   0E06
021E0:  BTFSC  19.7
021E2:  BSF    FF2.7
021E4:  CLRF   19
021E6:  BTFSC  FF2.7
021E8:  BSF    19.7
021EA:  BCF    FF2.7
021EC:  MOVFF  513,670
021F0:  MOVLW  1B
021F2:  MOVLB  6
021F4:  MOVWF  x71
021F6:  MOVLB  0
021F8:  CALL   0E30
021FC:  BTFSC  19.7
021FE:  BSF    FF2.7
02200:  MOVLW  1A
02202:  MOVWF  FF6
02204:  MOVLW  0B
02206:  MOVWF  FF7
02208:  CLRF   19
0220A:  BTFSC  FF2.7
0220C:  BSF    19.7
0220E:  BCF    FF2.7
02210:  MOVLW  03
02212:  MOVLB  6
02214:  MOVWF  x70
02216:  MOVLB  0
02218:  CALL   0E06
0221C:  BTFSC  19.7
0221E:  BSF    FF2.7
02220:  MOVLB  5
02222:  MOVF   x14,W
02224:  BTFSS  FA4.4
02226:  BRA    2224
02228:  MOVWF  F73
0222A:  MOVLW  3B
0222C:  BTFSS  FA4.4
0222E:  BRA    222C
02230:  MOVWF  F73
02232:  CLRF   19
02234:  BTFSC  FF2.7
02236:  BSF    19.7
02238:  BCF    FF2.7
0223A:  MOVFF  546,670
0223E:  MOVLW  1B
02240:  MOVLB  6
02242:  MOVWF  x71
02244:  MOVLB  0
02246:  CALL   0E30
0224A:  BTFSC  19.7
0224C:  BSF    FF2.7
0224E:  MOVLW  3B
02250:  BTFSS  FA4.4
02252:  BRA    2250
02254:  MOVWF  F73
02256:  MOVFF  51A,FEA
0225A:  MOVFF  519,FE9
0225E:  CLRF   19
02260:  BTFSC  FF2.7
02262:  BSF    19.7
02264:  BCF    FF2.7
02266:  CALL   0EAE
0226A:  BTFSC  19.7
0226C:  BSF    FF2.7
0226E:  MOVLW  2A
02270:  BTFSS  FA4.4
02272:  BRA    2270
02274:  MOVWF  F73
.................... 			write_eeprom(saveWirelessSwitchStatusAddress[switchnumber-1],wirelessSwitchStatus[switchnumber-1]); 
02276:  MOVLW  01
02278:  MOVLB  5
0227A:  SUBWF  x13,W
0227C:  CLRF   03
0227E:  ADDLW  4F
02280:  MOVWF  FE9
02282:  MOVLW  00
02284:  ADDWFC 03,W
02286:  MOVWF  FEA
02288:  MOVFF  FEF,547
0228C:  MOVLW  01
0228E:  SUBWF  x13,W
02290:  CLRF   03
02292:  ADDLW  31
02294:  MOVWF  FE9
02296:  MOVLW  00
02298:  ADDWFC 03,W
0229A:  MOVWF  FEA
0229C:  MOVFF  FEF,548
022A0:  MOVF   FF2,W
022A2:  MOVWF  00
022A4:  BCF    FF2.7
022A6:  CLRF   FAA
022A8:  MOVFF  547,FA9
022AC:  MOVFF  548,FA8
022B0:  BCF    FA6.6
022B2:  BCF    FA6.7
022B4:  BSF    FA6.2
022B6:  MOVLB  F
022B8:  MOVLW  55
022BA:  MOVWF  FA7
022BC:  MOVLW  AA
022BE:  MOVWF  FA7
022C0:  BSF    FA6.1
022C2:  BTFSC  FA6.1
022C4:  BRA    22C2
022C6:  BCF    FA6.2
022C8:  MOVF   00,W
022CA:  IORWF  FF2,F
.................... 		 
.................... 	 
.................... 			ptr = NULL; 
022CC:  MOVLB  5
022CE:  CLRF   x16
022D0:  CLRF   x15
.................... 			Clear_Receive(); 
022D2:  MOVLB  0
022D4:  RCALL  1EFC
.................... 			return; 
022D6:  BRA    24D8
.................... 		} 
....................  
.................... 	////$MQSWSTATUSSN;switchType;switchNumber;status* 
.................... 		if(strcmp(command, nofifySlaveStatus) == 0){ 
022D8:  MOVFF  512,647
022DC:  MOVFF  511,646
022E0:  MOVFF  527,649
022E4:  MOVFF  526,648
022E8:  RCALL  1C7C
022EA:  MOVF   01,F
022EC:  BTFSS  FD8.2
022EE:  BRA    24D2
.................... 			ptr = strtok(0,delimeter); 
022F0:  MOVLB  6
022F2:  CLRF   x47
022F4:  CLRF   x46
022F6:  MOVLW  05
022F8:  MOVWF  x49
022FA:  MOVLW  0F
022FC:  MOVWF  x48
022FE:  MOVLB  0
02300:  RCALL  1BC4
02302:  MOVFF  02,516
02306:  MOVFF  01,515
.................... 			switchType = ptr[0]; 
0230A:  MOVLB  5
0230C:  MOVFF  515,FE9
02310:  MOVFF  516,FEA
02314:  MOVFF  FEF,544
.................... 			switchNumber = atoi(strtok(0,delimeter)); 
02318:  MOVLB  6
0231A:  CLRF   x47
0231C:  CLRF   x46
0231E:  MOVLW  05
02320:  MOVWF  x49
02322:  MOVLW  0F
02324:  MOVWF  x48
02326:  MOVLB  0
02328:  RCALL  1BC4
0232A:  MOVFF  02,548
0232E:  MOVFF  01,547
02332:  MOVFF  02,649
02336:  MOVFF  01,648
0233A:  RCALL  1D44
0233C:  MOVFF  01,513
.................... 			switchStatus = atoi(strtok(0,delimeter)); 
02340:  MOVLB  6
02342:  CLRF   x47
02344:  CLRF   x46
02346:  MOVLW  05
02348:  MOVWF  x49
0234A:  MOVLW  0F
0234C:  MOVWF  x48
0234E:  MOVLB  0
02350:  RCALL  1BC4
02352:  MOVFF  02,548
02356:  MOVFF  01,547
0235A:  MOVFF  02,649
0235E:  MOVFF  01,648
02362:  RCALL  1D44
02364:  MOVFF  01,545
....................  
.................... 			if(switchType == 'L'){ 
02368:  MOVLB  5
0236A:  MOVF   x44,W
0236C:  SUBLW  4C
0236E:  BNZ   23DC
.................... 				livoloSwitchStatus[switchNumber-1] = switchStatus; 
02370:  MOVLW  01
02372:  SUBWF  x13,W
02374:  CLRF   03
02376:  ADDLW  3B
02378:  MOVWF  FE9
0237A:  MOVLW  00
0237C:  ADDWFC 03,W
0237E:  MOVWF  FEA
02380:  MOVFF  545,FEF
.................... 				write_eeprom(saveLivoloSwitchStatusAddress[switchnumber-1],livoloSwitchStatus[switchnumber-1]); 
02384:  MOVLW  01
02386:  SUBWF  x13,W
02388:  CLRF   03
0238A:  ADDLW  59
0238C:  MOVWF  FE9
0238E:  MOVLW  00
02390:  ADDWFC 03,W
02392:  MOVWF  FEA
02394:  MOVFF  FEF,547
02398:  MOVLW  01
0239A:  SUBWF  x13,W
0239C:  CLRF   03
0239E:  ADDLW  3B
023A0:  MOVWF  FE9
023A2:  MOVLW  00
023A4:  ADDWFC 03,W
023A6:  MOVWF  FEA
023A8:  MOVFF  FEF,548
023AC:  MOVF   FF2,W
023AE:  MOVWF  00
023B0:  BCF    FF2.7
023B2:  CLRF   FAA
023B4:  MOVFF  547,FA9
023B8:  MOVFF  548,FA8
023BC:  BCF    FA6.6
023BE:  BCF    FA6.7
023C0:  BSF    FA6.2
023C2:  MOVLB  F
023C4:  MOVLW  55
023C6:  MOVWF  FA7
023C8:  MOVLW  AA
023CA:  MOVWF  FA7
023CC:  BSF    FA6.1
023CE:  BTFSC  FA6.1
023D0:  BRA    23CE
023D2:  BCF    FA6.2
023D4:  MOVF   00,W
023D6:  IORWF  FF2,F
.................... 			}else if(switchType == 'W'){ 
023D8:  BRA    244A
023DA:  MOVLB  5
023DC:  MOVF   x44,W
023DE:  SUBLW  57
023E0:  BNZ   244C
.................... 				wirelessSwitchStatus[switchNumber-1] = switchStatus; 
023E2:  MOVLW  01
023E4:  SUBWF  x13,W
023E6:  CLRF   03
023E8:  ADDLW  31
023EA:  MOVWF  FE9
023EC:  MOVLW  00
023EE:  ADDWFC 03,W
023F0:  MOVWF  FEA
023F2:  MOVFF  545,FEF
.................... 				write_eeprom(saveWirelessSwitchStatusAddress[switchnumber-1],wirelessSwitchStatus[switchnumber-1]); 
023F6:  MOVLW  01
023F8:  SUBWF  x13,W
023FA:  CLRF   03
023FC:  ADDLW  4F
023FE:  MOVWF  FE9
02400:  MOVLW  00
02402:  ADDWFC 03,W
02404:  MOVWF  FEA
02406:  MOVFF  FEF,547
0240A:  MOVLW  01
0240C:  SUBWF  x13,W
0240E:  CLRF   03
02410:  ADDLW  31
02412:  MOVWF  FE9
02414:  MOVLW  00
02416:  ADDWFC 03,W
02418:  MOVWF  FEA
0241A:  MOVFF  FEF,548
0241E:  MOVF   FF2,W
02420:  MOVWF  00
02422:  BCF    FF2.7
02424:  CLRF   FAA
02426:  MOVFF  547,FA9
0242A:  MOVFF  548,FA8
0242E:  BCF    FA6.6
02430:  BCF    FA6.7
02432:  BSF    FA6.2
02434:  MOVLB  F
02436:  MOVLW  55
02438:  MOVWF  FA7
0243A:  MOVLW  AA
0243C:  MOVWF  FA7
0243E:  BSF    FA6.1
02440:  BTFSC  FA6.1
02442:  BRA    2440
02444:  BCF    FA6.2
02446:  MOVF   00,W
02448:  IORWF  FF2,F
0244A:  MOVLB  5
.................... 			} 
.................... 	 
.................... 			//fprintf(WIFI,"Switch Notify: %u Status: %u\n",switchNumber, switchStatus[switchNumber-1]); 
.................... 			//$MQSWCR;switchNumber;switchControlMode;success;uuid 
.................... 			fprintf(ESP8266,"$MQSWSTATUSN;%c;%u;%u*", switchType, switchNumber, switchStatus); 
0244C:  MOVLW  28
0244E:  MOVWF  FF6
02450:  MOVLW  0B
02452:  MOVWF  FF7
02454:  CLRF   19
02456:  BTFSC  FF2.7
02458:  BSF    19.7
0245A:  BCF    FF2.7
0245C:  MOVLW  0D
0245E:  MOVLB  6
02460:  MOVWF  x70
02462:  MOVLB  0
02464:  CALL   0E06
02468:  BTFSC  19.7
0246A:  BSF    FF2.7
0246C:  MOVLB  5
0246E:  MOVF   x44,W
02470:  BTFSS  FA4.4
02472:  BRA    2470
02474:  MOVWF  F73
02476:  MOVLW  3B
02478:  BTFSS  FA4.4
0247A:  BRA    2478
0247C:  MOVWF  F73
0247E:  CLRF   19
02480:  BTFSC  FF2.7
02482:  BSF    19.7
02484:  BCF    FF2.7
02486:  MOVFF  513,670
0248A:  MOVLW  1B
0248C:  MOVLB  6
0248E:  MOVWF  x71
02490:  MOVLB  0
02492:  CALL   0E30
02496:  BTFSC  19.7
02498:  BSF    FF2.7
0249A:  MOVLW  3B
0249C:  BTFSS  FA4.4
0249E:  BRA    249C
024A0:  MOVWF  F73
024A2:  CLRF   19
024A4:  BTFSC  FF2.7
024A6:  BSF    19.7
024A8:  BCF    FF2.7
024AA:  MOVFF  545,670
024AE:  MOVLW  1B
024B0:  MOVLB  6
024B2:  MOVWF  x71
024B4:  MOVLB  0
024B6:  CALL   0E30
024BA:  BTFSC  19.7
024BC:  BSF    FF2.7
024BE:  MOVLW  2A
024C0:  BTFSS  FA4.4
024C2:  BRA    24C0
024C4:  MOVWF  F73
.................... 			 
.................... 	 
.................... 			ptr = NULL; 
024C6:  MOVLB  5
024C8:  CLRF   x16
024CA:  CLRF   x15
.................... 			Clear_Receive(); 
024CC:  MOVLB  0
024CE:  RCALL  1EFC
.................... 			return; 
024D0:  BRA    24D8
024D2:  MOVLB  5
.................... 		} 
....................  
....................   
....................  
.................... 	} 
....................  
.................... 	Clear_Receive(); 
024D4:  MOVLB  0
024D6:  RCALL  1EFC
024D8:  GOTO   531E (RETURN)
....................  
.................... } 
.................... //======================================================================================================== 
....................  
.................... #include "MQTT_linker.c"						//นำเข้า ไลบารี่ MQTT Linker 
.................... int1 MQTTDataReadyFlag = false; 
....................  
....................  
....................  
....................  
....................  
....................  
.................... int timerEnable[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... int timerSwitchNumber[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... char timerDeviceType[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... char timerControlMode[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //int timerSecondDuration[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //int timerMonth[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //int timerDate[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... int timerHour[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... int timerMinute[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... int timerSecond[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //0-255 bit 7 is recurrent flag 
.................... int timerRecurrent[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //replace above 
.................... char *esp8266Ptr; 
.................... char *esp8266Index; 
.................... int1 esp8266Reading = false; 
.................... //====================================================================================================== 
.................... // 
.................... #INT_RDA2 
.................... void SerialInt2() 
*
00B58:  BRA    0B40
00B5A:  MOVFF  01,66C
.................... {    
.................... 	//get character from ESP8266 Module 
.................... 	char esp8266Char = getchar(ESP8266); 
....................  
.................... 	//if get $ then start read command for processing 
.................... 	if(esp8266Char == '$'){ 
00B5E:  MOVLB  6
00B60:  MOVF   x6C,W
00B62:  SUBLW  24
00B64:  BNZ   0B88
.................... 		//pointer need to be reset before start storing 
.................... 		esp8266Index = esp8266Ptr; 
00B66:  MOVFF  30E,310
00B6A:  MOVFF  30D,30F
.................... 		*esp8266Index = esp8266Char; 
00B6E:  MOVLB  3
00B70:  MOVFF  30F,FE9
00B74:  MOVFF  310,FEA
00B78:  MOVFF  66C,FEF
.................... 		esp8266Index++; 
00B7C:  INCF   x0F,F
00B7E:  BTFSC  FD8.2
00B80:  INCF   x10,F
.................... 		esp8266Reading = true; 
00B82:  MOVLB  2
00B84:  BSF    x62.2
.................... 	}else if(esp8266Reading == true){ 
00B86:  BRA    0BBC
00B88:  MOVLB  2
00B8A:  BTFSS  x62.2
00B8C:  BRA    0BBC
.................... 		*esp8266Index = esp8266Char; 
00B8E:  MOVLB  3
00B90:  MOVFF  30F,FE9
00B94:  MOVFF  310,FEA
00B98:  MOVFF  66C,FEF
.................... 		esp8266Index++; 
00B9C:  INCF   x0F,F
00B9E:  BTFSC  FD8.2
00BA0:  INCF   x10,F
.................... 		if(esp8266Char == '*'){ 
00BA2:  MOVLB  6
00BA4:  MOVF   x6C,W
00BA6:  SUBLW  2A
00BA8:  BNZ   0BBE
.................... 			*esp8266Index = 0; 
00BAA:  MOVLB  3
00BAC:  MOVFF  30F,FE9
00BB0:  MOVFF  310,FEA
00BB4:  CLRF   FEF
.................... 			esp8266Reading = false; 
00BB6:  MOVLB  2
00BB8:  BCF    x62.2
.................... 			MQTTDataReadyFlag = true; 
00BBA:  BSF    x62.1
00BBC:  MOVLB  6
.................... 		} 
.................... 	} 
00BBE:  BCF    FA4.5
00BC0:  MOVLB  0
00BC2:  GOTO   0484
.................... }  
....................  
.................... //======================================================================================================== 
.................... //  
.................... void ClearESP8266_Receive() 
.................... { 
.................... 	esp8266Index = esp8266Ptr; 
*
024DC:  MOVFF  30E,310
024E0:  MOVFF  30D,30F
.................... 	MQTTDataReadyFlag = false; 
024E4:  MOVLB  2
024E6:  BCF    x62.1
024E8:  MOVLB  0
024EA:  RETURN 0
.................... } 
....................  
.................... //======================================================================================================== 
.................... void ProcessMQTTData() 
.................... { 
.................... 	fprintf(WIFI,"CMD: %s\n", esp8266Ptr); 
*
02C6A:  MOVLW  C6
02C6C:  MOVWF  FF6
02C6E:  MOVLW  0B
02C70:  MOVWF  FF7
02C72:  CLRF   19
02C74:  BTFSC  FF2.7
02C76:  BSF    19.7
02C78:  BCF    FF2.7
02C7A:  MOVLW  05
02C7C:  MOVLB  6
02C7E:  MOVWF  x6C
02C80:  MOVLB  0
02C82:  CALL   050C
02C86:  BTFSC  19.7
02C88:  BSF    FF2.7
02C8A:  MOVFF  30E,FEA
02C8E:  MOVFF  30D,FE9
02C92:  CALL   1ED6
02C96:  MOVLW  0A
02C98:  BTFSS  F9E.4
02C9A:  BRA    2C98
02C9C:  MOVWF  FAD
....................  
.................... 	char *WIFIStatus = "$ESP8266WIFISTATUS"; 
02C9E:  MOVLW  24
02CA0:  MOVLB  3
02CA2:  MOVWF  x1B
02CA4:  MOVLW  45
02CA6:  MOVWF  x1C
02CA8:  MOVLW  53
02CAA:  MOVWF  x1D
02CAC:  MOVLW  50
02CAE:  MOVWF  x1E
02CB0:  MOVLW  38
02CB2:  MOVWF  x1F
02CB4:  MOVLW  32
02CB6:  MOVWF  x20
02CB8:  MOVLW  36
02CBA:  MOVWF  x21
02CBC:  MOVWF  x22
02CBE:  MOVLW  57
02CC0:  MOVWF  x23
02CC2:  MOVLW  49
02CC4:  MOVWF  x24
02CC6:  MOVLW  46
02CC8:  MOVWF  x25
02CCA:  MOVLW  49
02CCC:  MOVWF  x26
02CCE:  MOVLW  53
02CD0:  MOVWF  x27
02CD2:  MOVLW  54
02CD4:  MOVWF  x28
02CD6:  MOVLW  41
02CD8:  MOVWF  x29
02CDA:  MOVLW  54
02CDC:  MOVWF  x2A
02CDE:  MOVLW  55
02CE0:  MOVWF  x2B
02CE2:  MOVLW  53
02CE4:  MOVWF  x2C
02CE6:  CLRF   x2D
02CE8:  MOVLW  03
02CEA:  MOVWF  x1A
02CEC:  MOVLW  1B
02CEE:  MOVWF  x19
.................... 	char *MQStatus = "$ESP8266MQSTATUS"; 
02CF0:  MOVLW  24
02CF2:  MOVWF  x30
02CF4:  MOVLW  45
02CF6:  MOVWF  x31
02CF8:  MOVLW  53
02CFA:  MOVWF  x32
02CFC:  MOVLW  50
02CFE:  MOVWF  x33
02D00:  MOVLW  38
02D02:  MOVWF  x34
02D04:  MOVLW  32
02D06:  MOVWF  x35
02D08:  MOVLW  36
02D0A:  MOVWF  x36
02D0C:  MOVWF  x37
02D0E:  MOVLW  4D
02D10:  MOVWF  x38
02D12:  MOVLW  51
02D14:  MOVWF  x39
02D16:  MOVLW  53
02D18:  MOVWF  x3A
02D1A:  MOVLW  54
02D1C:  MOVWF  x3B
02D1E:  MOVLW  41
02D20:  MOVWF  x3C
02D22:  MOVLW  54
02D24:  MOVWF  x3D
02D26:  MOVLW  55
02D28:  MOVWF  x3E
02D2A:  MOVLW  53
02D2C:  MOVWF  x3F
02D2E:  CLRF   x40
02D30:  MOVLW  03
02D32:  MOVWF  x2F
02D34:  MOVLW  30
02D36:  MOVWF  x2E
.................... 	//$MQTT,IP192.168.1.201* 
....................  
.................... 	char *statusSuccess = "SUCCESS"; 
02D38:  MOVLW  53
02D3A:  MOVWF  x43
02D3C:  MOVLW  55
02D3E:  MOVWF  x44
02D40:  MOVLW  43
02D42:  MOVWF  x45
02D44:  MOVWF  x46
02D46:  MOVLW  45
02D48:  MOVWF  x47
02D4A:  MOVLW  53
02D4C:  MOVWF  x48
02D4E:  MOVWF  x49
02D50:  CLRF   x4A
02D52:  MOVLW  03
02D54:  MOVWF  x42
02D56:  MOVLW  43
02D58:  MOVWF  x41
.................... 	char *statusFailure = "FAILURE"; 
02D5A:  MOVLW  46
02D5C:  MOVWF  x4D
02D5E:  MOVLW  41
02D60:  MOVWF  x4E
02D62:  MOVLW  49
02D64:  MOVWF  x4F
02D66:  MOVLW  4C
02D68:  MOVWF  x50
02D6A:  MOVLW  55
02D6C:  MOVWF  x51
02D6E:  MOVLW  52
02D70:  MOVWF  x52
02D72:  MOVLW  45
02D74:  MOVWF  x53
02D76:  CLRF   x54
02D78:  MOVLW  03
02D7A:  MOVWF  x4C
02D7C:  MOVLW  4D
02D7E:  MOVWF  x4B
....................  
....................  
....................  
.................... 	char *accountInfo = "$ACRINFO"; 
02D80:  MOVLW  24
02D82:  MOVWF  x57
02D84:  MOVLW  41
02D86:  MOVWF  x58
02D88:  MOVLW  43
02D8A:  MOVWF  x59
02D8C:  MOVLW  52
02D8E:  MOVWF  x5A
02D90:  MOVLW  49
02D92:  MOVWF  x5B
02D94:  MOVLW  4E
02D96:  MOVWF  x5C
02D98:  MOVLW  46
02D9A:  MOVWF  x5D
02D9C:  MOVLW  4F
02D9E:  MOVWF  x5E
02DA0:  CLRF   x5F
02DA2:  MOVLW  03
02DA4:  MOVWF  x56
02DA6:  MOVLW  57
02DA8:  MOVWF  x55
....................  
....................  
.................... 	char *commandSwitch = "$MQSWC"; 
02DAA:  MOVLW  24
02DAC:  MOVWF  x62
02DAE:  MOVLW  4D
02DB0:  MOVWF  x63
02DB2:  MOVLW  51
02DB4:  MOVWF  x64
02DB6:  MOVLW  53
02DB8:  MOVWF  x65
02DBA:  MOVLW  57
02DBC:  MOVWF  x66
02DBE:  MOVLW  43
02DC0:  MOVWF  x67
02DC2:  CLRF   x68
02DC4:  MOVLW  03
02DC6:  MOVWF  x61
02DC8:  MOVLW  62
02DCA:  MOVWF  x60
.................... 	char *commandSetTimer = "$MQTMSET"; 
02DCC:  MOVLW  24
02DCE:  MOVWF  x6B
02DD0:  MOVLW  4D
02DD2:  MOVWF  x6C
02DD4:  MOVLW  51
02DD6:  MOVWF  x6D
02DD8:  MOVLW  54
02DDA:  MOVWF  x6E
02DDC:  MOVLW  4D
02DDE:  MOVWF  x6F
02DE0:  MOVLW  53
02DE2:  MOVWF  x70
02DE4:  MOVLW  45
02DE6:  MOVWF  x71
02DE8:  MOVLW  54
02DEA:  MOVWF  x72
02DEC:  CLRF   x73
02DEE:  MOVLW  03
02DF0:  MOVWF  x6A
02DF2:  MOVLW  6B
02DF4:  MOVWF  x69
.................... 	char *commandClearTimer = "$MQTMCLR"; 
02DF6:  MOVLW  24
02DF8:  MOVWF  x76
02DFA:  MOVLW  4D
02DFC:  MOVWF  x77
02DFE:  MOVLW  51
02E00:  MOVWF  x78
02E02:  MOVLW  54
02E04:  MOVWF  x79
02E06:  MOVLW  4D
02E08:  MOVWF  x7A
02E0A:  MOVLW  43
02E0C:  MOVWF  x7B
02E0E:  MOVLW  4C
02E10:  MOVWF  x7C
02E12:  MOVLW  52
02E14:  MOVWF  x7D
02E16:  CLRF   x7E
02E18:  MOVLW  03
02E1A:  MOVWF  x75
02E1C:  MOVLW  76
02E1E:  MOVWF  x74
.................... 	char *commandReadTimer = "$MQTMSTATUS"; 
02E20:  MOVLW  24
02E22:  MOVWF  x81
02E24:  MOVLW  4D
02E26:  MOVWF  x82
02E28:  MOVLW  51
02E2A:  MOVWF  x83
02E2C:  MOVLW  54
02E2E:  MOVWF  x84
02E30:  MOVLW  4D
02E32:  MOVWF  x85
02E34:  MOVLW  53
02E36:  MOVWF  x86
02E38:  MOVLW  54
02E3A:  MOVWF  x87
02E3C:  MOVLW  41
02E3E:  MOVWF  x88
02E40:  MOVLW  54
02E42:  MOVWF  x89
02E44:  MOVLW  55
02E46:  MOVWF  x8A
02E48:  MOVLW  53
02E4A:  MOVWF  x8B
02E4C:  CLRF   x8C
02E4E:  MOVLW  03
02E50:  MOVWF  x80
02E52:  MOVLW  81
02E54:  MOVWF  x7F
....................  
....................  
....................  
....................  
.................... 	char *commandStatus = "$MQSWSTATUS"; 
02E56:  MOVLW  24
02E58:  MOVWF  x8F
02E5A:  MOVLW  4D
02E5C:  MOVWF  x90
02E5E:  MOVLW  51
02E60:  MOVWF  x91
02E62:  MOVLW  53
02E64:  MOVWF  x92
02E66:  MOVLW  57
02E68:  MOVWF  x93
02E6A:  MOVLW  53
02E6C:  MOVWF  x94
02E6E:  MOVLW  54
02E70:  MOVWF  x95
02E72:  MOVLW  41
02E74:  MOVWF  x96
02E76:  MOVLW  54
02E78:  MOVWF  x97
02E7A:  MOVLW  55
02E7C:  MOVWF  x98
02E7E:  MOVLW  53
02E80:  MOVWF  x99
02E82:  CLRF   x9A
02E84:  MOVLW  03
02E86:  MOVWF  x8E
02E88:  MOVLW  8F
02E8A:  MOVWF  x8D
.................... 	char *commandUpdate = "$MQSYSUPFW"; 
02E8C:  MOVLW  24
02E8E:  MOVWF  x9D
02E90:  MOVLW  4D
02E92:  MOVWF  x9E
02E94:  MOVLW  51
02E96:  MOVWF  x9F
02E98:  MOVLW  53
02E9A:  MOVWF  xA0
02E9C:  MOVLW  59
02E9E:  MOVWF  xA1
02EA0:  MOVLW  53
02EA2:  MOVWF  xA2
02EA4:  MOVLW  55
02EA6:  MOVWF  xA3
02EA8:  MOVLW  50
02EAA:  MOVWF  xA4
02EAC:  MOVLW  46
02EAE:  MOVWF  xA5
02EB0:  MOVLW  57
02EB2:  MOVWF  xA6
02EB4:  CLRF   xA7
02EB6:  MOVLW  03
02EB8:  MOVWF  x9C
02EBA:  MOVLW  9D
02EBC:  MOVWF  x9B
.................... 	char *commandSyncTime = "$MQTTPSYNRTC"; 
02EBE:  MOVLW  24
02EC0:  MOVWF  xAA
02EC2:  MOVLW  4D
02EC4:  MOVWF  xAB
02EC6:  MOVLW  51
02EC8:  MOVWF  xAC
02ECA:  MOVLW  54
02ECC:  MOVWF  xAD
02ECE:  MOVWF  xAE
02ED0:  MOVLW  50
02ED2:  MOVWF  xAF
02ED4:  MOVLW  53
02ED6:  MOVWF  xB0
02ED8:  MOVLW  59
02EDA:  MOVWF  xB1
02EDC:  MOVLW  4E
02EDE:  MOVWF  xB2
02EE0:  MOVLW  52
02EE2:  MOVWF  xB3
02EE4:  MOVLW  54
02EE6:  MOVWF  xB4
02EE8:  MOVLW  43
02EEA:  MOVWF  xB5
02EEC:  CLRF   xB6
02EEE:  MOVLW  03
02EF0:  MOVWF  xA9
02EF2:  MOVLW  AA
02EF4:  MOVWF  xA8
....................  
....................  
.................... 	char *commandIRSwitch = "$XPORTIRSLWR"; 
02EF6:  MOVLW  24
02EF8:  MOVWF  xB9
02EFA:  MOVLW  58
02EFC:  MOVWF  xBA
02EFE:  MOVLW  50
02F00:  MOVWF  xBB
02F02:  MOVLW  4F
02F04:  MOVWF  xBC
02F06:  MOVLW  52
02F08:  MOVWF  xBD
02F0A:  MOVLW  54
02F0C:  MOVWF  xBE
02F0E:  MOVLW  49
02F10:  MOVWF  xBF
02F12:  MOVLW  52
02F14:  MOVWF  xC0
02F16:  MOVLW  53
02F18:  MOVWF  xC1
02F1A:  MOVLW  4C
02F1C:  MOVWF  xC2
02F1E:  MOVLW  57
02F20:  MOVWF  xC3
02F22:  MOVLW  52
02F24:  MOVWF  xC4
02F26:  CLRF   xC5
02F28:  MOVLW  03
02F2A:  MOVWF  xB8
02F2C:  MOVLW  B9
02F2E:  MOVWF  xB7
.................... 	char *commandIRSend = "$MQTTYIRSEND"; 
02F30:  MOVLW  24
02F32:  MOVWF  xC8
02F34:  MOVLW  4D
02F36:  MOVWF  xC9
02F38:  MOVLW  51
02F3A:  MOVWF  xCA
02F3C:  MOVLW  54
02F3E:  MOVWF  xCB
02F40:  MOVWF  xCC
02F42:  MOVLW  59
02F44:  MOVWF  xCD
02F46:  MOVLW  49
02F48:  MOVWF  xCE
02F4A:  MOVLW  52
02F4C:  MOVWF  xCF
02F4E:  MOVLW  53
02F50:  MOVWF  xD0
02F52:  MOVLW  45
02F54:  MOVWF  xD1
02F56:  MOVLW  4E
02F58:  MOVWF  xD2
02F5A:  MOVLW  44
02F5C:  MOVWF  xD3
02F5E:  CLRF   xD4
02F60:  MOVLW  03
02F62:  MOVWF  xC7
02F64:  MOVLW  C8
02F66:  MOVWF  xC6
.................... 	char *commandIRRead = "$XPORTIRREAD"; 
02F68:  MOVLW  24
02F6A:  MOVWF  xD7
02F6C:  MOVLW  58
02F6E:  MOVWF  xD8
02F70:  MOVLW  50
02F72:  MOVWF  xD9
02F74:  MOVLW  4F
02F76:  MOVWF  xDA
02F78:  MOVLW  52
02F7A:  MOVWF  xDB
02F7C:  MOVLW  54
02F7E:  MOVWF  xDC
02F80:  MOVLW  49
02F82:  MOVWF  xDD
02F84:  MOVLW  52
02F86:  MOVWF  xDE
02F88:  MOVWF  xDF
02F8A:  MOVLW  45
02F8C:  MOVWF  xE0
02F8E:  MOVLW  41
02F90:  MOVWF  xE1
02F92:  MOVLW  44
02F94:  MOVWF  xE2
02F96:  CLRF   xE3
02F98:  MOVLW  03
02F9A:  MOVWF  xD6
02F9C:  MOVLW  D7
02F9E:  MOVWF  xD5
.................... 	char *commandClearIR = "$XPORTIRSCLR"; 
02FA0:  MOVLW  24
02FA2:  MOVWF  xE6
02FA4:  MOVLW  58
02FA6:  MOVWF  xE7
02FA8:  MOVLW  50
02FAA:  MOVWF  xE8
02FAC:  MOVLW  4F
02FAE:  MOVWF  xE9
02FB0:  MOVLW  52
02FB2:  MOVWF  xEA
02FB4:  MOVLW  54
02FB6:  MOVWF  xEB
02FB8:  MOVLW  49
02FBA:  MOVWF  xEC
02FBC:  MOVLW  52
02FBE:  MOVWF  xED
02FC0:  MOVLW  53
02FC2:  MOVWF  xEE
02FC4:  MOVLW  43
02FC6:  MOVWF  xEF
02FC8:  MOVLW  4C
02FCA:  MOVWF  xF0
02FCC:  MOVLW  52
02FCE:  MOVWF  xF1
02FD0:  CLRF   xF2
02FD2:  MOVLW  03
02FD4:  MOVWF  xE5
02FD6:  MOVLW  E6
02FD8:  MOVWF  xE4
....................  
.................... 	char *commandSecurityLock = "$MQTTYSCLOCK"; 
02FDA:  MOVLW  24
02FDC:  MOVWF  xF5
02FDE:  MOVLW  4D
02FE0:  MOVWF  xF6
02FE2:  MOVLW  51
02FE4:  MOVWF  xF7
02FE6:  MOVLW  54
02FE8:  MOVWF  xF8
02FEA:  MOVWF  xF9
02FEC:  MOVLW  59
02FEE:  MOVWF  xFA
02FF0:  MOVLW  53
02FF2:  MOVWF  xFB
02FF4:  MOVLW  43
02FF6:  MOVWF  xFC
02FF8:  MOVLW  4C
02FFA:  MOVWF  xFD
02FFC:  MOVLW  4F
02FFE:  MOVWF  xFE
03000:  MOVLW  43
03002:  MOVWF  xFF
03004:  MOVLW  4B
03006:  MOVLB  4
03008:  MOVWF  x00
0300A:  CLRF   x01
0300C:  MOVLW  03
0300E:  MOVLB  3
03010:  MOVWF  xF4
03012:  MOVLW  F5
03014:  MOVWF  xF3
.................... 	char *commandSecurityUnlock = "$MQTTYUNLOCK"; 
03016:  MOVLW  24
03018:  MOVLB  4
0301A:  MOVWF  x04
0301C:  MOVLW  4D
0301E:  MOVWF  x05
03020:  MOVLW  51
03022:  MOVWF  x06
03024:  MOVLW  54
03026:  MOVWF  x07
03028:  MOVWF  x08
0302A:  MOVLW  59
0302C:  MOVWF  x09
0302E:  MOVLW  55
03030:  MOVWF  x0A
03032:  MOVLW  4E
03034:  MOVWF  x0B
03036:  MOVLW  4C
03038:  MOVWF  x0C
0303A:  MOVLW  4F
0303C:  MOVWF  x0D
0303E:  MOVLW  43
03040:  MOVWF  x0E
03042:  MOVLW  4B
03044:  MOVWF  x0F
03046:  CLRF   x10
03048:  MOVLW  04
0304A:  MOVWF  x03
0304C:  MOVWF  x02
.................... 	char *commandSecurityLoad = "$MQTTYSCLOAD"; 
0304E:  MOVLW  24
03050:  MOVWF  x13
03052:  MOVLW  4D
03054:  MOVWF  x14
03056:  MOVLW  51
03058:  MOVWF  x15
0305A:  MOVLW  54
0305C:  MOVWF  x16
0305E:  MOVWF  x17
03060:  MOVLW  59
03062:  MOVWF  x18
03064:  MOVLW  53
03066:  MOVWF  x19
03068:  MOVLW  43
0306A:  MOVWF  x1A
0306C:  MOVLW  4C
0306E:  MOVWF  x1B
03070:  MOVLW  4F
03072:  MOVWF  x1C
03074:  MOVLW  41
03076:  MOVWF  x1D
03078:  MOVLW  44
0307A:  MOVWF  x1E
0307C:  CLRF   x1F
0307E:  MOVLW  04
03080:  MOVWF  x12
03082:  MOVLW  13
03084:  MOVWF  x11
.................... 	char *commandSetSecurity = "$MQTTYSETSECURE"; 
03086:  MOVLW  24
03088:  MOVWF  x22
0308A:  MOVLW  4D
0308C:  MOVWF  x23
0308E:  MOVLW  51
03090:  MOVWF  x24
03092:  MOVLW  54
03094:  MOVWF  x25
03096:  MOVWF  x26
03098:  MOVLW  59
0309A:  MOVWF  x27
0309C:  MOVLW  53
0309E:  MOVWF  x28
030A0:  MOVLW  45
030A2:  MOVWF  x29
030A4:  MOVLW  54
030A6:  MOVWF  x2A
030A8:  MOVLW  53
030AA:  MOVWF  x2B
030AC:  MOVLW  45
030AE:  MOVWF  x2C
030B0:  MOVLW  43
030B2:  MOVWF  x2D
030B4:  MOVLW  55
030B6:  MOVWF  x2E
030B8:  MOVLW  52
030BA:  MOVWF  x2F
030BC:  MOVLW  45
030BE:  MOVWF  x30
030C0:  CLRF   x31
030C2:  MOVLW  04
030C4:  MOVWF  x21
030C6:  MOVLW  22
030C8:  MOVWF  x20
....................  
....................  
....................  
....................  
.................... 	char tempCommand[COMMAND_SIZE], delimeter[2]; 
.................... 	char *command; 
....................  
.................... //for general switch 
.................... 	int8 switchNumber; 
.................... 	int8 requestSwitchNumber; 
.................... 	char deviceType; 
.................... 	char switchControlMode; 
.................... //tmp sw status 
.................... 	char *allSwStatus = ""; 
030CA:  MOVLB  6
030CC:  CLRF   x30
030CE:  MOVLW  06
030D0:  MOVWF  x2F
030D2:  MOVLW  30
030D4:  MOVWF  x2E
....................  
.................... //for timer 
.................... 	//int secondDuration; 
.................... 	int monthSet; 
.................... 	int dateSet; 
.................... 	int hourSet; 
.................... 	int minuteSet; 
.................... 	int recurrent; 
.................... 	char recurrentStr[7]; 
.................... 	char* recurrentDay; 
.................... 	int setId; 
....................  
.................... 	char *ptr; 
.................... 	char *searchResultPtr; 
.................... 	char *uuid; 
.................... 	 
....................  
....................  
....................  
....................  
.................... 	//on boot 
.................... 	//$MQTTPSYNRTC:13:11:2016:1:12:56:38:* 
.................... 	 
.................... 	 
.................... 	strcpy(tempCommand, esp8266Ptr);               // copy the string to temp string 
030D6:  MOVLW  04
030D8:  MOVWF  FEA
030DA:  MOVLW  32
030DC:  MOVWF  FE9
030DE:  MOVFF  30E,FE2
030E2:  MOVFF  30D,FE1
030E6:  MOVF   FE7,F
030E8:  MOVFF  FE6,FEE
030EC:  BNZ   30E6
....................    	strcpy(delimeter,";");  
030EE:  MOVLW  06
030F0:  MOVWF  FEA
030F2:  MOVLW  26
030F4:  MOVWF  FE9
030F6:  MOVLW  00
030F8:  MOVLB  0
030FA:  CALL   04D2
030FE:  TBLRD*-
03100:  TBLRD*+
03102:  MOVF   FF5,W
03104:  MOVWF  FEE
03106:  IORLW  00
03108:  BNZ   3100
....................  
.................... 	//remove * 
.................... 	searchResultPtr = strchr(tempCommand, '*'); 
0310A:  MOVLW  04
0310C:  MOVLB  6
0310E:  MOVWF  x48
03110:  MOVLW  32
03112:  MOVWF  x47
03114:  MOVLW  2A
03116:  MOVWF  x49
03118:  MOVLB  0
0311A:  CALL   1A3A
0311E:  MOVFF  02,643
03122:  MOVFF  01,642
.................... 	if(searchResultPtr != NULL){ 
03126:  MOVLB  6
03128:  MOVF   x42,F
0312A:  BNZ   3130
0312C:  MOVF   x43,F
0312E:  BZ    313A
.................... 		searchResultPtr[0]=0; 
03130:  MOVFF  642,FE9
03134:  MOVFF  643,FEA
03138:  CLRF   FEF
.................... 	} 
....................  
....................  
.................... 	 
.................... 	command = strtok(tempCommand,delimeter); 
0313A:  MOVLW  04
0313C:  MOVWF  x47
0313E:  MOVLW  32
03140:  MOVWF  x46
03142:  MOVLW  06
03144:  MOVWF  x49
03146:  MOVLW  26
03148:  MOVWF  x48
0314A:  MOVLB  0
0314C:  CALL   1BC4
03150:  MOVFF  02,629
03154:  MOVFF  01,628
....................  
....................  
.................... 	if(command != 0){ 
03158:  MOVLB  6
0315A:  MOVF   x28,F
0315C:  BNZ   3166
0315E:  MOVF   x29,F
03160:  BTFSC  FD8.2
03162:  GOTO   4798
....................  
....................  
.................... 		if(strcmp(command, MQStatus) == 0){ 
03166:  MOVFF  629,647
0316A:  MOVFF  628,646
0316E:  MOVFF  32F,649
03172:  MOVFF  32E,648
03176:  MOVLB  0
03178:  CALL   1C7C
0317C:  MOVF   01,F
0317E:  BNZ   3232
.................... 			ptr = strtok(0,delimeter); 
03180:  MOVLB  6
03182:  CLRF   x47
03184:  CLRF   x46
03186:  MOVLW  06
03188:  MOVWF  x49
0318A:  MOVLW  26
0318C:  MOVWF  x48
0318E:  MOVLB  0
03190:  CALL   1BC4
03194:  MOVFF  02,641
03198:  MOVFF  01,640
.................... 			if(strcmp(ptr, statusSuccess) == 0){ 
0319C:  MOVFF  641,647
031A0:  MOVFF  640,646
031A4:  MOVFF  342,649
031A8:  MOVFF  341,648
031AC:  CALL   1C7C
031B0:  MOVF   01,F
031B2:  BNZ   31EE
.................... 				lcd_goto_xy(0,1); 
031B4:  MOVLB  6
031B6:  CLRF   x46
031B8:  MOVLW  01
031BA:  MOVWF  x47
031BC:  MOVLB  0
031BE:  CALL   1302
.................... 				display("MQTT    "); 
031C2:  MOVLW  D0
031C4:  MOVWF  FF6
031C6:  MOVLW  0B
031C8:  MOVWF  FF7
031CA:  CALL   1438
.................... 		 
.................... 			    lcd_goto_xy(0,2); 
031CE:  MOVLB  6
031D0:  CLRF   x46
031D2:  MOVLW  02
031D4:  MOVWF  x47
031D6:  MOVLB  0
031D8:  CALL   1302
.................... 		     	display("                "); 
031DC:  MOVLW  DA
031DE:  MOVWF  FF6
031E0:  MOVLW  0B
031E2:  MOVWF  FF7
031E4:  CALL   1438
.................... 		 
.................... 			 	Boot_Flag = true; 
031E8:  BSF    xC4.2
.................... 				MQTTConnect_Flag = false; 
031EA:  BCF    xC4.0
....................  
.................... 			}else{ 
031EC:  BRA    3222
.................... 				lcd_goto_xy(0,1); 
031EE:  MOVLB  6
031F0:  CLRF   x46
031F2:  MOVLW  01
031F4:  MOVWF  x47
031F6:  MOVLB  0
031F8:  CALL   1302
.................... 				display("FAIL    "); 
031FC:  MOVLW  EC
031FE:  MOVWF  FF6
03200:  MOVLW  0B
03202:  MOVWF  FF7
03204:  CALL   1438
.................... 		 
.................... 			    lcd_goto_xy(0,2); 
03208:  MOVLB  6
0320A:  CLRF   x46
0320C:  MOVLW  02
0320E:  MOVWF  x47
03210:  MOVLB  0
03212:  CALL   1302
.................... 		     	display("                "); 
03216:  MOVLW  F6
03218:  MOVWF  FF6
0321A:  MOVLW  0B
0321C:  MOVWF  FF7
0321E:  CALL   1438
.................... 			} 
....................  
.................... 			ptr = NULL; 
03222:  MOVLB  6
03224:  CLRF   x41
03226:  CLRF   x40
.................... 			ClearESP8266_Receive(); 
03228:  MOVLB  0
0322A:  CALL   24DC
.................... 			return; 
0322E:  GOTO   4A6E
.................... 		} 
....................  
.................... 		if(strcmp(command, WIFIStatus) == 0){ 
03232:  MOVFF  629,647
03236:  MOVFF  628,646
0323A:  MOVFF  31A,649
0323E:  MOVFF  319,648
03242:  CALL   1C7C
03246:  MOVF   01,F
03248:  BNZ   32E4
.................... 			ptr = strtok(0,delimeter); 
0324A:  MOVLB  6
0324C:  CLRF   x47
0324E:  CLRF   x46
03250:  MOVLW  06
03252:  MOVWF  x49
03254:  MOVLW  26
03256:  MOVWF  x48
03258:  MOVLB  0
0325A:  CALL   1BC4
0325E:  MOVFF  02,641
03262:  MOVFF  01,640
.................... 			if(strcmp(ptr, statusSuccess) == 0){ 
03266:  MOVFF  641,647
0326A:  MOVFF  640,646
0326E:  MOVFF  342,649
03272:  MOVFF  341,648
03276:  CALL   1C7C
0327A:  MOVF   01,F
0327C:  BNZ   329C
.................... 				lcd_goto_xy(0,2); 
0327E:  MOVLB  6
03280:  CLRF   x46
03282:  MOVLW  02
03284:  MOVWF  x47
03286:  MOVLB  0
03288:  CALL   1302
.................... 				display("                "); 
0328C:  MOVLW  08
0328E:  MOVWF  FF6
03290:  MOVLW  0C
03292:  MOVWF  FF7
03294:  CALL   1438
.................... 		 
.................... 			 	Boot_Flag = true; 
03298:  BSF    xC4.2
.................... 			}else{ 
0329A:  BRA    32D4
.................... 				lcd_goto_xy(5,1); 
0329C:  MOVLW  05
0329E:  MOVLB  6
032A0:  MOVWF  x46
032A2:  MOVLW  01
032A4:  MOVWF  x47
032A6:  MOVLB  0
032A8:  CALL   1302
.................... 				display("E2"); 
032AC:  MOVLW  1A
032AE:  MOVWF  FF6
032B0:  MOVLW  0C
032B2:  MOVWF  FF7
032B4:  CALL   1438
.................... 		 
.................... 				lcd_goto_xy(0,2); 
032B8:  MOVLB  6
032BA:  CLRF   x46
032BC:  MOVLW  02
032BE:  MOVWF  x47
032C0:  MOVLB  0
032C2:  CALL   1302
.................... 				display("WiFi Signal Loss"); 
032C6:  MOVLW  1E
032C8:  MOVWF  FF6
032CA:  MOVLW  0C
032CC:  MOVWF  FF7
032CE:  CALL   1438
.................... 		 
.................... 			 	Boot_Flag = false; 
032D2:  BCF    xC4.2
.................... 			} 
.................... 			ptr = NULL; 
032D4:  MOVLB  6
032D6:  CLRF   x41
032D8:  CLRF   x40
.................... 			ClearESP8266_Receive(); 
032DA:  MOVLB  0
032DC:  CALL   24DC
.................... 			return; 
032E0:  GOTO   4A6E
.................... 		} 
....................  
....................  
.................... 		//NEW $MQSWC;1;F;UUID;* 
.................... 		if(strcmp(command, commandSwitch) == 0){ 
032E4:  MOVFF  629,647
032E8:  MOVFF  628,646
032EC:  MOVFF  361,649
032F0:  MOVFF  360,648
032F4:  CALL   1C7C
032F8:  MOVF   01,F
032FA:  BTFSS  FD8.2
032FC:  BRA    37F4
.................... 			requestSwitchNumber = atoi(strtok(0,delimeter)); 
032FE:  MOVLB  6
03300:  CLRF   x47
03302:  CLRF   x46
03304:  MOVLW  06
03306:  MOVWF  x49
03308:  MOVLW  26
0330A:  MOVWF  x48
0330C:  MOVLB  0
0330E:  CALL   1BC4
03312:  MOVFF  02,647
03316:  MOVFF  01,646
0331A:  MOVFF  02,649
0331E:  MOVFF  01,648
03322:  CALL   1D44
03326:  MOVFF  01,62B
.................... 	 
.................... 			//ptr = strtok(0,delimeter); 
.................... 			//deviceType = ptr[0]; 
.................... 			ptr = strtok(0,delimeter); 
0332A:  MOVLB  6
0332C:  CLRF   x47
0332E:  CLRF   x46
03330:  MOVLW  06
03332:  MOVWF  x49
03334:  MOVLW  26
03336:  MOVWF  x48
03338:  MOVLB  0
0333A:  CALL   1BC4
0333E:  MOVFF  02,641
03342:  MOVFF  01,640
.................... 			switchControlMode = ptr[0]; 
03346:  MOVLB  6
03348:  MOVFF  640,FE9
0334C:  MOVFF  641,FEA
03350:  MOVFF  FEF,62D
.................... 		 
.................... 			uuid = strtok(0,delimeter); 
03354:  CLRF   x47
03356:  CLRF   x46
03358:  MOVLW  06
0335A:  MOVWF  x49
0335C:  MOVLW  26
0335E:  MOVWF  x48
03360:  MOVLB  0
03362:  CALL   1BC4
03366:  MOVFF  02,645
0336A:  MOVFF  01,644
....................  
.................... 			if(requestSwitchNumber <= sizeof(internalSwitchStatus)){ 
0336E:  MOVLB  6
03370:  MOVF   x2B,W
03372:  SUBLW  0A
03374:  BNC   3380
.................... 				switchNumber = requestSwitchNumber; 
03376:  MOVFF  62B,62A
.................... 				deviceType = INTERNAL; 
0337A:  MOVLW  49
0337C:  MOVWF  x2C
.................... 			}else if(requestSwitchNumber > sizeof(internalSwitchStatus) && requestSwitchNumber <= sizeof(internalSwitchStatus) + sizeof(wirelessSwitchStatus)){ 
0337E:  BRA    33A4
03380:  MOVF   x2B,W
03382:  SUBLW  0A
03384:  BC    3398
03386:  MOVF   x2B,W
03388:  SUBLW  14
0338A:  BNC   3398
.................... 				switchNumber = requestSwitchNumber - sizeof(internalSwitchStatus); 
0338C:  MOVLW  0A
0338E:  SUBWF  x2B,W
03390:  MOVWF  x2A
.................... 				deviceType = WIRELESS; 
03392:  MOVLW  57
03394:  MOVWF  x2C
.................... 			}else{ 
03396:  BRA    33A4
.................... 				switchNumber = requestSwitchNumber - sizeof(internalSwitchStatus) - sizeof(wirelessSwitchStatus); 
03398:  MOVLW  0A
0339A:  SUBWF  x2B,W
0339C:  ADDLW  F6
0339E:  MOVWF  x2A
.................... 				deviceType = LIVOLO; 
033A0:  MOVLW  4C
033A2:  MOVWF  x2C
.................... 			} 
.................... 			 
.................... 		 
.................... 		 
.................... 			//farward command to wifi and wait for response 
.................... 			if(deviceType == WIRELESS){ 
033A4:  MOVF   x2C,W
033A6:  SUBLW  57
033A8:  BNZ   344E
.................... 				fprintf(WIFI,"%sS;%u;%c;%s*", command, switchNumber, switchControlMode, uuid); 
033AA:  MOVFF  629,FEA
033AE:  MOVFF  628,FE9
033B2:  MOVLB  0
033B4:  CALL   1ED6
033B8:  MOVLW  53
033BA:  BTFSS  F9E.4
033BC:  BRA    33BA
033BE:  MOVWF  FAD
033C0:  MOVLW  3B
033C2:  BTFSS  F9E.4
033C4:  BRA    33C2
033C6:  MOVWF  FAD
033C8:  CLRF   19
033CA:  BTFSC  FF2.7
033CC:  BSF    19.7
033CE:  BCF    FF2.7
033D0:  MOVFF  62A,66C
033D4:  MOVLW  1B
033D6:  MOVLB  6
033D8:  MOVWF  x6D
033DA:  MOVLB  0
033DC:  CALL   0768
033E0:  BTFSC  19.7
033E2:  BSF    FF2.7
033E4:  MOVLW  3B
033E6:  BTFSS  F9E.4
033E8:  BRA    33E6
033EA:  MOVWF  FAD
033EC:  MOVLB  6
033EE:  MOVF   x2D,W
033F0:  BTFSS  F9E.4
033F2:  BRA    33F0
033F4:  MOVWF  FAD
033F6:  MOVLW  3B
033F8:  BTFSS  F9E.4
033FA:  BRA    33F8
033FC:  MOVWF  FAD
033FE:  MOVFF  645,FEA
03402:  MOVFF  644,FE9
03406:  MOVLB  0
03408:  CALL   1ED6
0340C:  MOVLW  2A
0340E:  BTFSS  F9E.4
03410:  BRA    340E
03412:  MOVWF  FAD
.................... 				waitingSlaveCounter[switchNumber-1] = 1; 
03414:  MOVLW  01
03416:  MOVLB  6
03418:  SUBWF  x2A,W
0341A:  CLRF   03
0341C:  ADDLW  8B
0341E:  MOVWF  FE9
03420:  MOVLW  00
03422:  ADDWFC 03,W
03424:  MOVWF  FEA
03426:  MOVLW  01
03428:  MOVWF  FEF
.................... 				uuids[switchNumber-1] = uuid; 
0342A:  SUBWF  x2A,W
0342C:  CLRF   03
0342E:  MOVWF  02
03430:  BCF    FD8.0
03432:  RLCF   02,F
03434:  RLCF   03,F
03436:  MOVF   02,W
03438:  ADDLW  95
0343A:  MOVWF  FE9
0343C:  MOVLW  00
0343E:  ADDWFC 03,W
03440:  MOVWF  FEA
03442:  MOVFF  645,FEC
03446:  MOVF   FED,F
03448:  MOVFF  644,FEF
.................... 			}else if(deviceType == LIVOLO){ 
0344C:  BRA    37E6
0344E:  MOVF   x2C,W
03450:  SUBLW  4C
03452:  BTFSS  FD8.2
03454:  BRA    356E
.................... 				fprintf(ESP8266,"%sL;%u;%c;%s*", command, switchNumber, switchControlMode, uuid); 
03456:  MOVFF  629,FEA
0345A:  MOVFF  628,FE9
0345E:  CLRF   19
03460:  BTFSC  FF2.7
03462:  BSF    19.7
03464:  BCF    FF2.7
03466:  MOVLB  0
03468:  CALL   0EAE
0346C:  BTFSC  19.7
0346E:  BSF    FF2.7
03470:  MOVLW  4C
03472:  BTFSS  FA4.4
03474:  BRA    3472
03476:  MOVWF  F73
03478:  MOVLW  3B
0347A:  BTFSS  FA4.4
0347C:  BRA    347A
0347E:  MOVWF  F73
03480:  CLRF   19
03482:  BTFSC  FF2.7
03484:  BSF    19.7
03486:  BCF    FF2.7
03488:  MOVFF  62A,670
0348C:  MOVLW  1B
0348E:  MOVLB  6
03490:  MOVWF  x71
03492:  MOVLB  0
03494:  CALL   0E30
03498:  BTFSC  19.7
0349A:  BSF    FF2.7
0349C:  MOVLW  3B
0349E:  BTFSS  FA4.4
034A0:  BRA    349E
034A2:  MOVWF  F73
034A4:  MOVLB  6
034A6:  MOVF   x2D,W
034A8:  BTFSS  FA4.4
034AA:  BRA    34A8
034AC:  MOVWF  F73
034AE:  MOVLW  3B
034B0:  BTFSS  FA4.4
034B2:  BRA    34B0
034B4:  MOVWF  F73
034B6:  MOVFF  645,FEA
034BA:  MOVFF  644,FE9
034BE:  CLRF   19
034C0:  BTFSC  FF2.7
034C2:  BSF    19.7
034C4:  BCF    FF2.7
034C6:  MOVLB  0
034C8:  CALL   0EAE
034CC:  BTFSC  19.7
034CE:  BSF    FF2.7
034D0:  MOVLW  2A
034D2:  BTFSS  FA4.4
034D4:  BRA    34D2
034D6:  MOVWF  F73
.................... 				if(livoloSwitchStatus[switchNumber-1] == 0){ 
034D8:  MOVLW  01
034DA:  MOVLB  6
034DC:  SUBWF  x2A,W
034DE:  CLRF   03
034E0:  ADDLW  3B
034E2:  MOVWF  FE9
034E4:  MOVLW  00
034E6:  ADDWFC 03,W
034E8:  MOVWF  FEA
034EA:  MOVF   FEF,F
034EC:  BNZ   3504
.................... 					livoloSwitchStatus[switchNumber-1] = 1; 
034EE:  MOVLW  01
034F0:  SUBWF  x2A,W
034F2:  CLRF   03
034F4:  ADDLW  3B
034F6:  MOVWF  FE9
034F8:  MOVLW  00
034FA:  ADDWFC 03,W
034FC:  MOVWF  FEA
034FE:  MOVLW  01
03500:  MOVWF  FEF
.................... 				}else{ 
03502:  BRA    3516
.................... 					livoloSwitchStatus[switchNumber-1] = 0; 
03504:  MOVLW  01
03506:  SUBWF  x2A,W
03508:  CLRF   03
0350A:  ADDLW  3B
0350C:  MOVWF  FE9
0350E:  MOVLW  00
03510:  ADDWFC 03,W
03512:  MOVWF  FEA
03514:  CLRF   FEF
.................... 				} 
.................... 				//fprintf(ESP8266,"%sR;%u;%c;%c;1;%s*", command, switchNumber, deviceType ,switchControlMode, uuid); 
.................... 				write_eeprom(saveLivoloSwitchStatusAddress[switchnumber-1],livoloSwitchStatus[switchnumber-1]); 
03516:  MOVLW  01
03518:  SUBWF  x2A,W
0351A:  CLRF   03
0351C:  ADDLW  59
0351E:  MOVWF  FE9
03520:  MOVLW  00
03522:  ADDWFC 03,W
03524:  MOVWF  FEA
03526:  MOVFF  FEF,646
0352A:  MOVLW  01
0352C:  SUBWF  x2A,W
0352E:  CLRF   03
03530:  ADDLW  3B
03532:  MOVWF  FE9
03534:  MOVLW  00
03536:  ADDWFC 03,W
03538:  MOVWF  FEA
0353A:  MOVFF  FEF,647
0353E:  MOVF   FF2,W
03540:  MOVWF  00
03542:  BCF    FF2.7
03544:  CLRF   FAA
03546:  MOVFF  646,FA9
0354A:  MOVFF  647,FA8
0354E:  BCF    FA6.6
03550:  BCF    FA6.7
03552:  BSF    FA6.2
03554:  MOVLB  F
03556:  MOVLW  55
03558:  MOVWF  FA7
0355A:  MOVLW  AA
0355C:  MOVWF  FA7
0355E:  BSF    FA6.1
03560:  BTFSC  FA6.1
03562:  BRA    3560
03564:  BCF    FA6.2
03566:  MOVF   00,W
03568:  IORWF  FF2,F
.................... 			}else{ 
0356A:  BRA    37E4
0356C:  MOVLB  6
....................  
.................... 				 
.................... 				fprintf(WIFI,"Switch Internal: %u\n",switchNumber); 
0356E:  MOVLW  30
03570:  MOVWF  FF6
03572:  MOVLW  0C
03574:  MOVWF  FF7
03576:  CLRF   19
03578:  BTFSC  FF2.7
0357A:  BSF    19.7
0357C:  BCF    FF2.7
0357E:  MOVLW  11
03580:  MOVWF  x6C
03582:  MOVLB  0
03584:  CALL   050C
03588:  BTFSC  19.7
0358A:  BSF    FF2.7
0358C:  CLRF   19
0358E:  BTFSC  FF2.7
03590:  BSF    19.7
03592:  BCF    FF2.7
03594:  MOVFF  62A,66C
03598:  MOVLW  1B
0359A:  MOVLB  6
0359C:  MOVWF  x6D
0359E:  MOVLB  0
035A0:  CALL   0768
035A4:  BTFSC  19.7
035A6:  BSF    FF2.7
035A8:  MOVLW  0A
035AA:  BTFSS  F9E.4
035AC:  BRA    35AA
035AE:  MOVWF  FAD
.................... 				fprintf(WIFI,"Control Mode: %c\n",switchControlMode); 
035B0:  MOVLW  46
035B2:  MOVWF  FF6
035B4:  MOVLW  0C
035B6:  MOVWF  FF7
035B8:  CLRF   19
035BA:  BTFSC  FF2.7
035BC:  BSF    19.7
035BE:  BCF    FF2.7
035C0:  MOVLW  0E
035C2:  MOVLB  6
035C4:  MOVWF  x6C
035C6:  MOVLB  0
035C8:  CALL   050C
035CC:  BTFSC  19.7
035CE:  BSF    FF2.7
035D0:  MOVLB  6
035D2:  MOVF   x2D,W
035D4:  BTFSS  F9E.4
035D6:  BRA    35D4
035D8:  MOVWF  FAD
035DA:  MOVLW  0A
035DC:  BTFSS  F9E.4
035DE:  BRA    35DC
035E0:  MOVWF  FAD
.................... 				 
.................... 				if(switchControlMode == SWITCH_ON){ 
035E2:  MOVF   x2D,W
035E4:  SUBLW  4E
035E6:  BNZ   3632
.................... 					output_high(internalSwitch[switchNumber-1]); 
035E8:  MOVLW  01
035EA:  SUBWF  x2A,W
035EC:  CLRF   03
035EE:  ADDLW  21
035F0:  MOVWF  FE9
035F2:  MOVLW  00
035F4:  ADDWFC 03,W
035F6:  MOVWF  FEA
035F8:  MOVFF  FEF,647
035FC:  MOVLW  01
035FE:  MOVWF  x48
03600:  MOVLW  0F
03602:  MOVWF  x4A
03604:  MOVLW  89
03606:  MOVWF  x49
03608:  MOVLB  0
0360A:  CALL   1498
.................... 					delay_ms(200); 
0360E:  MOVLW  C8
03610:  MOVLB  6
03612:  MOVWF  x4B
03614:  MOVLB  0
03616:  CALL   1062
.................... 					internalSwitchStatus[switchNumber-1] = 1; 
0361A:  MOVLW  01
0361C:  MOVLB  6
0361E:  SUBWF  x2A,W
03620:  CLRF   03
03622:  ADDLW  27
03624:  MOVWF  FE9
03626:  MOVLW  00
03628:  ADDWFC 03,W
0362A:  MOVWF  FEA
0362C:  MOVLW  01
0362E:  MOVWF  FEF
.................... 					 
.................... 				}else if(switchControlMode == SWITCH_OFF){ 
03630:  BRA    36F8
03632:  MOVF   x2D,W
03634:  SUBLW  46
03636:  BNZ   367E
.................... 					output_low(internalSwitch[switchNumber-1]); 
03638:  MOVLW  01
0363A:  SUBWF  x2A,W
0363C:  CLRF   03
0363E:  ADDLW  21
03640:  MOVWF  FE9
03642:  MOVLW  00
03644:  ADDWFC 03,W
03646:  MOVWF  FEA
03648:  MOVFF  FEF,647
0364C:  CLRF   x48
0364E:  MOVLW  0F
03650:  MOVWF  x4A
03652:  MOVLW  89
03654:  MOVWF  x49
03656:  MOVLB  0
03658:  CALL   1498
.................... 					delay_ms(200); 
0365C:  MOVLW  C8
0365E:  MOVLB  6
03660:  MOVWF  x4B
03662:  MOVLB  0
03664:  CALL   1062
.................... 					internalSwitchStatus[switchNumber-1] = 0; 
03668:  MOVLW  01
0366A:  MOVLB  6
0366C:  SUBWF  x2A,W
0366E:  CLRF   03
03670:  ADDLW  27
03672:  MOVWF  FE9
03674:  MOVLW  00
03676:  ADDWFC 03,W
03678:  MOVWF  FEA
0367A:  CLRF   FEF
.................... 				 
.................... 				}else if(switchControlMode == SWITCH_TOGGLE){ 
0367C:  BRA    36F8
0367E:  MOVF   x2D,W
03680:  SUBLW  54
03682:  BNZ   36F8
.................... 					output_high(internalSwitch[switchNumber-1]); 
03684:  MOVLW  01
03686:  SUBWF  x2A,W
03688:  CLRF   03
0368A:  ADDLW  21
0368C:  MOVWF  FE9
0368E:  MOVLW  00
03690:  ADDWFC 03,W
03692:  MOVWF  FEA
03694:  MOVFF  FEF,647
03698:  MOVLW  01
0369A:  MOVWF  x48
0369C:  MOVLW  0F
0369E:  MOVWF  x4A
036A0:  MOVLW  89
036A2:  MOVWF  x49
036A4:  MOVLB  0
036A6:  CALL   1498
.................... 					delay_ms(2000); 
036AA:  MOVLW  08
036AC:  MOVLB  6
036AE:  MOVWF  x46
036B0:  MOVLW  FA
036B2:  MOVWF  x4B
036B4:  MOVLB  0
036B6:  CALL   1062
036BA:  MOVLB  6
036BC:  DECFSZ x46,F
036BE:  BRA    36B0
.................... 					output_low(internalSwitch[switchNumber-1]); 
036C0:  MOVLW  01
036C2:  SUBWF  x2A,W
036C4:  CLRF   03
036C6:  ADDLW  21
036C8:  MOVWF  FE9
036CA:  MOVLW  00
036CC:  ADDWFC 03,W
036CE:  MOVWF  FEA
036D0:  MOVFF  FEF,647
036D4:  CLRF   x48
036D6:  MOVLW  0F
036D8:  MOVWF  x4A
036DA:  MOVLW  89
036DC:  MOVWF  x49
036DE:  MOVLB  0
036E0:  CALL   1498
.................... 					internalSwitchStatus[switchNumber-1] = 0; 
036E4:  MOVLW  01
036E6:  MOVLB  6
036E8:  SUBWF  x2A,W
036EA:  CLRF   03
036EC:  ADDLW  27
036EE:  MOVWF  FE9
036F0:  MOVLW  00
036F2:  ADDWFC 03,W
036F4:  MOVWF  FEA
036F6:  CLRF   FEF
.................... 				} 
.................... 	 
.................... 				//$MQSWCR;switchNumber;switchControlMode;success;uuid 
.................... 				fprintf(ESP8266,"%sR;%u;%c;1;%s*", command, requestSwitchNumber ,switchControlMode, uuid); 
036F8:  MOVFF  629,FEA
036FC:  MOVFF  628,FE9
03700:  CLRF   19
03702:  BTFSC  FF2.7
03704:  BSF    19.7
03706:  BCF    FF2.7
03708:  MOVLB  0
0370A:  CALL   0EAE
0370E:  BTFSC  19.7
03710:  BSF    FF2.7
03712:  MOVLW  52
03714:  BTFSS  FA4.4
03716:  BRA    3714
03718:  MOVWF  F73
0371A:  MOVLW  3B
0371C:  BTFSS  FA4.4
0371E:  BRA    371C
03720:  MOVWF  F73
03722:  CLRF   19
03724:  BTFSC  FF2.7
03726:  BSF    19.7
03728:  BCF    FF2.7
0372A:  MOVFF  62B,670
0372E:  MOVLW  1B
03730:  MOVLB  6
03732:  MOVWF  x71
03734:  MOVLB  0
03736:  CALL   0E30
0373A:  BTFSC  19.7
0373C:  BSF    FF2.7
0373E:  MOVLW  3B
03740:  BTFSS  FA4.4
03742:  BRA    3740
03744:  MOVWF  F73
03746:  MOVLB  6
03748:  MOVF   x2D,W
0374A:  BTFSS  FA4.4
0374C:  BRA    374A
0374E:  MOVWF  F73
03750:  MOVLW  61
03752:  MOVWF  FF6
03754:  MOVLW  0C
03756:  MOVWF  FF7
03758:  CLRF   19
0375A:  BTFSC  FF2.7
0375C:  BSF    19.7
0375E:  BCF    FF2.7
03760:  MOVLW  03
03762:  MOVWF  x70
03764:  MOVLB  0
03766:  CALL   0E06
0376A:  BTFSC  19.7
0376C:  BSF    FF2.7
0376E:  MOVFF  645,FEA
03772:  MOVFF  644,FE9
03776:  CLRF   19
03778:  BTFSC  FF2.7
0377A:  BSF    19.7
0377C:  BCF    FF2.7
0377E:  CALL   0EAE
03782:  BTFSC  19.7
03784:  BSF    FF2.7
03786:  MOVLW  2A
03788:  BTFSS  FA4.4
0378A:  BRA    3788
0378C:  MOVWF  F73
.................... 				write_eeprom(saveInternalSwitchStatusAddress[switchnumber-1],internalSwitchStatus[switchnumber-1]); 
0378E:  MOVLW  01
03790:  MOVLB  6
03792:  SUBWF  x2A,W
03794:  CLRF   03
03796:  ADDLW  45
03798:  MOVWF  FE9
0379A:  MOVLW  00
0379C:  ADDWFC 03,W
0379E:  MOVWF  FEA
037A0:  MOVFF  FEF,646
037A4:  MOVLW  01
037A6:  SUBWF  x2A,W
037A8:  CLRF   03
037AA:  ADDLW  27
037AC:  MOVWF  FE9
037AE:  MOVLW  00
037B0:  ADDWFC 03,W
037B2:  MOVWF  FEA
037B4:  MOVFF  FEF,647
037B8:  MOVF   FF2,W
037BA:  MOVWF  00
037BC:  BCF    FF2.7
037BE:  CLRF   FAA
037C0:  MOVFF  646,FA9
037C4:  MOVFF  647,FA8
037C8:  BCF    FA6.6
037CA:  BCF    FA6.7
037CC:  BSF    FA6.2
037CE:  MOVLB  F
037D0:  MOVLW  55
037D2:  MOVWF  FA7
037D4:  MOVLW  AA
037D6:  MOVWF  FA7
037D8:  BSF    FA6.1
037DA:  BTFSC  FA6.1
037DC:  BRA    37DA
037DE:  BCF    FA6.2
037E0:  MOVF   00,W
037E2:  IORWF  FF2,F
037E4:  MOVLB  6
.................... 			} 
.................... 	 
.................... 	 
.................... 			ptr = NULL; 
037E6:  CLRF   x41
037E8:  CLRF   x40
.................... 			ClearESP8266_Receive(); 
037EA:  MOVLB  0
037EC:  CALL   24DC
.................... 			return; 
037F0:  GOTO   4A6E
.................... 		} 
.................... 	 
....................  
.................... 		//$MQSWSTATUS;uuid* 
.................... 		if(strcmp(command, commandStatus) == 0){ 
037F4:  MOVFF  629,647
037F8:  MOVFF  628,646
037FC:  MOVFF  38E,649
03800:  MOVFF  38D,648
03804:  CALL   1C7C
03808:  MOVF   01,F
0380A:  BTFSS  FD8.2
0380C:  BRA    3A4E
.................... 			uuid = strtok(0,delimeter); 
0380E:  MOVLB  6
03810:  CLRF   x47
03812:  CLRF   x46
03814:  MOVLW  06
03816:  MOVWF  x49
03818:  MOVLW  26
0381A:  MOVWF  x48
0381C:  MOVLB  0
0381E:  CALL   1BC4
03822:  MOVFF  02,645
03826:  MOVFF  01,644
.................... 			delay_ms(200); 
0382A:  MOVLW  C8
0382C:  MOVLB  6
0382E:  MOVWF  x4B
03830:  MOVLB  0
03832:  CALL   1062
....................  
.................... 			strcpy(allSwStatus, command); 
03836:  MOVFF  62F,FEA
0383A:  MOVFF  62E,FE9
0383E:  MOVFF  629,FE2
03842:  MOVFF  628,FE1
03846:  MOVF   FE7,F
03848:  MOVFF  FE6,FEE
0384C:  BNZ   3846
.................... //			ptr = allSwStatus + strlen(allSwStatus); 
.................... //			ptr[0] = 'R'; 
.................... //			ptr[1] = 0; 
.................... 			 
.................... 			 
....................  
.................... //			stringLength = strlen(allSwStatus); 
.................... //			allSwStatus[stringLength] = 'R'; 
.................... 			fprintf(ESP8266,"%sR", command); 
0384E:  MOVFF  629,FEA
03852:  MOVFF  628,FE9
03856:  CLRF   19
03858:  BTFSC  FF2.7
0385A:  BSF    19.7
0385C:  BCF    FF2.7
0385E:  CALL   0EAE
03862:  BTFSC  19.7
03864:  BSF    FF2.7
03866:  MOVLW  52
03868:  BTFSS  FA4.4
0386A:  BRA    3868
0386C:  MOVWF  F73
.................... 			 
.................... 			 
.................... 			fprintf(WIFI,"Size %u\n",sizeof(internalSwitchStatus));  
0386E:  MOVLW  68
03870:  MOVWF  FF6
03872:  MOVLW  0C
03874:  MOVWF  FF7
03876:  CLRF   19
03878:  BTFSC  FF2.7
0387A:  BSF    19.7
0387C:  BCF    FF2.7
0387E:  MOVLW  05
03880:  MOVLB  6
03882:  MOVWF  x6C
03884:  MOVLB  0
03886:  CALL   050C
0388A:  BTFSC  19.7
0388C:  BSF    FF2.7
0388E:  CLRF   19
03890:  BTFSC  FF2.7
03892:  BSF    19.7
03894:  BCF    FF2.7
03896:  MOVLW  0A
03898:  MOVLB  6
0389A:  MOVWF  x6C
0389C:  MOVLW  1B
0389E:  MOVWF  x6D
038A0:  MOVLB  0
038A2:  CALL   0768
038A6:  BTFSC  19.7
038A8:  BSF    FF2.7
038AA:  MOVLW  0A
038AC:  BTFSS  F9E.4
038AE:  BRA    38AC
038B0:  MOVWF  FAD
.................... 			//fprintf(ESP8266,";I;%u", sizeof(internalSwitchStatus)); 
.................... 			for(i=0; i<sizeof(internalSwitchStatus); i++){ 
038B2:  CLRF   xBD
038B4:  MOVF   xBD,W
038B6:  SUBLW  09
038B8:  BNC   3912
....................  
.................... 				itoa(internalSwitchStatus[i], 10, ptr); 
038BA:  CLRF   03
038BC:  MOVF   xBD,W
038BE:  ADDLW  27
038C0:  MOVWF  FE9
038C2:  MOVLW  00
038C4:  ADDWFC 03,W
038C6:  MOVWF  FEA
038C8:  MOVFF  FEF,647
038CC:  MOVLB  6
038CE:  CLRF   x4A
038D0:  CLRF   x49
038D2:  CLRF   x48
038D4:  MOVLW  0A
038D6:  MOVWF  x4B
038D8:  MOVFF  641,64D
038DC:  MOVFF  640,64C
038E0:  MOVLB  0
038E2:  CALL   2634
.................... 				fprintf(ESP8266,";%s", ptr); 
038E6:  MOVLW  3B
038E8:  BTFSS  FA4.4
038EA:  BRA    38E8
038EC:  MOVWF  F73
038EE:  MOVFF  641,FEA
038F2:  MOVFF  640,FE9
038F6:  CLRF   19
038F8:  BTFSC  FF2.7
038FA:  BSF    19.7
038FC:  BCF    FF2.7
038FE:  CALL   0EAE
03902:  BTFSC  19.7
03904:  BSF    FF2.7
.................... 				ptr = NULL; 
03906:  MOVLB  6
03908:  CLRF   x41
0390A:  CLRF   x40
0390C:  MOVLB  0
0390E:  INCF   xBD,F
03910:  BRA    38B4
....................  
.................... 			} 
....................  
.................... 			fprintf(WIFI,"Size %u\n",sizeof(wirelessSwitchStatus));  
03912:  MOVLW  72
03914:  MOVWF  FF6
03916:  MOVLW  0C
03918:  MOVWF  FF7
0391A:  CLRF   19
0391C:  BTFSC  FF2.7
0391E:  BSF    19.7
03920:  BCF    FF2.7
03922:  MOVLW  05
03924:  MOVLB  6
03926:  MOVWF  x6C
03928:  MOVLB  0
0392A:  CALL   050C
0392E:  BTFSC  19.7
03930:  BSF    FF2.7
03932:  CLRF   19
03934:  BTFSC  FF2.7
03936:  BSF    19.7
03938:  BCF    FF2.7
0393A:  MOVLW  0A
0393C:  MOVLB  6
0393E:  MOVWF  x6C
03940:  MOVLW  1B
03942:  MOVWF  x6D
03944:  MOVLB  0
03946:  CALL   0768
0394A:  BTFSC  19.7
0394C:  BSF    FF2.7
0394E:  MOVLW  0A
03950:  BTFSS  F9E.4
03952:  BRA    3950
03954:  MOVWF  FAD
.................... 			//fprintf(ESP8266,";W;%u", sizeof(wirelessSwitchStatus)); 
.................... 			for(i=0; i<sizeof(wirelessSwitchStatus); i++){ 
03956:  CLRF   xBD
03958:  MOVF   xBD,W
0395A:  SUBLW  09
0395C:  BNC   39B6
....................  
.................... 				itoa(wirelessSwitchStatus[i], 10, ptr); 
0395E:  CLRF   03
03960:  MOVF   xBD,W
03962:  ADDLW  31
03964:  MOVWF  FE9
03966:  MOVLW  00
03968:  ADDWFC 03,W
0396A:  MOVWF  FEA
0396C:  MOVFF  FEF,647
03970:  MOVLB  6
03972:  CLRF   x4A
03974:  CLRF   x49
03976:  CLRF   x48
03978:  MOVLW  0A
0397A:  MOVWF  x4B
0397C:  MOVFF  641,64D
03980:  MOVFF  640,64C
03984:  MOVLB  0
03986:  CALL   2634
.................... 				fprintf(ESP8266,";%s", ptr); 
0398A:  MOVLW  3B
0398C:  BTFSS  FA4.4
0398E:  BRA    398C
03990:  MOVWF  F73
03992:  MOVFF  641,FEA
03996:  MOVFF  640,FE9
0399A:  CLRF   19
0399C:  BTFSC  FF2.7
0399E:  BSF    19.7
039A0:  BCF    FF2.7
039A2:  CALL   0EAE
039A6:  BTFSC  19.7
039A8:  BSF    FF2.7
.................... 				ptr = NULL; 
039AA:  MOVLB  6
039AC:  CLRF   x41
039AE:  CLRF   x40
039B0:  MOVLB  0
039B2:  INCF   xBD,F
039B4:  BRA    3958
....................  
.................... 			} 
....................  
.................... 			fprintf(WIFI,"Size %u\n",sizeof(livoloSwitchStatus));  
039B6:  MOVLW  7C
039B8:  MOVWF  FF6
039BA:  MOVLW  0C
039BC:  MOVWF  FF7
039BE:  CLRF   19
039C0:  BTFSC  FF2.7
039C2:  BSF    19.7
039C4:  BCF    FF2.7
039C6:  MOVLW  05
039C8:  MOVLB  6
039CA:  MOVWF  x6C
039CC:  MOVLB  0
039CE:  CALL   050C
039D2:  BTFSC  19.7
039D4:  BSF    FF2.7
039D6:  CLRF   19
039D8:  BTFSC  FF2.7
039DA:  BSF    19.7
039DC:  BCF    FF2.7
039DE:  MOVLW  0A
039E0:  MOVLB  6
039E2:  MOVWF  x6C
039E4:  MOVLW  1B
039E6:  MOVWF  x6D
039E8:  MOVLB  0
039EA:  CALL   0768
039EE:  BTFSC  19.7
039F0:  BSF    FF2.7
039F2:  MOVLW  0A
039F4:  BTFSS  F9E.4
039F6:  BRA    39F4
039F8:  MOVWF  FAD
.................... //			fprintf(ESP8266,";L;%u", sizeof(livoloSwitchStatus)); 
.................... 			for(i=0; i<sizeof(livoloSwitchStatus); i++){ 
039FA:  CLRF   xBD
039FC:  MOVF   xBD,W
039FE:  SUBLW  09
03A00:  BNC   3A16
....................  
.................... 				//itoa(livoloSwitchStatus[i], 10, ptr); 
.................... 				//fprintf(ESP8266,";%s", ptr); 
.................... 				//ptr = NULL; 
.................... 				fprintf(ESP8266,";0"); 
03A02:  MOVLW  3B
03A04:  BTFSS  FA4.4
03A06:  BRA    3A04
03A08:  MOVWF  F73
03A0A:  MOVLW  30
03A0C:  BTFSS  FA4.4
03A0E:  BRA    3A0C
03A10:  MOVWF  F73
03A12:  INCF   xBD,F
03A14:  BRA    39FC
....................  
.................... 			} 
....................  
....................  
.................... 			fprintf(ESP8266,";%s*", uuid); 
03A16:  MOVLW  3B
03A18:  BTFSS  FA4.4
03A1A:  BRA    3A18
03A1C:  MOVWF  F73
03A1E:  MOVFF  645,FEA
03A22:  MOVFF  644,FE9
03A26:  CLRF   19
03A28:  BTFSC  FF2.7
03A2A:  BSF    19.7
03A2C:  BCF    FF2.7
03A2E:  CALL   0EAE
03A32:  BTFSC  19.7
03A34:  BSF    FF2.7
03A36:  MOVLW  2A
03A38:  BTFSS  FA4.4
03A3A:  BRA    3A38
03A3C:  MOVWF  F73
....................  
....................  
.................... 			ptr = NULL; 
03A3E:  MOVLB  6
03A40:  CLRF   x41
03A42:  CLRF   x40
.................... 			ClearESP8266_Receive(); 
03A44:  MOVLB  0
03A46:  CALL   24DC
.................... 			return; 
03A4A:  GOTO   4A6E
.................... 		} 
....................  
.................... 		//============================================================================================================================           
.................... 		//$MQTMSET;id;1;T;20;M;d;H;m;1;0-127;uuid* 
.................... 		//id=99 for new timer 
.................... 		if(strcmp(command, commandSetTimer) == 0){ 
03A4E:  MOVFF  629,647
03A52:  MOVFF  628,646
03A56:  MOVFF  36A,649
03A5A:  MOVFF  369,648
03A5E:  CALL   1C7C
03A62:  MOVF   01,F
03A64:  BTFSS  FD8.2
03A66:  GOTO   4244
.................... 			setId = atoi(strtok(0,delimeter)); 
03A6A:  MOVLB  6
03A6C:  CLRF   x47
03A6E:  CLRF   x46
03A70:  MOVLW  06
03A72:  MOVWF  x49
03A74:  MOVLW  26
03A76:  MOVWF  x48
03A78:  MOVLB  0
03A7A:  CALL   1BC4
03A7E:  MOVFF  02,647
03A82:  MOVFF  01,646
03A86:  MOVFF  02,649
03A8A:  MOVFF  01,648
03A8E:  CALL   1D44
03A92:  MOVFF  01,63F
....................  
.................... 			requestSwitchNumber = atoi(strtok(0,delimeter)); 
03A96:  MOVLB  6
03A98:  CLRF   x47
03A9A:  CLRF   x46
03A9C:  MOVLW  06
03A9E:  MOVWF  x49
03AA0:  MOVLW  26
03AA2:  MOVWF  x48
03AA4:  MOVLB  0
03AA6:  CALL   1BC4
03AAA:  MOVFF  02,647
03AAE:  MOVFF  01,646
03AB2:  MOVFF  02,649
03AB6:  MOVFF  01,648
03ABA:  CALL   1D44
03ABE:  MOVFF  01,62B
.................... 			ptr = strtok(0,delimeter); 
03AC2:  MOVLB  6
03AC4:  CLRF   x47
03AC6:  CLRF   x46
03AC8:  MOVLW  06
03ACA:  MOVWF  x49
03ACC:  MOVLW  26
03ACE:  MOVWF  x48
03AD0:  MOVLB  0
03AD2:  CALL   1BC4
03AD6:  MOVFF  02,641
03ADA:  MOVFF  01,640
.................... 			//deviceType = ptr[0]; 
.................... 			ptr = strtok(0,delimeter); 
03ADE:  MOVLB  6
03AE0:  CLRF   x47
03AE2:  CLRF   x46
03AE4:  MOVLW  06
03AE6:  MOVWF  x49
03AE8:  MOVLW  26
03AEA:  MOVWF  x48
03AEC:  MOVLB  0
03AEE:  CALL   1BC4
03AF2:  MOVFF  02,641
03AF6:  MOVFF  01,640
.................... 			switchControlMode = ptr[0]; 
03AFA:  MOVLB  6
03AFC:  MOVFF  640,FE9
03B00:  MOVFF  641,FEA
03B04:  MOVFF  FEF,62D
.................... 		 
.................... 			//secondDuration = atoi(strtok(0,delimeter)); 
.................... 			//monthSet = atoi(strtok(0,delimeter)); 
.................... 			//dateSet = atoi(strtok(0,delimeter)); 
.................... 			hourSet = atoi(strtok(0,delimeter)); 
03B08:  CLRF   x47
03B0A:  CLRF   x46
03B0C:  MOVLW  06
03B0E:  MOVWF  x49
03B10:  MOVLW  26
03B12:  MOVWF  x48
03B14:  MOVLB  0
03B16:  CALL   1BC4
03B1A:  MOVFF  02,647
03B1E:  MOVFF  01,646
03B22:  MOVFF  02,649
03B26:  MOVFF  01,648
03B2A:  CALL   1D44
03B2E:  MOVFF  01,633
.................... 			minuteSet = atoi(strtok(0,delimeter)); 
03B32:  MOVLB  6
03B34:  CLRF   x47
03B36:  CLRF   x46
03B38:  MOVLW  06
03B3A:  MOVWF  x49
03B3C:  MOVLW  26
03B3E:  MOVWF  x48
03B40:  MOVLB  0
03B42:  CALL   1BC4
03B46:  MOVFF  02,647
03B4A:  MOVFF  01,646
03B4E:  MOVFF  02,649
03B52:  MOVFF  01,648
03B56:  CALL   1D44
03B5A:  MOVFF  01,634
.................... 			recurrent = atoi(strtok(0,delimeter)); 
03B5E:  MOVLB  6
03B60:  CLRF   x47
03B62:  CLRF   x46
03B64:  MOVLW  06
03B66:  MOVWF  x49
03B68:  MOVLW  26
03B6A:  MOVWF  x48
03B6C:  MOVLB  0
03B6E:  CALL   1BC4
03B72:  MOVFF  02,647
03B76:  MOVFF  01,646
03B7A:  MOVFF  02,649
03B7E:  MOVFF  01,648
03B82:  CALL   1D44
03B86:  MOVFF  01,635
.................... 			recurrentDay = strtok(0,delimeter); 
03B8A:  MOVLB  6
03B8C:  CLRF   x47
03B8E:  CLRF   x46
03B90:  MOVLW  06
03B92:  MOVWF  x49
03B94:  MOVLW  26
03B96:  MOVWF  x48
03B98:  MOVLB  0
03B9A:  CALL   1BC4
03B9E:  MOVFF  02,63E
03BA2:  MOVFF  01,63D
....................  
.................... 			//last command 
.................... 			uuid = strtok(0,delimeter); 
03BA6:  MOVLB  6
03BA8:  CLRF   x47
03BAA:  CLRF   x46
03BAC:  MOVLW  06
03BAE:  MOVWF  x49
03BB0:  MOVLW  26
03BB2:  MOVWF  x48
03BB4:  MOVLB  0
03BB6:  CALL   1BC4
03BBA:  MOVFF  02,645
03BBE:  MOVFF  01,644
....................  
....................  
.................... 			if(requestSwitchNumber <= sizeof(internalSwitchStatus)){ 
03BC2:  MOVLB  6
03BC4:  MOVF   x2B,W
03BC6:  SUBLW  0A
03BC8:  BNC   3BD4
.................... 				switchNumber = requestSwitchNumber; 
03BCA:  MOVFF  62B,62A
.................... 				deviceType = INTERNAL; 
03BCE:  MOVLW  49
03BD0:  MOVWF  x2C
.................... 			}else if(requestSwitchNumber > sizeof(internalSwitchStatus) && requestSwitchNumber <= sizeof(internalSwitchStatus) + sizeof(wirelessSwitchStatus)){ 
03BD2:  BRA    3BF8
03BD4:  MOVF   x2B,W
03BD6:  SUBLW  0A
03BD8:  BC    3BEC
03BDA:  MOVF   x2B,W
03BDC:  SUBLW  14
03BDE:  BNC   3BEC
.................... 				switchNumber = requestSwitchNumber - sizeof(internalSwitchStatus); 
03BE0:  MOVLW  0A
03BE2:  SUBWF  x2B,W
03BE4:  MOVWF  x2A
.................... 				deviceType = WIRELESS; 
03BE6:  MOVLW  57
03BE8:  MOVWF  x2C
.................... 			}else{ 
03BEA:  BRA    3BF8
.................... 				switchNumber = requestSwitchNumber - sizeof(internalSwitchStatus) - sizeof(wirelessSwitchStatus); 
03BEC:  MOVLW  0A
03BEE:  SUBWF  x2B,W
03BF0:  ADDLW  F6
03BF2:  MOVWF  x2A
.................... 				deviceType = LIVOLO; 
03BF4:  MOVLW  4C
03BF6:  MOVWF  x2C
.................... 			} 
....................  
....................  
.................... 			 
.................... 	 
....................  
.................... 			timerEnable[setId] = 1; 
03BF8:  CLRF   03
03BFA:  MOVF   x3F,W
03BFC:  ADDLW  65
03BFE:  MOVWF  FE9
03C00:  MOVLW  02
03C02:  ADDWFC 03,W
03C04:  MOVWF  FEA
03C06:  MOVLW  01
03C08:  MOVWF  FEF
.................... 			timerSwitchNumber[setId] = switchNumber; 
03C0A:  CLRF   03
03C0C:  MOVF   x3F,W
03C0E:  ADDLW  7A
03C10:  MOVWF  FE9
03C12:  MOVLW  02
03C14:  ADDWFC 03,W
03C16:  MOVWF  FEA
03C18:  MOVFF  62A,FEF
.................... 			timerDeviceType[setId] = deviceType; 
03C1C:  CLRF   03
03C1E:  MOVF   x3F,W
03C20:  ADDLW  8F
03C22:  MOVWF  FE9
03C24:  MOVLW  02
03C26:  ADDWFC 03,W
03C28:  MOVWF  FEA
03C2A:  MOVFF  62C,FEF
.................... 			timerControlMode[setId] = switchControlMode; 
03C2E:  CLRF   03
03C30:  MOVF   x3F,W
03C32:  ADDLW  A4
03C34:  MOVWF  FE9
03C36:  MOVLW  02
03C38:  ADDWFC 03,W
03C3A:  MOVWF  FEA
03C3C:  MOVFF  62D,FEF
.................... //			timerSecondDuration[setId] = secondDuration; 
.................... //			timerMonth[setId] = monthSet; 
.................... //			timerDate[setId] = dateSet; 
.................... 			timerHour[setId] = hourSet; 
03C40:  CLRF   03
03C42:  MOVF   x3F,W
03C44:  ADDLW  B9
03C46:  MOVWF  FE9
03C48:  MOVLW  02
03C4A:  ADDWFC 03,W
03C4C:  MOVWF  FEA
03C4E:  MOVFF  633,FEF
.................... 			timerMinute[setId] = minuteSet; 
03C52:  CLRF   03
03C54:  MOVF   x3F,W
03C56:  ADDLW  CE
03C58:  MOVWF  FE9
03C5A:  MOVLW  02
03C5C:  ADDWFC 03,W
03C5E:  MOVWF  FEA
03C60:  MOVFF  634,FEF
.................... 			 
....................  
.................... 			 
.................... 			if(recurrent == 1){ 
03C64:  DECFSZ x35,W
03C66:  BRA    3E3C
.................... 				 
.................... 				bit_set(timerRecurrent[setId],7); 
03C68:  CLRF   03
03C6A:  MOVF   x3F,W
03C6C:  ADDLW  F8
03C6E:  MOVWF  01
03C70:  MOVLW  02
03C72:  ADDWFC 03,F
03C74:  MOVFF  01,FE9
03C78:  MOVFF  03,FEA
03C7C:  BSF    FEF.7
....................  
.................... 				//sunday 
.................... 				if(recurrentDay[0] == '1'){ 
03C7E:  MOVFF  63D,FE9
03C82:  MOVFF  63E,FEA
03C86:  MOVF   FEF,W
03C88:  SUBLW  31
03C8A:  BNZ   3CA4
.................... 					bit_set(timerRecurrent[setId],6); 
03C8C:  CLRF   03
03C8E:  MOVF   x3F,W
03C90:  ADDLW  F8
03C92:  MOVWF  01
03C94:  MOVLW  02
03C96:  ADDWFC 03,F
03C98:  MOVFF  01,FE9
03C9C:  MOVFF  03,FEA
03CA0:  BSF    FEF.6
.................... 				}else{ 
03CA2:  BRA    3CBA
.................... 					bit_clear(timerRecurrent[setId],6); 
03CA4:  CLRF   03
03CA6:  MOVF   x3F,W
03CA8:  ADDLW  F8
03CAA:  MOVWF  01
03CAC:  MOVLW  02
03CAE:  ADDWFC 03,F
03CB0:  MOVFF  01,FE9
03CB4:  MOVFF  03,FEA
03CB8:  BCF    FEF.6
.................... 				} 
.................... 				 
.................... 				//monday 
.................... 				if(recurrentDay[1] == '1'){ 
03CBA:  MOVLW  01
03CBC:  ADDWF  x3D,W
03CBE:  MOVWF  FE9
03CC0:  MOVLW  00
03CC2:  ADDWFC x3E,W
03CC4:  MOVWF  FEA
03CC6:  MOVF   FEF,W
03CC8:  SUBLW  31
03CCA:  BNZ   3CE4
.................... 					bit_set(timerRecurrent[setId],5); 
03CCC:  CLRF   03
03CCE:  MOVF   x3F,W
03CD0:  ADDLW  F8
03CD2:  MOVWF  01
03CD4:  MOVLW  02
03CD6:  ADDWFC 03,F
03CD8:  MOVFF  01,FE9
03CDC:  MOVFF  03,FEA
03CE0:  BSF    FEF.5
.................... 				}else{ 
03CE2:  BRA    3CFA
.................... 					bit_clear(timerRecurrent[setId],5); 
03CE4:  CLRF   03
03CE6:  MOVF   x3F,W
03CE8:  ADDLW  F8
03CEA:  MOVWF  01
03CEC:  MOVLW  02
03CEE:  ADDWFC 03,F
03CF0:  MOVFF  01,FE9
03CF4:  MOVFF  03,FEA
03CF8:  BCF    FEF.5
.................... 				} 
....................  
.................... 				//tuesday 
.................... 				if(recurrentDay[2] == '1'){ 
03CFA:  MOVLW  02
03CFC:  ADDWF  x3D,W
03CFE:  MOVWF  FE9
03D00:  MOVLW  00
03D02:  ADDWFC x3E,W
03D04:  MOVWF  FEA
03D06:  MOVF   FEF,W
03D08:  SUBLW  31
03D0A:  BNZ   3D24
.................... 					bit_set(timerRecurrent[setId],4); 
03D0C:  CLRF   03
03D0E:  MOVF   x3F,W
03D10:  ADDLW  F8
03D12:  MOVWF  01
03D14:  MOVLW  02
03D16:  ADDWFC 03,F
03D18:  MOVFF  01,FE9
03D1C:  MOVFF  03,FEA
03D20:  BSF    FEF.4
.................... 				}else{ 
03D22:  BRA    3D3A
.................... 					bit_clear(timerRecurrent[setId],4); 
03D24:  CLRF   03
03D26:  MOVF   x3F,W
03D28:  ADDLW  F8
03D2A:  MOVWF  01
03D2C:  MOVLW  02
03D2E:  ADDWFC 03,F
03D30:  MOVFF  01,FE9
03D34:  MOVFF  03,FEA
03D38:  BCF    FEF.4
.................... 				} 
....................  
.................... 				//wednesday 
.................... 				if(recurrentDay[3] == '1'){ 
03D3A:  MOVLW  03
03D3C:  ADDWF  x3D,W
03D3E:  MOVWF  FE9
03D40:  MOVLW  00
03D42:  ADDWFC x3E,W
03D44:  MOVWF  FEA
03D46:  MOVF   FEF,W
03D48:  SUBLW  31
03D4A:  BNZ   3D64
.................... 					bit_set(timerRecurrent[setId],3); 
03D4C:  CLRF   03
03D4E:  MOVF   x3F,W
03D50:  ADDLW  F8
03D52:  MOVWF  01
03D54:  MOVLW  02
03D56:  ADDWFC 03,F
03D58:  MOVFF  01,FE9
03D5C:  MOVFF  03,FEA
03D60:  BSF    FEF.3
.................... 				}else{ 
03D62:  BRA    3D7A
.................... 					bit_clear(timerRecurrent[setId],3); 
03D64:  CLRF   03
03D66:  MOVF   x3F,W
03D68:  ADDLW  F8
03D6A:  MOVWF  01
03D6C:  MOVLW  02
03D6E:  ADDWFC 03,F
03D70:  MOVFF  01,FE9
03D74:  MOVFF  03,FEA
03D78:  BCF    FEF.3
.................... 				} 
....................  
.................... 				//thursday 
.................... 				if(recurrentDay[4] == '1'){ 
03D7A:  MOVLW  04
03D7C:  ADDWF  x3D,W
03D7E:  MOVWF  FE9
03D80:  MOVLW  00
03D82:  ADDWFC x3E,W
03D84:  MOVWF  FEA
03D86:  MOVF   FEF,W
03D88:  SUBLW  31
03D8A:  BNZ   3DA4
.................... 					bit_set(timerRecurrent[setId],2); 
03D8C:  CLRF   03
03D8E:  MOVF   x3F,W
03D90:  ADDLW  F8
03D92:  MOVWF  01
03D94:  MOVLW  02
03D96:  ADDWFC 03,F
03D98:  MOVFF  01,FE9
03D9C:  MOVFF  03,FEA
03DA0:  BSF    FEF.2
.................... 				}else{ 
03DA2:  BRA    3DBA
.................... 					bit_clear(timerRecurrent[setId],2); 
03DA4:  CLRF   03
03DA6:  MOVF   x3F,W
03DA8:  ADDLW  F8
03DAA:  MOVWF  01
03DAC:  MOVLW  02
03DAE:  ADDWFC 03,F
03DB0:  MOVFF  01,FE9
03DB4:  MOVFF  03,FEA
03DB8:  BCF    FEF.2
.................... 				} 
....................  
.................... 				//friday 
.................... 				if(recurrentDay[5] == '1'){ 
03DBA:  MOVLW  05
03DBC:  ADDWF  x3D,W
03DBE:  MOVWF  FE9
03DC0:  MOVLW  00
03DC2:  ADDWFC x3E,W
03DC4:  MOVWF  FEA
03DC6:  MOVF   FEF,W
03DC8:  SUBLW  31
03DCA:  BNZ   3DE4
.................... 					bit_set(timerRecurrent[setId],1); 
03DCC:  CLRF   03
03DCE:  MOVF   x3F,W
03DD0:  ADDLW  F8
03DD2:  MOVWF  01
03DD4:  MOVLW  02
03DD6:  ADDWFC 03,F
03DD8:  MOVFF  01,FE9
03DDC:  MOVFF  03,FEA
03DE0:  BSF    FEF.1
.................... 				}else{ 
03DE2:  BRA    3DFA
.................... 					bit_clear(timerRecurrent[setId],1); 
03DE4:  CLRF   03
03DE6:  MOVF   x3F,W
03DE8:  ADDLW  F8
03DEA:  MOVWF  01
03DEC:  MOVLW  02
03DEE:  ADDWFC 03,F
03DF0:  MOVFF  01,FE9
03DF4:  MOVFF  03,FEA
03DF8:  BCF    FEF.1
.................... 				} 
....................  
.................... 				//saturday 
.................... 				if(recurrentDay[6] == '1'){ 
03DFA:  MOVLW  06
03DFC:  ADDWF  x3D,W
03DFE:  MOVWF  FE9
03E00:  MOVLW  00
03E02:  ADDWFC x3E,W
03E04:  MOVWF  FEA
03E06:  MOVF   FEF,W
03E08:  SUBLW  31
03E0A:  BNZ   3E24
.................... 					bit_set(timerRecurrent[setId],0); 
03E0C:  CLRF   03
03E0E:  MOVF   x3F,W
03E10:  ADDLW  F8
03E12:  MOVWF  01
03E14:  MOVLW  02
03E16:  ADDWFC 03,F
03E18:  MOVFF  01,FE9
03E1C:  MOVFF  03,FEA
03E20:  BSF    FEF.0
.................... 				}else{ 
03E22:  BRA    3E3A
.................... 					bit_clear(timerRecurrent[setId],0); 
03E24:  CLRF   03
03E26:  MOVF   x3F,W
03E28:  ADDLW  F8
03E2A:  MOVWF  01
03E2C:  MOVLW  02
03E2E:  ADDWFC 03,F
03E30:  MOVFF  01,FE9
03E34:  MOVFF  03,FEA
03E38:  BCF    FEF.0
.................... 				} 
.................... 			 
.................... 			}else{ 
03E3A:  BRA    3E4C
.................... 				timerRecurrent[setId] = 0; 
03E3C:  CLRF   03
03E3E:  MOVF   x3F,W
03E40:  ADDLW  F8
03E42:  MOVWF  FE9
03E44:  MOVLW  02
03E46:  ADDWFC 03,W
03E48:  MOVWF  FEA
03E4A:  CLRF   FEF
.................... 			} 
.................... 			 
.................... 			write_eeprom (timerEnableEEPROM[setId], timerEnable[setId]); 
03E4C:  CLRF   03
03E4E:  MOVF   x3F,W
03E50:  ADDLW  DC
03E52:  MOVWF  FE9
03E54:  MOVLW  00
03E56:  ADDWFC 03,W
03E58:  MOVWF  FEA
03E5A:  MOVFF  FEF,646
03E5E:  CLRF   03
03E60:  MOVF   x3F,W
03E62:  ADDLW  65
03E64:  MOVWF  FE9
03E66:  MOVLW  02
03E68:  ADDWFC 03,W
03E6A:  MOVWF  FEA
03E6C:  MOVFF  FEF,647
03E70:  MOVF   FF2,W
03E72:  MOVWF  00
03E74:  BCF    FF2.7
03E76:  CLRF   FAA
03E78:  MOVFF  646,FA9
03E7C:  MOVFF  647,FA8
03E80:  BCF    FA6.6
03E82:  BCF    FA6.7
03E84:  BSF    FA6.2
03E86:  MOVLB  F
03E88:  MOVLW  55
03E8A:  MOVWF  FA7
03E8C:  MOVLW  AA
03E8E:  MOVWF  FA7
03E90:  BSF    FA6.1
03E92:  BTFSC  FA6.1
03E94:  BRA    3E92
03E96:  BCF    FA6.2
03E98:  MOVF   00,W
03E9A:  IORWF  FF2,F
.................... 			write_eeprom (timerSwitchNumberEEPROM[setId], timerSwitchNumber[setId]); 
03E9C:  CLRF   03
03E9E:  MOVLB  6
03EA0:  MOVF   x3F,W
03EA2:  ADDLW  F0
03EA4:  MOVWF  FE9
03EA6:  MOVLW  00
03EA8:  ADDWFC 03,W
03EAA:  MOVWF  FEA
03EAC:  MOVFF  FEF,646
03EB0:  CLRF   03
03EB2:  MOVF   x3F,W
03EB4:  ADDLW  7A
03EB6:  MOVWF  FE9
03EB8:  MOVLW  02
03EBA:  ADDWFC 03,W
03EBC:  MOVWF  FEA
03EBE:  MOVFF  FEF,647
03EC2:  MOVF   FF2,W
03EC4:  MOVWF  00
03EC6:  BCF    FF2.7
03EC8:  CLRF   FAA
03ECA:  MOVFF  646,FA9
03ECE:  MOVFF  647,FA8
03ED2:  BCF    FA6.6
03ED4:  BCF    FA6.7
03ED6:  BSF    FA6.2
03ED8:  MOVLB  F
03EDA:  MOVLW  55
03EDC:  MOVWF  FA7
03EDE:  MOVLW  AA
03EE0:  MOVWF  FA7
03EE2:  BSF    FA6.1
03EE4:  BTFSC  FA6.1
03EE6:  BRA    3EE4
03EE8:  BCF    FA6.2
03EEA:  MOVF   00,W
03EEC:  IORWF  FF2,F
.................... 			write_eeprom (timerControlModeEEPROM[setId], timerControlMode[setId]); 
03EEE:  CLRF   03
03EF0:  MOVLB  6
03EF2:  MOVF   x3F,W
03EF4:  ADDLW  18
03EF6:  MOVWF  FE9
03EF8:  MOVLW  01
03EFA:  ADDWFC 03,W
03EFC:  MOVWF  FEA
03EFE:  MOVFF  FEF,646
03F02:  CLRF   03
03F04:  MOVF   x3F,W
03F06:  ADDLW  A4
03F08:  MOVWF  FE9
03F0A:  MOVLW  02
03F0C:  ADDWFC 03,W
03F0E:  MOVWF  FEA
03F10:  MOVFF  FEF,647
03F14:  MOVF   FF2,W
03F16:  MOVWF  00
03F18:  BCF    FF2.7
03F1A:  CLRF   FAA
03F1C:  MOVFF  646,FA9
03F20:  MOVFF  647,FA8
03F24:  BCF    FA6.6
03F26:  BCF    FA6.7
03F28:  BSF    FA6.2
03F2A:  MOVLB  F
03F2C:  MOVLW  55
03F2E:  MOVWF  FA7
03F30:  MOVLW  AA
03F32:  MOVWF  FA7
03F34:  BSF    FA6.1
03F36:  BTFSC  FA6.1
03F38:  BRA    3F36
03F3A:  BCF    FA6.2
03F3C:  MOVF   00,W
03F3E:  IORWF  FF2,F
.................... //			write_eeprom (timerSecondDurationEEPROM[setId], timerSecondDuration[setId]); 
.................... //			write_eeprom (timerMonthEEPROM[setId], timerMonth[setId]); 
.................... //			write_eeprom (timerDateEEPROM[setId], timerDate[setId]); 
.................... 			write_eeprom (timerHourEEPROM[setId], timerHour[setId]); 
03F40:  CLRF   03
03F42:  MOVLB  6
03F44:  MOVF   x3F,W
03F46:  ADDLW  2C
03F48:  MOVWF  FE9
03F4A:  MOVLW  01
03F4C:  ADDWFC 03,W
03F4E:  MOVWF  FEA
03F50:  MOVFF  FEF,646
03F54:  CLRF   03
03F56:  MOVF   x3F,W
03F58:  ADDLW  B9
03F5A:  MOVWF  FE9
03F5C:  MOVLW  02
03F5E:  ADDWFC 03,W
03F60:  MOVWF  FEA
03F62:  MOVFF  FEF,647
03F66:  MOVF   FF2,W
03F68:  MOVWF  00
03F6A:  BCF    FF2.7
03F6C:  CLRF   FAA
03F6E:  MOVFF  646,FA9
03F72:  MOVFF  647,FA8
03F76:  BCF    FA6.6
03F78:  BCF    FA6.7
03F7A:  BSF    FA6.2
03F7C:  MOVLB  F
03F7E:  MOVLW  55
03F80:  MOVWF  FA7
03F82:  MOVLW  AA
03F84:  MOVWF  FA7
03F86:  BSF    FA6.1
03F88:  BTFSC  FA6.1
03F8A:  BRA    3F88
03F8C:  BCF    FA6.2
03F8E:  MOVF   00,W
03F90:  IORWF  FF2,F
.................... 			write_eeprom (timerMinuteEEPROM[setId], timerMinute[setId]); 
03F92:  CLRF   03
03F94:  MOVLB  6
03F96:  MOVF   x3F,W
03F98:  ADDLW  40
03F9A:  MOVWF  FE9
03F9C:  MOVLW  01
03F9E:  ADDWFC 03,W
03FA0:  MOVWF  FEA
03FA2:  MOVFF  FEF,646
03FA6:  CLRF   03
03FA8:  MOVF   x3F,W
03FAA:  ADDLW  CE
03FAC:  MOVWF  FE9
03FAE:  MOVLW  02
03FB0:  ADDWFC 03,W
03FB2:  MOVWF  FEA
03FB4:  MOVFF  FEF,647
03FB8:  MOVF   FF2,W
03FBA:  MOVWF  00
03FBC:  BCF    FF2.7
03FBE:  CLRF   FAA
03FC0:  MOVFF  646,FA9
03FC4:  MOVFF  647,FA8
03FC8:  BCF    FA6.6
03FCA:  BCF    FA6.7
03FCC:  BSF    FA6.2
03FCE:  MOVLB  F
03FD0:  MOVLW  55
03FD2:  MOVWF  FA7
03FD4:  MOVLW  AA
03FD6:  MOVWF  FA7
03FD8:  BSF    FA6.1
03FDA:  BTFSC  FA6.1
03FDC:  BRA    3FDA
03FDE:  BCF    FA6.2
03FE0:  MOVF   00,W
03FE2:  IORWF  FF2,F
.................... 			write_eeprom (timerRecurrentEEPROM[setId], timerRecurrent[setId]); 
03FE4:  CLRF   03
03FE6:  MOVLB  6
03FE8:  MOVF   x3F,W
03FEA:  ADDLW  54
03FEC:  MOVWF  FE9
03FEE:  MOVLW  01
03FF0:  ADDWFC 03,W
03FF2:  MOVWF  FEA
03FF4:  MOVFF  FEF,646
03FF8:  CLRF   03
03FFA:  MOVF   x3F,W
03FFC:  ADDLW  F8
03FFE:  MOVWF  FE9
04000:  MOVLW  02
04002:  ADDWFC 03,W
04004:  MOVWF  FEA
04006:  MOVFF  FEF,647
0400A:  MOVF   FF2,W
0400C:  MOVWF  00
0400E:  BCF    FF2.7
04010:  CLRF   FAA
04012:  MOVFF  646,FA9
04016:  MOVFF  647,FA8
0401A:  BCF    FA6.6
0401C:  BCF    FA6.7
0401E:  BSF    FA6.2
04020:  MOVLB  F
04022:  MOVLW  55
04024:  MOVWF  FA7
04026:  MOVLW  AA
04028:  MOVWF  FA7
0402A:  BSF    FA6.1
0402C:  BTFSC  FA6.1
0402E:  BRA    402C
04030:  BCF    FA6.2
04032:  MOVF   00,W
04034:  IORWF  FF2,F
....................  
.................... 			delay_ms(200); 
04036:  MOVLW  C8
04038:  MOVLB  6
0403A:  MOVWF  x4B
0403C:  MOVLB  0
0403E:  CALL   1062
....................  
.................... 			lastTrigDate[setId] = 0; 
04042:  BCF    FD8.0
04044:  MOVLB  6
04046:  RLCF   x3F,W
04048:  CLRF   03
0404A:  ADDLW  63
0404C:  MOVWF  FE9
0404E:  MOVLW  00
04050:  ADDWFC 03,W
04052:  MOVWF  FEA
04054:  CLRF   FEC
04056:  MOVF   FED,F
04058:  CLRF   FEF
....................  
.................... 			ptr = strchr (activeTimerSwitch,  setId+1); 
0405A:  MOVLW  01
0405C:  ADDWF  x3F,W
0405E:  MOVWF  x46
04060:  MOVLW  01
04062:  MOVWF  x48
04064:  MOVLW  68
04066:  MOVWF  x47
04068:  MOVFF  646,649
0406C:  MOVLB  0
0406E:  CALL   1A3A
04072:  MOVFF  02,641
04076:  MOVFF  01,640
.................... 			if(ptr == 0){ 
0407A:  MOVLB  6
0407C:  MOVF   x40,F
0407E:  BNZ   40BC
04080:  MOVF   x41,F
04082:  BNZ   40BC
.................... 				ptr = activeTimerSwitch + strlen(activeTimerSwitch); 
04084:  MOVLW  01
04086:  MOVWF  x4F
04088:  MOVLW  68
0408A:  MOVWF  x4E
0408C:  MOVLB  0
0408E:  CALL   1B88
04092:  MOVF   01,W
04094:  ADDLW  68
04096:  MOVLB  6
04098:  MOVWF  x40
0409A:  MOVLW  01
0409C:  ADDWFC 02,W
0409E:  MOVWF  x41
.................... 				ptr[0] = setId+1; 
040A0:  MOVFF  640,FE9
040A4:  MOVFF  641,FEA
040A8:  MOVLW  01
040AA:  ADDWF  x3F,W
040AC:  MOVWF  FEF
.................... 				ptr[1] = 0; 
040AE:  MOVLW  01
040B0:  ADDWF  x40,W
040B2:  MOVWF  FE9
040B4:  MOVLW  00
040B6:  ADDWFC x41,W
040B8:  MOVWF  FEA
040BA:  CLRF   FEF
.................... 			} 
....................  
.................... 			//fprintf(ESP8266,"$ACTIVE TIMER ADDED id: %u\nSwitch Number: %u*", ptr[0], switchNumber); 
.................... 			ptr = NULL; 
040BC:  CLRF   x41
040BE:  CLRF   x40
.................... 			 
.................... 	//$MQTMSETR;id;1;T;20;M;d;H;m;1;1111111;success;uuid* 
....................  
.................... 	        fprintf(ESP8266,"%sR;%u;%u;%u;%c;%u;%u;%u;%s;1;%s*", command, setId, timerEnable[setId], requestSwitchNumber, switchControlMode, hourSet, minuteSet, recurrent, recurrentDay, uuid); 
040C0:  CLRF   03
040C2:  MOVF   x3F,W
040C4:  ADDLW  65
040C6:  MOVWF  FE9
040C8:  MOVLW  02
040CA:  ADDWFC 03,W
040CC:  MOVWF  FEA
040CE:  MOVFF  FEF,646
040D2:  MOVFF  629,FEA
040D6:  MOVFF  628,FE9
040DA:  CLRF   19
040DC:  BTFSC  FF2.7
040DE:  BSF    19.7
040E0:  BCF    FF2.7
040E2:  MOVLB  0
040E4:  CALL   0EAE
040E8:  BTFSC  19.7
040EA:  BSF    FF2.7
040EC:  MOVLW  52
040EE:  BTFSS  FA4.4
040F0:  BRA    40EE
040F2:  MOVWF  F73
040F4:  MOVLW  3B
040F6:  BTFSS  FA4.4
040F8:  BRA    40F6
040FA:  MOVWF  F73
040FC:  CLRF   19
040FE:  BTFSC  FF2.7
04100:  BSF    19.7
04102:  BCF    FF2.7
04104:  MOVFF  63F,670
04108:  MOVLW  1B
0410A:  MOVLB  6
0410C:  MOVWF  x71
0410E:  MOVLB  0
04110:  CALL   0E30
04114:  BTFSC  19.7
04116:  BSF    FF2.7
04118:  MOVLW  3B
0411A:  BTFSS  FA4.4
0411C:  BRA    411A
0411E:  MOVWF  F73
04120:  CLRF   19
04122:  BTFSC  FF2.7
04124:  BSF    19.7
04126:  BCF    FF2.7
04128:  MOVFF  646,670
0412C:  MOVLW  1B
0412E:  MOVLB  6
04130:  MOVWF  x71
04132:  MOVLB  0
04134:  CALL   0E30
04138:  BTFSC  19.7
0413A:  BSF    FF2.7
0413C:  MOVLW  3B
0413E:  BTFSS  FA4.4
04140:  BRA    413E
04142:  MOVWF  F73
04144:  CLRF   19
04146:  BTFSC  FF2.7
04148:  BSF    19.7
0414A:  BCF    FF2.7
0414C:  MOVFF  62B,670
04150:  MOVLW  1B
04152:  MOVLB  6
04154:  MOVWF  x71
04156:  MOVLB  0
04158:  CALL   0E30
0415C:  BTFSC  19.7
0415E:  BSF    FF2.7
04160:  MOVLW  3B
04162:  BTFSS  FA4.4
04164:  BRA    4162
04166:  MOVWF  F73
04168:  MOVLB  6
0416A:  MOVF   x2D,W
0416C:  BTFSS  FA4.4
0416E:  BRA    416C
04170:  MOVWF  F73
04172:  MOVLW  3B
04174:  BTFSS  FA4.4
04176:  BRA    4174
04178:  MOVWF  F73
0417A:  CLRF   19
0417C:  BTFSC  FF2.7
0417E:  BSF    19.7
04180:  BCF    FF2.7
04182:  MOVFF  633,670
04186:  MOVLW  1B
04188:  MOVWF  x71
0418A:  MOVLB  0
0418C:  CALL   0E30
04190:  BTFSC  19.7
04192:  BSF    FF2.7
04194:  MOVLW  3B
04196:  BTFSS  FA4.4
04198:  BRA    4196
0419A:  MOVWF  F73
0419C:  CLRF   19
0419E:  BTFSC  FF2.7
041A0:  BSF    19.7
041A2:  BCF    FF2.7
041A4:  MOVFF  634,670
041A8:  MOVLW  1B
041AA:  MOVLB  6
041AC:  MOVWF  x71
041AE:  MOVLB  0
041B0:  CALL   0E30
041B4:  BTFSC  19.7
041B6:  BSF    FF2.7
041B8:  MOVLW  3B
041BA:  BTFSS  FA4.4
041BC:  BRA    41BA
041BE:  MOVWF  F73
041C0:  CLRF   19
041C2:  BTFSC  FF2.7
041C4:  BSF    19.7
041C6:  BCF    FF2.7
041C8:  MOVFF  635,670
041CC:  MOVLW  1B
041CE:  MOVLB  6
041D0:  MOVWF  x71
041D2:  MOVLB  0
041D4:  CALL   0E30
041D8:  BTFSC  19.7
041DA:  BSF    FF2.7
041DC:  MOVLW  3B
041DE:  BTFSS  FA4.4
041E0:  BRA    41DE
041E2:  MOVWF  F73
041E4:  MOVFF  63E,FEA
041E8:  MOVFF  63D,FE9
041EC:  CLRF   19
041EE:  BTFSC  FF2.7
041F0:  BSF    19.7
041F2:  BCF    FF2.7
041F4:  CALL   0EAE
041F8:  BTFSC  19.7
041FA:  BSF    FF2.7
041FC:  MOVLW  A1
041FE:  MOVWF  FF6
04200:  MOVLW  0C
04202:  MOVWF  FF7
04204:  CLRF   19
04206:  BTFSC  FF2.7
04208:  BSF    19.7
0420A:  BCF    FF2.7
0420C:  MOVLW  03
0420E:  MOVLB  6
04210:  MOVWF  x70
04212:  MOVLB  0
04214:  CALL   0E06
04218:  BTFSC  19.7
0421A:  BSF    FF2.7
0421C:  MOVFF  645,FEA
04220:  MOVFF  644,FE9
04224:  CLRF   19
04226:  BTFSC  FF2.7
04228:  BSF    19.7
0422A:  BCF    FF2.7
0422C:  CALL   0EAE
04230:  BTFSC  19.7
04232:  BSF    FF2.7
04234:  MOVLW  2A
04236:  BTFSS  FA4.4
04238:  BRA    4236
0423A:  MOVWF  F73
.................... 			 
.................... 	 
.................... 			ClearESP8266_Receive(); 
0423C:  CALL   24DC
.................... 			return; 
04240:  GOTO   4A6E
.................... 	 
.................... 		} 
....................  
....................  
.................... 		//$MQTMCLR;id;uuid* 
.................... 		//id=99 for new timer 
.................... 		if(strcmp(command, commandClearTimer) == 0){ 
04244:  MOVFF  629,647
04248:  MOVFF  628,646
0424C:  MOVFF  375,649
04250:  MOVFF  374,648
04254:  CALL   1C7C
04258:  MOVF   01,F
0425A:  BTFSS  FD8.2
0425C:  BRA    442A
.................... 			setId = atoi(strtok(0,delimeter)); 
0425E:  MOVLB  6
04260:  CLRF   x47
04262:  CLRF   x46
04264:  MOVLW  06
04266:  MOVWF  x49
04268:  MOVLW  26
0426A:  MOVWF  x48
0426C:  MOVLB  0
0426E:  CALL   1BC4
04272:  MOVFF  02,647
04276:  MOVFF  01,646
0427A:  MOVFF  02,649
0427E:  MOVFF  01,648
04282:  CALL   1D44
04286:  MOVFF  01,63F
.................... 			uuid = strtok(0,delimeter); 
0428A:  MOVLB  6
0428C:  CLRF   x47
0428E:  CLRF   x46
04290:  MOVLW  06
04292:  MOVWF  x49
04294:  MOVLW  26
04296:  MOVWF  x48
04298:  MOVLB  0
0429A:  CALL   1BC4
0429E:  MOVFF  02,645
042A2:  MOVFF  01,644
....................  
....................  
.................... 			ptr = strchr (activeTimerSwitch,  setId+1); 
042A6:  MOVLW  01
042A8:  MOVLB  6
042AA:  ADDWF  x3F,W
042AC:  MOVWF  x46
042AE:  MOVLW  01
042B0:  MOVWF  x48
042B2:  MOVLW  68
042B4:  MOVWF  x47
042B6:  MOVFF  646,649
042BA:  MOVLB  0
042BC:  CALL   1A3A
042C0:  MOVFF  02,641
042C4:  MOVFF  01,640
.................... 			if(ptr == 0){ 
042C8:  MOVLB  6
042CA:  MOVF   x40,F
042CC:  BNZ   4360
042CE:  MOVF   x41,F
042D0:  BNZ   4360
.................... 				fprintf(ESP8266,"%sR;%u;0;%s*", command, setId, uuid); 
042D2:  MOVFF  629,FEA
042D6:  MOVFF  628,FE9
042DA:  CLRF   19
042DC:  BTFSC  FF2.7
042DE:  BSF    19.7
042E0:  BCF    FF2.7
042E2:  MOVLB  0
042E4:  CALL   0EAE
042E8:  BTFSC  19.7
042EA:  BSF    FF2.7
042EC:  MOVLW  52
042EE:  BTFSS  FA4.4
042F0:  BRA    42EE
042F2:  MOVWF  F73
042F4:  MOVLW  3B
042F6:  BTFSS  FA4.4
042F8:  BRA    42F6
042FA:  MOVWF  F73
042FC:  CLRF   19
042FE:  BTFSC  FF2.7
04300:  BSF    19.7
04302:  BCF    FF2.7
04304:  MOVFF  63F,670
04308:  MOVLW  1B
0430A:  MOVLB  6
0430C:  MOVWF  x71
0430E:  MOVLB  0
04310:  CALL   0E30
04314:  BTFSC  19.7
04316:  BSF    FF2.7
04318:  MOVLW  AE
0431A:  MOVWF  FF6
0431C:  MOVLW  0C
0431E:  MOVWF  FF7
04320:  CLRF   19
04322:  BTFSC  FF2.7
04324:  BSF    19.7
04326:  BCF    FF2.7
04328:  MOVLW  03
0432A:  MOVLB  6
0432C:  MOVWF  x70
0432E:  MOVLB  0
04330:  CALL   0E06
04334:  BTFSC  19.7
04336:  BSF    FF2.7
04338:  MOVFF  645,FEA
0433C:  MOVFF  644,FE9
04340:  CLRF   19
04342:  BTFSC  FF2.7
04344:  BSF    19.7
04346:  BCF    FF2.7
04348:  CALL   0EAE
0434C:  BTFSC  19.7
0434E:  BSF    FF2.7
04350:  MOVLW  2A
04352:  BTFSS  FA4.4
04354:  BRA    4352
04356:  MOVWF  F73
.................... 				ClearESP8266_Receive(); 
04358:  CALL   24DC
.................... 				return; 
0435C:  BRA    4A6E
0435E:  MOVLB  6
.................... 			} 
.................... 			while(ptr[0] != 0){ 
04360:  MOVFF  640,FE9
04364:  MOVFF  641,FEA
04368:  MOVF   FEF,F
0436A:  BZ    4390
.................... 				ptr[0] = ptr[1]; 
0436C:  MOVLW  01
0436E:  ADDWF  x40,W
04370:  MOVWF  FE9
04372:  MOVLW  00
04374:  ADDWFC x41,W
04376:  MOVWF  FEA
04378:  MOVFF  FEF,648
0437C:  MOVFF  641,FEA
04380:  MOVFF  640,FE9
04384:  MOVFF  648,FEF
.................... 				ptr++; 
04388:  INCF   x40,F
0438A:  BTFSC  FD8.2
0438C:  INCF   x41,F
0438E:  BRA    4360
.................... 			} 
.................... 			ptr[0] = 0; 
04390:  MOVFF  640,FE9
04394:  MOVFF  641,FEA
04398:  CLRF   FEF
.................... 			ptr = NULL; 
0439A:  CLRF   x41
0439C:  CLRF   x40
.................... 			 
.................... 			fprintf(ESP8266,"%sR;%u;1;%s*", command, setId, uuid); 
0439E:  MOVFF  629,FEA
043A2:  MOVFF  628,FE9
043A6:  CLRF   19
043A8:  BTFSC  FF2.7
043AA:  BSF    19.7
043AC:  BCF    FF2.7
043AE:  MOVLB  0
043B0:  CALL   0EAE
043B4:  BTFSC  19.7
043B6:  BSF    FF2.7
043B8:  MOVLW  52
043BA:  BTFSS  FA4.4
043BC:  BRA    43BA
043BE:  MOVWF  F73
043C0:  MOVLW  3B
043C2:  BTFSS  FA4.4
043C4:  BRA    43C2
043C6:  MOVWF  F73
043C8:  CLRF   19
043CA:  BTFSC  FF2.7
043CC:  BSF    19.7
043CE:  BCF    FF2.7
043D0:  MOVFF  63F,670
043D4:  MOVLW  1B
043D6:  MOVLB  6
043D8:  MOVWF  x71
043DA:  MOVLB  0
043DC:  CALL   0E30
043E0:  BTFSC  19.7
043E2:  BSF    FF2.7
043E4:  MOVLW  BC
043E6:  MOVWF  FF6
043E8:  MOVLW  0C
043EA:  MOVWF  FF7
043EC:  CLRF   19
043EE:  BTFSC  FF2.7
043F0:  BSF    19.7
043F2:  BCF    FF2.7
043F4:  MOVLW  03
043F6:  MOVLB  6
043F8:  MOVWF  x70
043FA:  MOVLB  0
043FC:  CALL   0E06
04400:  BTFSC  19.7
04402:  BSF    FF2.7
04404:  MOVFF  645,FEA
04408:  MOVFF  644,FE9
0440C:  CLRF   19
0440E:  BTFSC  FF2.7
04410:  BSF    19.7
04412:  BCF    FF2.7
04414:  CALL   0EAE
04418:  BTFSC  19.7
0441A:  BSF    FF2.7
0441C:  MOVLW  2A
0441E:  BTFSS  FA4.4
04420:  BRA    441E
04422:  MOVWF  F73
.................... 			ClearESP8266_Receive(); 
04424:  CALL   24DC
.................... 			return; 
04428:  BRA    4A6E
.................... 			 
.................... 		} 
....................  
.................... 		//$MQTMSTATUS;id;uuid* 
.................... 		//id=99 for new timer 
.................... 		if(strcmp(command, commandReadTimer) == 0){ 
0442A:  MOVFF  629,647
0442E:  MOVFF  628,646
04432:  MOVFF  380,649
04436:  MOVFF  37F,648
0443A:  CALL   1C7C
0443E:  MOVF   01,F
04440:  BTFSS  FD8.2
04442:  BRA    4706
.................... 			setId = atoi(strtok(0,delimeter)); 
04444:  MOVLB  6
04446:  CLRF   x47
04448:  CLRF   x46
0444A:  MOVLW  06
0444C:  MOVWF  x49
0444E:  MOVLW  26
04450:  MOVWF  x48
04452:  MOVLB  0
04454:  CALL   1BC4
04458:  MOVFF  02,647
0445C:  MOVFF  01,646
04460:  MOVFF  02,649
04464:  MOVFF  01,648
04468:  CALL   1D44
0446C:  MOVFF  01,63F
.................... 			uuid = strtok(0,delimeter); 
04470:  MOVLB  6
04472:  CLRF   x47
04474:  CLRF   x46
04476:  MOVLW  06
04478:  MOVWF  x49
0447A:  MOVLW  26
0447C:  MOVWF  x48
0447E:  MOVLB  0
04480:  CALL   1BC4
04484:  MOVFF  02,645
04488:  MOVFF  01,644
.................... 			 
.................... 			recurrent = bit_test(timerRecurrent[setId], 7); 
0448C:  CLRF   03
0448E:  MOVLB  6
04490:  MOVF   x3F,W
04492:  ADDLW  F8
04494:  MOVWF  FE9
04496:  MOVLW  02
04498:  ADDWFC 03,W
0449A:  MOVWF  FEA
0449C:  MOVFF  FEF,646
044A0:  CLRF   x35
044A2:  BTFSC  x46.7
044A4:  INCF   x35,F
.................... 			itoa(timerRecurrent[setId],2, recurrentDay); 
044A6:  CLRF   03
044A8:  MOVF   x3F,W
044AA:  ADDLW  F8
044AC:  MOVWF  FE9
044AE:  MOVLW  02
044B0:  ADDWFC 03,W
044B2:  MOVWF  FEA
044B4:  MOVFF  FEF,647
044B8:  CLRF   x4A
044BA:  CLRF   x49
044BC:  CLRF   x48
044BE:  MOVLW  02
044C0:  MOVWF  x4B
044C2:  MOVFF  63E,64D
044C6:  MOVFF  63D,64C
044CA:  MOVLB  0
044CC:  CALL   2634
.................... 			ptr = recurrentDay + 1; 
044D0:  MOVLW  01
044D2:  MOVLB  6
044D4:  ADDWF  x3D,W
044D6:  MOVWF  x40
044D8:  MOVLW  00
044DA:  ADDWFC x3E,W
044DC:  MOVWF  x41
.................... 			//itoa(x,10, string); 
....................  
....................  
.................... 			if(timerDeviceType[setId] == INTERNAL){ 
044DE:  CLRF   03
044E0:  MOVF   x3F,W
044E2:  ADDLW  8F
044E4:  MOVWF  FE9
044E6:  MOVLW  02
044E8:  ADDWFC 03,W
044EA:  MOVWF  FEA
044EC:  MOVF   FEF,W
044EE:  SUBLW  49
044F0:  BNZ   4506
.................... 				switchNumber = timerSwitchNumber[setId]; 
044F2:  CLRF   03
044F4:  MOVF   x3F,W
044F6:  ADDLW  7A
044F8:  MOVWF  FE9
044FA:  MOVLW  02
044FC:  ADDWFC 03,W
044FE:  MOVWF  FEA
04500:  MOVFF  FEF,62A
.................... 			 
.................... 			}else if(timerDeviceType[setId] == WIRELESS){ 
04504:  BRA    4546
04506:  CLRF   03
04508:  MOVF   x3F,W
0450A:  ADDLW  8F
0450C:  MOVWF  FE9
0450E:  MOVLW  02
04510:  ADDWFC 03,W
04512:  MOVWF  FEA
04514:  MOVF   FEF,W
04516:  SUBLW  57
04518:  BNZ   4530
.................... 				switchNumber = timerSwitchNumber[setId] + sizeof(internalSwitchStatus); 
0451A:  CLRF   03
0451C:  MOVF   x3F,W
0451E:  ADDLW  7A
04520:  MOVWF  FE9
04522:  MOVLW  02
04524:  ADDWFC 03,W
04526:  MOVWF  FEA
04528:  MOVLW  0A
0452A:  ADDWF  FEF,W
0452C:  MOVWF  x2A
.................... 				 
.................... 			}else{ 
0452E:  BRA    4546
.................... 				switchNumber = timerSwitchNumber[setId] + sizeof(internalSwitchStatus) + sizeof(wirelessSwitchStatus); 
04530:  CLRF   03
04532:  MOVF   x3F,W
04534:  ADDLW  7A
04536:  MOVWF  FE9
04538:  MOVLW  02
0453A:  ADDWFC 03,W
0453C:  MOVWF  FEA
0453E:  MOVLW  0A
04540:  ADDWF  FEF,W
04542:  ADDLW  0A
04544:  MOVWF  x2A
.................... 			} 
.................... 	 
.................... 	        fprintf(ESP8266,"%sR;%u;%u;%u;%c;%u;%u;%u;%s;1;%s*", command, setId ,timerEnable[setId], switchNumber, timerControlMode[setId], timerHour[setId], timerMinute[setId], recurrent, ptr, uuid); 
04546:  CLRF   03
04548:  MOVF   x3F,W
0454A:  ADDLW  65
0454C:  MOVWF  FE9
0454E:  MOVLW  02
04550:  ADDWFC 03,W
04552:  MOVWF  FEA
04554:  MOVFF  FEF,646
04558:  CLRF   03
0455A:  MOVF   x3F,W
0455C:  ADDLW  A4
0455E:  MOVWF  FE9
04560:  MOVLW  02
04562:  ADDWFC 03,W
04564:  MOVWF  FEA
04566:  MOVFF  FEF,647
0456A:  CLRF   03
0456C:  MOVF   x3F,W
0456E:  ADDLW  B9
04570:  MOVWF  FE9
04572:  MOVLW  02
04574:  ADDWFC 03,W
04576:  MOVWF  FEA
04578:  MOVFF  FEF,648
0457C:  CLRF   03
0457E:  MOVF   x3F,W
04580:  ADDLW  CE
04582:  MOVWF  FE9
04584:  MOVLW  02
04586:  ADDWFC 03,W
04588:  MOVWF  FEA
0458A:  MOVFF  FEF,649
0458E:  MOVFF  629,FEA
04592:  MOVFF  628,FE9
04596:  CLRF   19
04598:  BTFSC  FF2.7
0459A:  BSF    19.7
0459C:  BCF    FF2.7
0459E:  MOVLB  0
045A0:  CALL   0EAE
045A4:  BTFSC  19.7
045A6:  BSF    FF2.7
045A8:  MOVLW  52
045AA:  BTFSS  FA4.4
045AC:  BRA    45AA
045AE:  MOVWF  F73
045B0:  MOVLW  3B
045B2:  BTFSS  FA4.4
045B4:  BRA    45B2
045B6:  MOVWF  F73
045B8:  CLRF   19
045BA:  BTFSC  FF2.7
045BC:  BSF    19.7
045BE:  BCF    FF2.7
045C0:  MOVFF  63F,670
045C4:  MOVLW  1B
045C6:  MOVLB  6
045C8:  MOVWF  x71
045CA:  MOVLB  0
045CC:  CALL   0E30
045D0:  BTFSC  19.7
045D2:  BSF    FF2.7
045D4:  MOVLW  3B
045D6:  BTFSS  FA4.4
045D8:  BRA    45D6
045DA:  MOVWF  F73
045DC:  CLRF   19
045DE:  BTFSC  FF2.7
045E0:  BSF    19.7
045E2:  BCF    FF2.7
045E4:  MOVFF  646,670
045E8:  MOVLW  1B
045EA:  MOVLB  6
045EC:  MOVWF  x71
045EE:  MOVLB  0
045F0:  CALL   0E30
045F4:  BTFSC  19.7
045F6:  BSF    FF2.7
045F8:  MOVLW  3B
045FA:  BTFSS  FA4.4
045FC:  BRA    45FA
045FE:  MOVWF  F73
04600:  CLRF   19
04602:  BTFSC  FF2.7
04604:  BSF    19.7
04606:  BCF    FF2.7
04608:  MOVFF  62A,670
0460C:  MOVLW  1B
0460E:  MOVLB  6
04610:  MOVWF  x71
04612:  MOVLB  0
04614:  CALL   0E30
04618:  BTFSC  19.7
0461A:  BSF    FF2.7
0461C:  MOVLW  3B
0461E:  BTFSS  FA4.4
04620:  BRA    461E
04622:  MOVWF  F73
04624:  MOVLB  6
04626:  MOVF   x47,W
04628:  BTFSS  FA4.4
0462A:  BRA    4628
0462C:  MOVWF  F73
0462E:  MOVLW  3B
04630:  BTFSS  FA4.4
04632:  BRA    4630
04634:  MOVWF  F73
04636:  CLRF   19
04638:  BTFSC  FF2.7
0463A:  BSF    19.7
0463C:  BCF    FF2.7
0463E:  MOVFF  648,670
04642:  MOVLW  1B
04644:  MOVWF  x71
04646:  MOVLB  0
04648:  CALL   0E30
0464C:  BTFSC  19.7
0464E:  BSF    FF2.7
04650:  MOVLW  3B
04652:  BTFSS  FA4.4
04654:  BRA    4652
04656:  MOVWF  F73
04658:  CLRF   19
0465A:  BTFSC  FF2.7
0465C:  BSF    19.7
0465E:  BCF    FF2.7
04660:  MOVFF  649,670
04664:  MOVLW  1B
04666:  MOVLB  6
04668:  MOVWF  x71
0466A:  MOVLB  0
0466C:  CALL   0E30
04670:  BTFSC  19.7
04672:  BSF    FF2.7
04674:  MOVLW  3B
04676:  BTFSS  FA4.4
04678:  BRA    4676
0467A:  MOVWF  F73
0467C:  CLRF   19
0467E:  BTFSC  FF2.7
04680:  BSF    19.7
04682:  BCF    FF2.7
04684:  MOVFF  635,670
04688:  MOVLW  1B
0468A:  MOVLB  6
0468C:  MOVWF  x71
0468E:  MOVLB  0
04690:  CALL   0E30
04694:  BTFSC  19.7
04696:  BSF    FF2.7
04698:  MOVLW  3B
0469A:  BTFSS  FA4.4
0469C:  BRA    469A
0469E:  MOVWF  F73
046A0:  MOVFF  641,FEA
046A4:  MOVFF  640,FE9
046A8:  CLRF   19
046AA:  BTFSC  FF2.7
046AC:  BSF    19.7
046AE:  BCF    FF2.7
046B0:  CALL   0EAE
046B4:  BTFSC  19.7
046B6:  BSF    FF2.7
046B8:  MOVLW  DF
046BA:  MOVWF  FF6
046BC:  MOVLW  0C
046BE:  MOVWF  FF7
046C0:  CLRF   19
046C2:  BTFSC  FF2.7
046C4:  BSF    19.7
046C6:  BCF    FF2.7
046C8:  MOVLW  03
046CA:  MOVLB  6
046CC:  MOVWF  x70
046CE:  MOVLB  0
046D0:  CALL   0E06
046D4:  BTFSC  19.7
046D6:  BSF    FF2.7
046D8:  MOVFF  645,FEA
046DC:  MOVFF  644,FE9
046E0:  CLRF   19
046E2:  BTFSC  FF2.7
046E4:  BSF    19.7
046E6:  BCF    FF2.7
046E8:  CALL   0EAE
046EC:  BTFSC  19.7
046EE:  BSF    FF2.7
046F0:  MOVLW  2A
046F2:  BTFSS  FA4.4
046F4:  BRA    46F2
046F6:  MOVWF  F73
.................... 			ptr = NULL; 
046F8:  MOVLB  6
046FA:  CLRF   x41
046FC:  CLRF   x40
.................... 			ClearESP8266_Receive(); 
046FE:  MOVLB  0
04700:  CALL   24DC
.................... 			return; 
04704:  BRA    4A6E
.................... 			 
.................... 		} 
....................  
....................  
....................  
.................... 	    //=========================================================================================================================== 
.................... 		//Online Update Firmware 
.................... 		//============================================================================================================================ 
.................... 	    if(strcmp(command, commandUpdate) == 0){ 
04706:  MOVFF  629,647
0470A:  MOVFF  628,646
0470E:  MOVFF  39C,649
04712:  MOVFF  39B,648
04716:  CALL   1C7C
0471A:  MOVF   01,F
0471C:  BNZ   4796
.................... 		 
....................      		lcd_goto_xy(0,1); 
0471E:  MOVLB  6
04720:  CLRF   x46
04722:  MOVLW  01
04724:  MOVWF  x47
04726:  MOVLB  0
04728:  CALL   1302
....................      		display("Process OTA ...."); 
0472C:  MOVLW  E6
0472E:  MOVWF  FF6
04730:  MOVLW  0C
04732:  MOVWF  FF7
04734:  CALL   1438
....................  
.................... 			lcd_goto_xy(0,2); 
04738:  MOVLB  6
0473A:  CLRF   x46
0473C:  MOVLW  02
0473E:  MOVWF  x47
04740:  MOVLB  0
04742:  CALL   1302
....................      		display("Upload New F/W  "); 
04746:  MOVLW  F8
04748:  MOVWF  FF6
0474A:  MOVLW  0C
0474C:  MOVWF  FF7
0474E:  CALL   1438
....................  
.................... 			fprintf(WIFI,"Upgrade New Firmware Process\r\n"); 
04752:  MOVLW  0A
04754:  MOVWF  FF6
04756:  MOVLW  0D
04758:  MOVWF  FF7
0475A:  CALL   1458
.................... 			write_eeprom (UPGRADE_ADDRESS, 0x31);				// Set Upgrade New Firmware 
0475E:  MOVF   FF2,W
04760:  MOVWF  00
04762:  BCF    FF2.7
04764:  CLRF   FAA
04766:  SETF   FA9
04768:  MOVLW  31
0476A:  MOVWF  FA8
0476C:  BCF    FA6.6
0476E:  BCF    FA6.7
04770:  BSF    FA6.2
04772:  MOVLB  F
04774:  MOVLW  55
04776:  MOVWF  FA7
04778:  MOVLW  AA
0477A:  MOVWF  FA7
0477C:  BSF    FA6.1
0477E:  BTFSC  FA6.1
04780:  BRA    477E
04782:  BCF    FA6.2
04784:  MOVF   00,W
04786:  IORWF  FF2,F
.................... 			delay_ms(100); 
04788:  MOVLW  64
0478A:  MOVLB  6
0478C:  MOVWF  x4B
0478E:  MOVLB  0
04790:  CALL   1062
.................... 			Reset_CPU(); 
04794:  RESET
04796:  MOVLB  6
.................... 		} 
....................  
....................  
.................... 	} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //============================================================================================================================ 
.................... 	//$MQTTPSYNRTC + : ( ตัวแบ่งข้อมูล ) + วัน : เดือน : ปี : DOW* : ชั่วโมง : นาที : วินาที( ซึ่งทุกๆ ข้อมูลต้องคั่นด้วยตัวแบ่งข้อมูลทุกครั้ง ) ========================================== 
.................... 	//$MQTTPSYNRTC:23:10:2016:1:10:58:34:** 
....................  
.................... 	searchResultPtr = strstr(esp8266Ptr, commandSyncTime); 
04798:  MOVFF  30E,647
0479C:  MOVFF  30D,646
047A0:  MOVFF  3A9,649
047A4:  MOVFF  3A8,648
047A8:  MOVLB  0
047AA:  CALL   27EC
047AE:  MOVFF  02,643
047B2:  MOVFF  01,642
....................     if(searchResultPtr != NULL){ 
047B6:  MOVLB  6
047B8:  MOVF   x42,F
047BA:  BNZ   47C2
047BC:  MOVF   x43,F
047BE:  BTFSC  FD8.2
047C0:  BRA    498E
.................... 		strcpy(tempCommand, esp8266Ptr);               // copy the string to temp string 
047C2:  MOVLW  04
047C4:  MOVWF  FEA
047C6:  MOVLW  32
047C8:  MOVWF  FE9
047CA:  MOVFF  30E,FE2
047CE:  MOVFF  30D,FE1
047D2:  MOVF   FE7,F
047D4:  MOVFF  FE6,FEE
047D8:  BNZ   47D2
....................    		strcpy(delimeter,":");  
047DA:  MOVLW  06
047DC:  MOVWF  FEA
047DE:  MOVLW  26
047E0:  MOVWF  FE9
047E2:  MOVLW  00
047E4:  MOVLB  0
047E6:  CALL   04E4
047EA:  TBLRD*-
047EC:  TBLRD*+
047EE:  MOVF   FF5,W
047F0:  MOVWF  FEE
047F2:  IORLW  00
047F4:  BNZ   47EC
.................... 		ptr = strtok(tempCommand,delimeter); 
047F6:  MOVLW  04
047F8:  MOVLB  6
047FA:  MOVWF  x47
047FC:  MOVLW  32
047FE:  MOVWF  x46
04800:  MOVLW  06
04802:  MOVWF  x49
04804:  MOVLW  26
04806:  MOVWF  x48
04808:  MOVLB  0
0480A:  CALL   1BC4
0480E:  MOVFF  02,641
04812:  MOVFF  01,640
.................... 		if(ptr==0){ 
04816:  MOVLB  6
04818:  MOVF   x40,F
0481A:  BNZ   482A
0481C:  MOVF   x41,F
0481E:  BNZ   482A
.................... 			ClearESP8266_Receive(); 
04820:  MOVLB  0
04822:  CALL   24DC
.................... 			return; 
04826:  BRA    4A6E
04828:  MOVLB  6
.................... 		} 
....................  
.................... 		day = atoi(strtok(0,delimeter)); 
0482A:  CLRF   x47
0482C:  CLRF   x46
0482E:  MOVLW  06
04830:  MOVWF  x49
04832:  MOVLW  26
04834:  MOVWF  x48
04836:  MOVLB  0
04838:  CALL   1BC4
0483C:  MOVFF  02,647
04840:  MOVFF  01,646
04844:  MOVFF  02,649
04848:  MOVFF  01,648
0484C:  CALL   1D44
04850:  MOVFF  01,1E5
.................... 		mth = atoi(strtok(0,delimeter)); 
04854:  MOVLB  6
04856:  CLRF   x47
04858:  CLRF   x46
0485A:  MOVLW  06
0485C:  MOVWF  x49
0485E:  MOVLW  26
04860:  MOVWF  x48
04862:  MOVLB  0
04864:  CALL   1BC4
04868:  MOVFF  02,647
0486C:  MOVFF  01,646
04870:  MOVFF  02,649
04874:  MOVFF  01,648
04878:  CALL   1D44
0487C:  MOVFF  01,1E6
.................... 		year = atoi(strtok(0,delimeter)); 
04880:  MOVLB  6
04882:  CLRF   x47
04884:  CLRF   x46
04886:  MOVLW  06
04888:  MOVWF  x49
0488A:  MOVLW  26
0488C:  MOVWF  x48
0488E:  MOVLB  0
04890:  CALL   1BC4
04894:  MOVFF  02,647
04898:  MOVFF  01,646
0489C:  MOVFF  02,649
048A0:  MOVFF  01,648
048A4:  CALL   1D44
048A8:  MOVFF  01,1E7
.................... 		dow = atoi(strtok(0,delimeter)); 
048AC:  MOVLB  6
048AE:  CLRF   x47
048B0:  CLRF   x46
048B2:  MOVLW  06
048B4:  MOVWF  x49
048B6:  MOVLW  26
048B8:  MOVWF  x48
048BA:  MOVLB  0
048BC:  CALL   1BC4
048C0:  MOVFF  02,647
048C4:  MOVFF  01,646
048C8:  MOVFF  02,649
048CC:  MOVFF  01,648
048D0:  CALL   1D44
048D4:  MOVFF  01,1E8
.................... 		hour = atoi(strtok(0,delimeter)); 
048D8:  MOVLB  6
048DA:  CLRF   x47
048DC:  CLRF   x46
048DE:  MOVLW  06
048E0:  MOVWF  x49
048E2:  MOVLW  26
048E4:  MOVWF  x48
048E6:  MOVLB  0
048E8:  CALL   1BC4
048EC:  MOVFF  02,647
048F0:  MOVFF  01,646
048F4:  MOVFF  02,649
048F8:  MOVFF  01,648
048FC:  CALL   1D44
04900:  MOVFF  01,1E9
.................... 		min = atoi(strtok(0,delimeter)); 
04904:  MOVLB  6
04906:  CLRF   x47
04908:  CLRF   x46
0490A:  MOVLW  06
0490C:  MOVWF  x49
0490E:  MOVLW  26
04910:  MOVWF  x48
04912:  MOVLB  0
04914:  CALL   1BC4
04918:  MOVFF  02,647
0491C:  MOVFF  01,646
04920:  MOVFF  02,649
04924:  MOVFF  01,648
04928:  CALL   1D44
0492C:  MOVFF  01,1EA
.................... 		sec = atoi(strtok(0,delimeter)); 
04930:  MOVLB  6
04932:  CLRF   x47
04934:  CLRF   x46
04936:  MOVLW  06
04938:  MOVWF  x49
0493A:  MOVLW  26
0493C:  MOVWF  x48
0493E:  MOVLB  0
04940:  CALL   1BC4
04944:  MOVFF  02,647
04948:  MOVFF  01,646
0494C:  MOVFF  02,649
04950:  MOVFF  01,648
04954:  CALL   1D44
04958:  MOVFF  01,1EB
.................... 		rtc_set_datetime(day,mth,year,dow,hour,min,sec); 
0495C:  MOVFF  1E5,646
04960:  MOVFF  1E6,647
04964:  MOVFF  1E7,648
04968:  MOVFF  1E8,649
0496C:  MOVFF  1E9,64A
04970:  MOVFF  1EA,64B
04974:  MOVFF  1EB,64C
04978:  GOTO   28B8
.................... 		ptr = NULL; 
0497C:  MOVLB  6
0497E:  CLRF   x41
04980:  CLRF   x40
.................... 		ClearESP8266_Receive(); 
04982:  MOVLB  0
04984:  CALL   24DC
....................  
.................... 		UpdateRTC_flag = false; 
04988:  BCF    xC4.1
....................  
.................... 		return;	 
0498A:  BRA    4A6E
0498C:  MOVLB  6
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	//%$ACCINFO* 
.................... 	searchResultPtr = strstr(esp8266Ptr, accountInfo); 
0498E:  MOVFF  30E,647
04992:  MOVFF  30D,646
04996:  MOVFF  356,649
0499A:  MOVFF  355,648
0499E:  MOVLB  0
049A0:  CALL   27EC
049A4:  MOVFF  02,643
049A8:  MOVFF  01,642
.................... 	if(searchResultPtr != NULL){ 
049AC:  MOVLB  6
049AE:  MOVF   x42,F
049B0:  BNZ   49B6
049B2:  MOVF   x43,F
049B4:  BZ    4A68
.................... 		delay_ms(100); 
049B6:  MOVLW  64
049B8:  MOVWF  x4B
049BA:  MOVLB  0
049BC:  CALL   1062
.................... 		fprintf(ESP8266,"$ACR,%2.2f,%u,%u,*",voltage,temp,HomeLock_Flag); 
049C0:  MOVLW  00
049C2:  BTFSC  xC4.5
049C4:  MOVLW  01
049C6:  MOVLB  6
049C8:  MOVWF  x46
049CA:  MOVLW  2A
049CC:  MOVWF  FF6
049CE:  MOVLW  0D
049D0:  MOVWF  FF7
049D2:  CLRF   19
049D4:  BTFSC  FF2.7
049D6:  BSF    19.7
049D8:  BCF    FF2.7
049DA:  MOVLW  05
049DC:  MOVWF  x70
049DE:  MOVLB  0
049E0:  CALL   0E06
049E4:  BTFSC  19.7
049E6:  BSF    FF2.7
049E8:  MOVLW  89
049EA:  MOVWF  FE9
049EC:  MOVFF  D1,64A
049F0:  MOVFF  D0,649
049F4:  MOVFF  CF,648
049F8:  MOVFF  CE,647
049FC:  MOVLW  02
049FE:  MOVLB  6
04A00:  MOVWF  x4B
04A02:  MOVLB  0
04A04:  GOTO   2AAE
04A08:  MOVLW  2C
04A0A:  BTFSS  FA4.4
04A0C:  BRA    4A0A
04A0E:  MOVWF  F73
04A10:  CLRF   19
04A12:  BTFSC  FF2.7
04A14:  BSF    19.7
04A16:  BCF    FF2.7
04A18:  MOVFF  C5,670
04A1C:  MOVLW  1B
04A1E:  MOVLB  6
04A20:  MOVWF  x71
04A22:  MOVLB  0
04A24:  CALL   0E30
04A28:  BTFSC  19.7
04A2A:  BSF    FF2.7
04A2C:  MOVLW  2C
04A2E:  BTFSS  FA4.4
04A30:  BRA    4A2E
04A32:  MOVWF  F73
04A34:  CLRF   19
04A36:  BTFSC  FF2.7
04A38:  BSF    19.7
04A3A:  BCF    FF2.7
04A3C:  MOVFF  646,670
04A40:  MOVLW  1B
04A42:  MOVLB  6
04A44:  MOVWF  x71
04A46:  MOVLB  0
04A48:  CALL   0E30
04A4C:  BTFSC  19.7
04A4E:  BSF    FF2.7
04A50:  MOVLW  2C
04A52:  BTFSS  FA4.4
04A54:  BRA    4A52
04A56:  MOVWF  F73
04A58:  MOVLW  2A
04A5A:  BTFSS  FA4.4
04A5C:  BRA    4A5A
04A5E:  MOVWF  F73
.................... 		ClearESP8266_Receive(); 
04A60:  CALL   24DC
.................... 		return; 
04A64:  BRA    4A6E
04A66:  MOVLB  6
.................... 	} 
....................  
.................... 	ClearESP8266_Receive(); 
04A68:  MOVLB  0
04A6A:  CALL   24DC
04A6E:  GOTO   532C (RETURN)
.................... } 
....................  
.................... //================================================================================================================================================================== 
.................... void Last_Switch_State() 
.................... { 
.................... 			   //=================================================================== 
.................... 	disable_interrupts(GLOBAL);                 // enable global ints 
*
014DA:  BCF    FF2.6
014DC:  BCF    FF2.7
014DE:  BTFSC  FF2.7
014E0:  BRA    14DC
.................... 			 
.................... 	int timerEnableSize = sizeOf(timerEnable); 
.................... 	char *ptr; 
014E2:  MOVLW  15
014E4:  MOVLB  3
014E6:  MOVWF  x19
....................  
.................... 	//load internal switch state 
.................... 	for(int i = 0; i < sizeOf(saveInternalSwitchStatusAddress); i++){ 
014E8:  CLRF   x1C
014EA:  MOVF   x1C,W
014EC:  SUBLW  09
014EE:  BNC   15C2
.................... 		internalSwitchStatus[i] = read_eeprom (saveInternalSwitchStatusAddress[i]); 
014F0:  CLRF   03
014F2:  MOVF   x1C,W
014F4:  ADDLW  27
014F6:  MOVWF  01
014F8:  MOVLW  00
014FA:  ADDWFC 03,F
014FC:  MOVF   01,W
014FE:  MOVWF  x20
01500:  MOVFF  03,321
01504:  CLRF   03
01506:  MOVF   x1C,W
01508:  ADDLW  45
0150A:  MOVWF  FE9
0150C:  MOVLW  00
0150E:  ADDWFC 03,W
01510:  MOVWF  FEA
01512:  MOVFF  FEF,322
01516:  MOVFF  FF2,323
0151A:  BCF    FF2.7
0151C:  CLRF   FAA
0151E:  MOVFF  322,FA9
01522:  BCF    FA6.6
01524:  BCF    FA6.7
01526:  BSF    FA6.0
01528:  MOVF   FA8,W
0152A:  BTFSC  x23.7
0152C:  BSF    FF2.7
0152E:  MOVWF  x22
01530:  MOVFF  321,FEA
01534:  MOVFF  320,FE9
01538:  MOVFF  322,FEF
....................  
.................... 		if(internalSwitchStatus[i] > 1){ 
0153C:  CLRF   03
0153E:  MOVF   x1C,W
01540:  ADDLW  27
01542:  MOVWF  FE9
01544:  MOVLW  00
01546:  ADDWFC 03,W
01548:  MOVWF  FEA
0154A:  MOVF   FEF,W
0154C:  SUBLW  01
0154E:  BC    1560
.................... 			internalSwitchStatus[i] = 0; 
01550:  CLRF   03
01552:  MOVF   x1C,W
01554:  ADDLW  27
01556:  MOVWF  FE9
01558:  MOVLW  00
0155A:  ADDWFC 03,W
0155C:  MOVWF  FEA
0155E:  CLRF   FEF
.................... 		} 
....................  
.................... 		if(internalSwitchStatus[i] == 1){ 
01560:  CLRF   03
01562:  MOVF   x1C,W
01564:  ADDLW  27
01566:  MOVWF  FE9
01568:  MOVLW  00
0156A:  ADDWFC 03,W
0156C:  MOVWF  FEA
0156E:  DECFSZ FEF,W
01570:  BRA    159A
.................... 			output_high(internalSwitch[i]); 
01572:  CLRF   03
01574:  MOVF   x1C,W
01576:  ADDLW  21
01578:  MOVWF  FE9
0157A:  MOVLW  00
0157C:  ADDWFC 03,W
0157E:  MOVWF  FEA
01580:  MOVFF  FEF,647
01584:  MOVLW  01
01586:  MOVLB  6
01588:  MOVWF  x48
0158A:  MOVLW  0F
0158C:  MOVWF  x4A
0158E:  MOVLW  89
01590:  MOVWF  x49
01592:  MOVLB  0
01594:  RCALL  1498
.................... 		}else{ 
01596:  BRA    15BC
01598:  MOVLB  3
.................... 			output_low(internalSwitch[i]); 
0159A:  CLRF   03
0159C:  MOVF   x1C,W
0159E:  ADDLW  21
015A0:  MOVWF  FE9
015A2:  MOVLW  00
015A4:  ADDWFC 03,W
015A6:  MOVWF  FEA
015A8:  MOVFF  FEF,647
015AC:  MOVLB  6
015AE:  CLRF   x48
015B0:  MOVLW  0F
015B2:  MOVWF  x4A
015B4:  MOVLW  89
015B6:  MOVWF  x49
015B8:  MOVLB  0
015BA:  RCALL  1498
.................... 		} 
015BC:  MOVLB  3
015BE:  INCF   x1C,F
015C0:  BRA    14EA
.................... 	 
.................... 	} 
....................  
.................... 	//load wireless switch state 
.................... 	for(int i = 0; i < sizeOf(saveWirelessSwitchStatusAddress); i++){ 
015C2:  CLRF   x1D
015C4:  MOVF   x1D,W
015C6:  SUBLW  09
015C8:  BTFSS  FD8.0
015CA:  BRA    172E
.................... 		wirelessSwitchStatus[i] = read_eeprom (saveWirelessSwitchStatusAddress[i]); 
015CC:  CLRF   03
015CE:  MOVF   x1D,W
015D0:  ADDLW  31
015D2:  MOVWF  01
015D4:  MOVLW  00
015D6:  ADDWFC 03,F
015D8:  MOVF   01,W
015DA:  MOVWF  x20
015DC:  MOVFF  03,321
015E0:  CLRF   03
015E2:  MOVF   x1D,W
015E4:  ADDLW  4F
015E6:  MOVWF  FE9
015E8:  MOVLW  00
015EA:  ADDWFC 03,W
015EC:  MOVWF  FEA
015EE:  MOVFF  FEF,322
015F2:  MOVFF  FF2,323
015F6:  BCF    FF2.7
015F8:  CLRF   FAA
015FA:  MOVFF  322,FA9
015FE:  BCF    FA6.6
01600:  BCF    FA6.7
01602:  BSF    FA6.0
01604:  MOVF   FA8,W
01606:  BTFSC  x23.7
01608:  BSF    FF2.7
0160A:  MOVWF  x22
0160C:  MOVFF  321,FEA
01610:  MOVFF  320,FE9
01614:  MOVFF  322,FEF
....................  
.................... 		if(wirelessSwitchStatus[i] > 1){ 
01618:  CLRF   03
0161A:  MOVF   x1D,W
0161C:  ADDLW  31
0161E:  MOVWF  FE9
01620:  MOVLW  00
01622:  ADDWFC 03,W
01624:  MOVWF  FEA
01626:  MOVF   FEF,W
01628:  SUBLW  01
0162A:  BC    163C
.................... 			wirelessSwitchStatus[i] = 0; 
0162C:  CLRF   03
0162E:  MOVF   x1D,W
01630:  ADDLW  31
01632:  MOVWF  FE9
01634:  MOVLW  00
01636:  ADDWFC 03,W
01638:  MOVWF  FEA
0163A:  CLRF   FEF
.................... 		} 
....................  
.................... 		if(wirelessSwitchStatus[i] == 1){ 
0163C:  CLRF   03
0163E:  MOVF   x1D,W
01640:  ADDLW  31
01642:  MOVWF  FE9
01644:  MOVLW  00
01646:  ADDWFC 03,W
01648:  MOVWF  FEA
0164A:  DECFSZ FEF,W
0164C:  BRA    16B4
.................... 			fprintf(WIFI,"$MQSWCS;%u;N;MASTER*", i+1); 
0164E:  MOVLW  01
01650:  ADDWF  x1D,W
01652:  MOVWF  x20
01654:  MOVLW  3E
01656:  MOVWF  FF6
01658:  MOVLW  0D
0165A:  MOVWF  FF7
0165C:  CLRF   19
0165E:  BTFSC  FF2.7
01660:  BSF    19.7
01662:  BCF    FF2.7
01664:  MOVLW  08
01666:  MOVLB  6
01668:  MOVWF  x6C
0166A:  MOVLB  0
0166C:  CALL   050C
01670:  BTFSC  19.7
01672:  BSF    FF2.7
01674:  CLRF   19
01676:  BTFSC  FF2.7
01678:  BSF    19.7
0167A:  BCF    FF2.7
0167C:  MOVFF  320,66C
01680:  MOVLW  1B
01682:  MOVLB  6
01684:  MOVWF  x6D
01686:  MOVLB  0
01688:  CALL   0768
0168C:  BTFSC  19.7
0168E:  BSF    FF2.7
01690:  MOVLW  48
01692:  MOVWF  FF6
01694:  MOVLW  0D
01696:  MOVWF  FF7
01698:  CLRF   19
0169A:  BTFSC  FF2.7
0169C:  BSF    19.7
0169E:  BCF    FF2.7
016A0:  MOVLW  0A
016A2:  MOVLB  6
016A4:  MOVWF  x6C
016A6:  MOVLB  0
016A8:  CALL   050C
016AC:  BTFSC  19.7
016AE:  BSF    FF2.7
.................... 			 
.................... 		}else{ 
016B0:  BRA    1716
016B2:  MOVLB  3
.................... 			fprintf(WIFI,"$MQSWCS;%u;F;MASTER*", i+1); 
016B4:  MOVLW  01
016B6:  ADDWF  x1D,W
016B8:  MOVWF  x20
016BA:  MOVLW  54
016BC:  MOVWF  FF6
016BE:  MOVLW  0D
016C0:  MOVWF  FF7
016C2:  CLRF   19
016C4:  BTFSC  FF2.7
016C6:  BSF    19.7
016C8:  BCF    FF2.7
016CA:  MOVLW  08
016CC:  MOVLB  6
016CE:  MOVWF  x6C
016D0:  MOVLB  0
016D2:  CALL   050C
016D6:  BTFSC  19.7
016D8:  BSF    FF2.7
016DA:  CLRF   19
016DC:  BTFSC  FF2.7
016DE:  BSF    19.7
016E0:  BCF    FF2.7
016E2:  MOVFF  320,66C
016E6:  MOVLW  1B
016E8:  MOVLB  6
016EA:  MOVWF  x6D
016EC:  MOVLB  0
016EE:  CALL   0768
016F2:  BTFSC  19.7
016F4:  BSF    FF2.7
016F6:  MOVLW  5E
016F8:  MOVWF  FF6
016FA:  MOVLW  0D
016FC:  MOVWF  FF7
016FE:  CLRF   19
01700:  BTFSC  FF2.7
01702:  BSF    19.7
01704:  BCF    FF2.7
01706:  MOVLW  0A
01708:  MOVLB  6
0170A:  MOVWF  x6C
0170C:  MOVLB  0
0170E:  CALL   050C
01712:  BTFSC  19.7
01714:  BSF    FF2.7
.................... 		} 
.................... 		waitingSlaveCounter[i] = 1; 
01716:  CLRF   03
01718:  MOVLB  3
0171A:  MOVF   x1D,W
0171C:  ADDLW  8B
0171E:  MOVWF  FE9
01720:  MOVLW  00
01722:  ADDWFC 03,W
01724:  MOVWF  FEA
01726:  MOVLW  01
01728:  MOVWF  FEF
0172A:  INCF   x1D,F
0172C:  BRA    15C4
.................... 	 
.................... 	}			 
....................  
.................... 	//load livolo switch state 
.................... 	for(int i = 0; i < sizeOf(saveLivoloSwitchStatusAddress); i++){ 
0172E:  CLRF   x1E
01730:  MOVF   x1E,W
01732:  SUBLW  09
01734:  BNC   17AA
.................... 		livoloSwitchStatus[i] = read_eeprom (saveLivoloSwitchStatusAddress[i]); 
01736:  CLRF   03
01738:  MOVF   x1E,W
0173A:  ADDLW  3B
0173C:  MOVWF  01
0173E:  MOVLW  00
01740:  ADDWFC 03,F
01742:  MOVF   01,W
01744:  MOVWF  x20
01746:  MOVFF  03,321
0174A:  CLRF   03
0174C:  MOVF   x1E,W
0174E:  ADDLW  59
01750:  MOVWF  FE9
01752:  MOVLW  00
01754:  ADDWFC 03,W
01756:  MOVWF  FEA
01758:  MOVFF  FEF,322
0175C:  MOVFF  FF2,323
01760:  BCF    FF2.7
01762:  CLRF   FAA
01764:  MOVFF  322,FA9
01768:  BCF    FA6.6
0176A:  BCF    FA6.7
0176C:  BSF    FA6.0
0176E:  MOVF   FA8,W
01770:  BTFSC  x23.7
01772:  BSF    FF2.7
01774:  MOVWF  x22
01776:  MOVFF  321,FEA
0177A:  MOVFF  320,FE9
0177E:  MOVFF  322,FEF
....................  
.................... 		if(livoloSwitchStatus[i] > 1){ 
01782:  CLRF   03
01784:  MOVF   x1E,W
01786:  ADDLW  3B
01788:  MOVWF  FE9
0178A:  MOVLW  00
0178C:  ADDWFC 03,W
0178E:  MOVWF  FEA
01790:  MOVF   FEF,W
01792:  SUBLW  01
01794:  BC    17A6
.................... 			livoloSwitchStatus[i] = 0; 
01796:  CLRF   03
01798:  MOVF   x1E,W
0179A:  ADDLW  3B
0179C:  MOVWF  FE9
0179E:  MOVLW  00
017A0:  ADDWFC 03,W
017A2:  MOVWF  FEA
017A4:  CLRF   FEF
.................... 		} 
017A6:  INCF   x1E,F
017A8:  BRA    1730
....................  
.................... 	}	 
....................  
.................... 	ptr = activeTimerSwitch; 
017AA:  MOVLW  01
017AC:  MOVWF  x1B
017AE:  MOVLW  68
017B0:  MOVWF  x1A
.................... 	for(int i = 0; i < sizeof(timerEnableEEPROM); i++){ 
017B2:  CLRF   x1F
017B4:  MOVF   x1F,W
017B6:  SUBLW  13
017B8:  BTFSS  FD8.0
017BA:  BRA    1A30
....................  
.................... 		timerEnable[i]  = read_eeprom (timerEnableEEPROM[i]); 
017BC:  CLRF   03
017BE:  MOVF   x1F,W
017C0:  ADDLW  65
017C2:  MOVWF  01
017C4:  MOVLW  02
017C6:  ADDWFC 03,F
017C8:  MOVF   01,W
017CA:  MOVWF  x20
017CC:  MOVFF  03,321
017D0:  CLRF   03
017D2:  MOVF   x1F,W
017D4:  ADDLW  DC
017D6:  MOVWF  FE9
017D8:  MOVLW  00
017DA:  ADDWFC 03,W
017DC:  MOVWF  FEA
017DE:  MOVFF  FEF,322
017E2:  MOVFF  FF2,323
017E6:  BCF    FF2.7
017E8:  CLRF   FAA
017EA:  MOVFF  322,FA9
017EE:  BCF    FA6.6
017F0:  BCF    FA6.7
017F2:  BSF    FA6.0
017F4:  MOVF   FA8,W
017F6:  BTFSC  x23.7
017F8:  BSF    FF2.7
017FA:  MOVWF  x22
017FC:  MOVFF  321,FEA
01800:  MOVFF  320,FE9
01804:  MOVFF  322,FEF
.................... 		if(timerEnable[i] > 1){ 
01808:  CLRF   03
0180A:  MOVF   x1F,W
0180C:  ADDLW  65
0180E:  MOVWF  FE9
01810:  MOVLW  02
01812:  ADDWFC 03,W
01814:  MOVWF  FEA
01816:  MOVF   FEF,W
01818:  SUBLW  01
0181A:  BC    182C
.................... 			timerEnable[i] = 0; 
0181C:  CLRF   03
0181E:  MOVF   x1F,W
01820:  ADDLW  65
01822:  MOVWF  FE9
01824:  MOVLW  02
01826:  ADDWFC 03,W
01828:  MOVWF  FEA
0182A:  CLRF   FEF
.................... 		} 
.................... 		 
.................... 		if(timerEnable[i] == 1){ 
0182C:  CLRF   03
0182E:  MOVF   x1F,W
01830:  ADDLW  65
01832:  MOVWF  FE9
01834:  MOVLW  02
01836:  ADDWFC 03,W
01838:  MOVWF  FEA
0183A:  DECFSZ FEF,W
0183C:  BRA    1A1A
.................... 		 
.................... 			timerSwitchNumber[i]  = read_eeprom (timerSwitchNumberEEPROM[i]);  
0183E:  CLRF   03
01840:  MOVF   x1F,W
01842:  ADDLW  7A
01844:  MOVWF  01
01846:  MOVLW  02
01848:  ADDWFC 03,F
0184A:  MOVF   01,W
0184C:  MOVWF  x20
0184E:  MOVFF  03,321
01852:  CLRF   03
01854:  MOVF   x1F,W
01856:  ADDLW  F0
01858:  MOVWF  FE9
0185A:  MOVLW  00
0185C:  ADDWFC 03,W
0185E:  MOVWF  FEA
01860:  MOVFF  FEF,322
01864:  MOVFF  FF2,323
01868:  BCF    FF2.7
0186A:  CLRF   FAA
0186C:  MOVFF  322,FA9
01870:  BCF    FA6.6
01872:  BCF    FA6.7
01874:  BSF    FA6.0
01876:  MOVF   FA8,W
01878:  BTFSC  x23.7
0187A:  BSF    FF2.7
0187C:  MOVWF  x22
0187E:  MOVFF  321,FEA
01882:  MOVFF  320,FE9
01886:  MOVFF  322,FEF
.................... 			timerDeviceType[i]  = read_eeprom (timerDeviceTypeEEPROM[i]);  
0188A:  CLRF   03
0188C:  MOVF   x1F,W
0188E:  ADDLW  8F
01890:  MOVWF  01
01892:  MOVLW  02
01894:  ADDWFC 03,F
01896:  MOVF   01,W
01898:  MOVWF  x20
0189A:  MOVFF  03,321
0189E:  CLRF   03
018A0:  MOVF   x1F,W
018A2:  ADDLW  04
018A4:  MOVWF  FE9
018A6:  MOVLW  01
018A8:  ADDWFC 03,W
018AA:  MOVWF  FEA
018AC:  MOVFF  FEF,322
018B0:  MOVFF  FF2,323
018B4:  BCF    FF2.7
018B6:  CLRF   FAA
018B8:  MOVFF  322,FA9
018BC:  BCF    FA6.6
018BE:  BCF    FA6.7
018C0:  BSF    FA6.0
018C2:  MOVF   FA8,W
018C4:  BTFSC  x23.7
018C6:  BSF    FF2.7
018C8:  MOVWF  x22
018CA:  MOVFF  321,FEA
018CE:  MOVFF  320,FE9
018D2:  MOVFF  322,FEF
.................... 			timerControlMode[i]  = read_eeprom (timerControlModeEEPROM[i]); 
018D6:  CLRF   03
018D8:  MOVF   x1F,W
018DA:  ADDLW  A4
018DC:  MOVWF  01
018DE:  MOVLW  02
018E0:  ADDWFC 03,F
018E2:  MOVF   01,W
018E4:  MOVWF  x20
018E6:  MOVFF  03,321
018EA:  CLRF   03
018EC:  MOVF   x1F,W
018EE:  ADDLW  18
018F0:  MOVWF  FE9
018F2:  MOVLW  01
018F4:  ADDWFC 03,W
018F6:  MOVWF  FEA
018F8:  MOVFF  FEF,322
018FC:  MOVFF  FF2,323
01900:  BCF    FF2.7
01902:  CLRF   FAA
01904:  MOVFF  322,FA9
01908:  BCF    FA6.6
0190A:  BCF    FA6.7
0190C:  BSF    FA6.0
0190E:  MOVF   FA8,W
01910:  BTFSC  x23.7
01912:  BSF    FF2.7
01914:  MOVWF  x22
01916:  MOVFF  321,FEA
0191A:  MOVFF  320,FE9
0191E:  MOVFF  322,FEF
.................... //			timerSecondDuration[i]  = read_eeprom (timerSecondDurationEEPROM[i]); 
.................... //			timerMonth[i]  = read_eeprom (timerMonthEEPROM[i]); 
.................... //			timerDate[i]  = read_eeprom (timerDateEEPROM[i]);  
.................... 			timerHour[i]  = read_eeprom (timerHourEEPROM[i]); 
01922:  CLRF   03
01924:  MOVF   x1F,W
01926:  ADDLW  B9
01928:  MOVWF  01
0192A:  MOVLW  02
0192C:  ADDWFC 03,F
0192E:  MOVF   01,W
01930:  MOVWF  x20
01932:  MOVFF  03,321
01936:  CLRF   03
01938:  MOVF   x1F,W
0193A:  ADDLW  2C
0193C:  MOVWF  FE9
0193E:  MOVLW  01
01940:  ADDWFC 03,W
01942:  MOVWF  FEA
01944:  MOVFF  FEF,322
01948:  MOVFF  FF2,323
0194C:  BCF    FF2.7
0194E:  CLRF   FAA
01950:  MOVFF  322,FA9
01954:  BCF    FA6.6
01956:  BCF    FA6.7
01958:  BSF    FA6.0
0195A:  MOVF   FA8,W
0195C:  BTFSC  x23.7
0195E:  BSF    FF2.7
01960:  MOVWF  x22
01962:  MOVFF  321,FEA
01966:  MOVFF  320,FE9
0196A:  MOVFF  322,FEF
.................... 			timerMinute[i]  = read_eeprom (timerMinuteEEPROM[i]);  
0196E:  CLRF   03
01970:  MOVF   x1F,W
01972:  ADDLW  CE
01974:  MOVWF  01
01976:  MOVLW  02
01978:  ADDWFC 03,F
0197A:  MOVF   01,W
0197C:  MOVWF  x20
0197E:  MOVFF  03,321
01982:  CLRF   03
01984:  MOVF   x1F,W
01986:  ADDLW  40
01988:  MOVWF  FE9
0198A:  MOVLW  01
0198C:  ADDWFC 03,W
0198E:  MOVWF  FEA
01990:  MOVFF  FEF,322
01994:  MOVFF  FF2,323
01998:  BCF    FF2.7
0199A:  CLRF   FAA
0199C:  MOVFF  322,FA9
019A0:  BCF    FA6.6
019A2:  BCF    FA6.7
019A4:  BSF    FA6.0
019A6:  MOVF   FA8,W
019A8:  BTFSC  x23.7
019AA:  BSF    FF2.7
019AC:  MOVWF  x22
019AE:  MOVFF  321,FEA
019B2:  MOVFF  320,FE9
019B6:  MOVFF  322,FEF
.................... 			timerRecurrent[i]  = read_eeprom (timerRecurrentEEPROM[i]);  
019BA:  CLRF   03
019BC:  MOVF   x1F,W
019BE:  ADDLW  F8
019C0:  MOVWF  01
019C2:  MOVLW  02
019C4:  ADDWFC 03,F
019C6:  MOVF   01,W
019C8:  MOVWF  x20
019CA:  MOVFF  03,321
019CE:  CLRF   03
019D0:  MOVF   x1F,W
019D2:  ADDLW  54
019D4:  MOVWF  FE9
019D6:  MOVLW  01
019D8:  ADDWFC 03,W
019DA:  MOVWF  FEA
019DC:  MOVFF  FEF,322
019E0:  MOVFF  FF2,323
019E4:  BCF    FF2.7
019E6:  CLRF   FAA
019E8:  MOVFF  322,FA9
019EC:  BCF    FA6.6
019EE:  BCF    FA6.7
019F0:  BSF    FA6.0
019F2:  MOVF   FA8,W
019F4:  BTFSC  x23.7
019F6:  BSF    FF2.7
019F8:  MOVWF  x22
019FA:  MOVFF  321,FEA
019FE:  MOVFF  320,FE9
01A02:  MOVFF  322,FEF
.................... 			 
.................... 			ptr[0] = i+1; 
01A06:  MOVFF  31A,FE9
01A0A:  MOVFF  31B,FEA
01A0E:  MOVLW  01
01A10:  ADDWF  x1F,W
01A12:  MOVWF  FEF
.................... 			ptr++; 
01A14:  INCF   x1A,F
01A16:  BTFSC  FD8.2
01A18:  INCF   x1B,F
.................... 		} 
.................... 		if(i == timerEnableSize-1){ 
01A1A:  MOVLW  01
01A1C:  SUBWF  x19,W
01A1E:  SUBWF  x1F,W
01A20:  BNZ   1A2C
.................... 			ptr[0] = 0; 
01A22:  MOVFF  31A,FE9
01A26:  MOVFF  31B,FEA
01A2A:  CLRF   FEF
.................... 		} 
01A2C:  INCF   x1F,F
01A2E:  BRA    17B4
....................  
.................... 	} 
....................  
....................  
.................... 	enable_interrupts(GLOBAL);                 // enable global ints 
01A30:  MOVLW  C0
01A32:  IORWF  FF2,F
01A34:  MOVLB  0
01A36:  GOTO   5312 (RETURN)
....................    //===================================================================					 
.................... 			 
.................... } 
....................  
.................... //================================================================================== 
.................... void HardResetESP8266() 
.................... { 
.................... 	output_low(ESP8266_RESET); 
*
0147A:  BCF    F8D.1
.................... 	delay_ms(500); 
0147C:  MOVLW  02
0147E:  MOVLB  3
01480:  MOVWF  x19
01482:  MOVLW  FA
01484:  MOVLB  6
01486:  MOVWF  x4B
01488:  MOVLB  0
0148A:  RCALL  1062
0148C:  MOVLB  3
0148E:  DECFSZ x19,F
01490:  BRA    1482
.................... 	output_high(ESP8266_RESET); 
01492:  BSF    F8D.1
01494:  MOVLB  0
01496:  RETURN 0
.................... } 
....................  
.................... //================================================================================== 
.................... void Check_Connecttion() 
.................... { 
.................... 	if(input(ESP8266_Connect)) 
*
04EB0:  BTFSS  F84.2
04EB2:  BRA    4F70
.................... 	{	 
.................... 		Boot_Flag = false; 
04EB4:  BCF    xC4.2
....................  
.................... 		connection_cnt++;	 
04EB6:  MOVLW  01
04EB8:  ADDWF  xBE,F
04EBA:  BTFSC  FD8.0
04EBC:  INCF   xBF,F
04EBE:  BTFSC  FD8.2
04EC0:  INCF   xC0,F
04EC2:  BTFSC  FD8.2
04EC4:  INCF   xC1,F
.................... 		lcd_goto_xy(0,2); 
04EC6:  MOVLB  6
04EC8:  CLRF   x46
04ECA:  MOVLW  02
04ECC:  MOVWF  x47
04ECE:  MOVLB  0
04ED0:  CALL   1302
.................... 		display("WiFi Loss "); 
04ED4:  MOVLW  6A
04ED6:  MOVWF  FF6
04ED8:  MOVLW  0D
04EDA:  MOVWF  FF7
04EDC:  CALL   1438
.................... 		printf(display,"%lu    ",connection_cnt);	 
04EE0:  MOVLW  41
04EE2:  MOVWF  FE9
04EE4:  MOVFF  C1,31C
04EE8:  MOVFF  C0,31B
04EEC:  MOVFF  BF,31A
04EF0:  MOVFF  BE,319
04EF4:  BRA    4DA4
04EF6:  MOVLW  79
04EF8:  MOVWF  FF6
04EFA:  MOVLW  0D
04EFC:  MOVWF  FF7
04EFE:  MOVLW  04
04F00:  MOVLB  3
04F02:  MOVWF  x19
04F04:  MOVLB  0
04F06:  BRA    4E84
.................... 		if(connection_cnt > 999) 
04F08:  MOVF   xC1,F
04F0A:  BNZ   4F20
04F0C:  MOVF   xC0,F
04F0E:  BNZ   4F20
04F10:  MOVF   xBF,W
04F12:  SUBLW  02
04F14:  BC    4F6E
04F16:  XORLW  FF
04F18:  BNZ   4F20
04F1A:  MOVF   xBE,W
04F1C:  SUBLW  E7
04F1E:  BC    4F6E
.................... 		{ 
.................... 			connection_cnt = 0; 
04F20:  CLRF   xC1
04F22:  CLRF   xC0
04F24:  CLRF   xBF
04F26:  CLRF   xBE
.................... 			lcd_goto_xy(5,1); 
04F28:  MOVLW  05
04F2A:  MOVLB  6
04F2C:  MOVWF  x46
04F2E:  MOVLW  01
04F30:  MOVWF  x47
04F32:  MOVLB  0
04F34:  CALL   1302
.................... 			display("E1 "); 
04F38:  MOVLW  7E
04F3A:  MOVWF  FF6
04F3C:  MOVLW  0D
04F3E:  MOVWF  FF7
04F40:  CALL   1438
.................... 			HardResetESP8266(); 
04F44:  CALL   147A
....................  
.................... 			lcd_goto_xy(0,2); 
04F48:  MOVLB  6
04F4A:  CLRF   x46
04F4C:  MOVLW  02
04F4E:  MOVWF  x47
04F50:  MOVLB  0
04F52:  CALL   1302
.................... 			display("Reset WiFi      "); 
04F56:  MOVLW  82
04F58:  MOVWF  FF6
04F5A:  MOVLW  0D
04F5C:  MOVWF  FF7
04F5E:  CALL   1438
.................... 			fprintf(WIFI,"Reset WiFi\n"); 
04F62:  MOVLW  94
04F64:  MOVWF  FF6
04F66:  MOVLW  0D
04F68:  MOVWF  FF7
04F6A:  CALL   1458
.................... 		} 
.................... 	} 
04F6E:  BRA    4F7A
.................... 	else{ 
.................... 		connection_cnt = 0; 
04F70:  CLRF   xC1
04F72:  CLRF   xC0
04F74:  CLRF   xBF
04F76:  CLRF   xBE
.................... 		Boot_Flag = true; 
04F78:  BSF    xC4.2
.................... 	} 
04F7A:  GOTO   5338 (RETURN)
.................... } 
....................  
.................... //================================================================================== 
....................  
....................  
.................... #include "Timer.c"								//นำเข้า ไลบารี่ Timer 
....................  
....................  
.................... int16 timerTrigger = 5; 
....................  
.................... int1 timerProcessing[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... void Show_RTC() 
.................... { 
.................... 	rtc_get_date( day, mth, year, dow); 
.................... 	rtc_get_time( hour, min, sec ); 
....................  
.................... 	itoa(hour,10, hour_Display);									//แปลง int ให้เป็น String 
*
04B5A:  MOVLB  6
04B5C:  CLRF   x4A
04B5E:  CLRF   x49
04B60:  CLRF   x48
04B62:  MOVFF  1E9,647
04B66:  MOVLW  0A
04B68:  MOVWF  x4B
04B6A:  MOVLW  01
04B6C:  MOVWF  x4D
04B6E:  MOVLW  84
04B70:  MOVWF  x4C
04B72:  MOVLB  0
04B74:  CALL   2634
04B78:  CLRF   19
04B7A:  BTFSC  FF2.7
04B7C:  BSF    19.7
04B7E:  BCF    FF2.7
....................  
.................... 	hour_Display[0] = hour/10 + 48; 
04B80:  MOVFF  1E9,672
04B84:  MOVLW  0A
04B86:  MOVLB  6
04B88:  MOVWF  x73
04B8A:  MOVLB  0
04B8C:  CALL   073C
04B90:  BTFSC  19.7
04B92:  BSF    FF2.7
04B94:  MOVLW  30
04B96:  ADDWF  01,W
04B98:  MOVLB  1
04B9A:  MOVWF  x84
04B9C:  CLRF   19
04B9E:  BTFSC  FF2.7
04BA0:  BSF    19.7
04BA2:  BCF    FF2.7
.................... 	hour_Display[1] = hour%10 + 48; 
04BA4:  MOVFF  1E9,672
04BA8:  MOVLW  0A
04BAA:  MOVLB  6
04BAC:  MOVWF  x73
04BAE:  MOVLB  0
04BB0:  CALL   073C
04BB4:  BTFSC  19.7
04BB6:  BSF    FF2.7
04BB8:  MOVLW  30
04BBA:  ADDWF  00,W
04BBC:  MOVLB  1
04BBE:  MOVWF  x85
04BC0:  CLRF   19
04BC2:  BTFSC  FF2.7
04BC4:  BSF    19.7
04BC6:  BCF    FF2.7
....................  
.................... 	min_Display[0] = min/10 + 48; 
04BC8:  MOVFF  1EA,672
04BCC:  MOVLW  0A
04BCE:  MOVLB  6
04BD0:  MOVWF  x73
04BD2:  MOVLB  0
04BD4:  CALL   073C
04BD8:  BTFSC  19.7
04BDA:  BSF    FF2.7
04BDC:  MOVLW  30
04BDE:  ADDWF  01,W
04BE0:  MOVLB  1
04BE2:  MOVWF  x86
04BE4:  CLRF   19
04BE6:  BTFSC  FF2.7
04BE8:  BSF    19.7
04BEA:  BCF    FF2.7
.................... 	min_Display[1] = min%10 + 48; 
04BEC:  MOVFF  1EA,672
04BF0:  MOVLW  0A
04BF2:  MOVLB  6
04BF4:  MOVWF  x73
04BF6:  MOVLB  0
04BF8:  CALL   073C
04BFC:  BTFSC  19.7
04BFE:  BSF    FF2.7
04C00:  MOVLW  30
04C02:  ADDWF  00,W
04C04:  MOVLB  1
04C06:  MOVWF  x87
04C08:  CLRF   19
04C0A:  BTFSC  FF2.7
04C0C:  BSF    19.7
04C0E:  BCF    FF2.7
....................  
....................     sec_Display[0] = sec/10 + 48; 
04C10:  MOVFF  1EB,672
04C14:  MOVLW  0A
04C16:  MOVLB  6
04C18:  MOVWF  x73
04C1A:  MOVLB  0
04C1C:  CALL   073C
04C20:  BTFSC  19.7
04C22:  BSF    FF2.7
04C24:  MOVLW  30
04C26:  ADDWF  01,W
04C28:  MOVLB  1
04C2A:  MOVWF  x88
04C2C:  CLRF   19
04C2E:  BTFSC  FF2.7
04C30:  BSF    19.7
04C32:  BCF    FF2.7
....................     sec_Display[1] = sec%10 + 48; 
04C34:  MOVFF  1EB,672
04C38:  MOVLW  0A
04C3A:  MOVLB  6
04C3C:  MOVWF  x73
04C3E:  MOVLB  0
04C40:  CALL   073C
04C44:  BTFSC  19.7
04C46:  BSF    FF2.7
04C48:  MOVLW  30
04C4A:  ADDWF  00,W
04C4C:  MOVLB  1
04C4E:  MOVWF  x89
04C50:  CLRF   19
04C52:  BTFSC  FF2.7
04C54:  BSF    19.7
04C56:  BCF    FF2.7
....................  
.................... 	day_Display[0] = day/10 + 48; 
04C58:  MOVFF  1E5,672
04C5C:  MOVLW  0A
04C5E:  MOVLB  6
04C60:  MOVWF  x73
04C62:  MOVLB  0
04C64:  CALL   073C
04C68:  BTFSC  19.7
04C6A:  BSF    FF2.7
04C6C:  MOVLW  30
04C6E:  ADDWF  01,W
04C70:  MOVLB  1
04C72:  MOVWF  x7E
04C74:  CLRF   19
04C76:  BTFSC  FF2.7
04C78:  BSF    19.7
04C7A:  BCF    FF2.7
.................... 	day_Display[1] = day%10 + 48; 
04C7C:  MOVFF  1E5,672
04C80:  MOVLW  0A
04C82:  MOVLB  6
04C84:  MOVWF  x73
04C86:  MOVLB  0
04C88:  CALL   073C
04C8C:  BTFSC  19.7
04C8E:  BSF    FF2.7
04C90:  MOVLW  30
04C92:  ADDWF  00,W
04C94:  MOVLB  1
04C96:  MOVWF  x7F
04C98:  CLRF   19
04C9A:  BTFSC  FF2.7
04C9C:  BSF    19.7
04C9E:  BCF    FF2.7
....................  
.................... 	mth_Display[0] = mth/10 + 48; 
04CA0:  MOVFF  1E6,672
04CA4:  MOVLW  0A
04CA6:  MOVLB  6
04CA8:  MOVWF  x73
04CAA:  MOVLB  0
04CAC:  CALL   073C
04CB0:  BTFSC  19.7
04CB2:  BSF    FF2.7
04CB4:  MOVLW  30
04CB6:  ADDWF  01,W
04CB8:  MOVLB  1
04CBA:  MOVWF  x80
04CBC:  CLRF   19
04CBE:  BTFSC  FF2.7
04CC0:  BSF    19.7
04CC2:  BCF    FF2.7
.................... 	mth_Display[1] = mth%10 + 48; 
04CC4:  MOVFF  1E6,672
04CC8:  MOVLW  0A
04CCA:  MOVLB  6
04CCC:  MOVWF  x73
04CCE:  MOVLB  0
04CD0:  CALL   073C
04CD4:  BTFSC  19.7
04CD6:  BSF    FF2.7
04CD8:  MOVLW  30
04CDA:  ADDWF  00,W
04CDC:  MOVLB  1
04CDE:  MOVWF  x81
04CE0:  CLRF   19
04CE2:  BTFSC  FF2.7
04CE4:  BSF    19.7
04CE6:  BCF    FF2.7
....................  
.................... 	year_Display[0] = year/10 + 48; 
04CE8:  MOVFF  1E7,672
04CEC:  MOVLW  0A
04CEE:  MOVLB  6
04CF0:  MOVWF  x73
04CF2:  MOVLB  0
04CF4:  CALL   073C
04CF8:  BTFSC  19.7
04CFA:  BSF    FF2.7
04CFC:  MOVLW  30
04CFE:  ADDWF  01,W
04D00:  MOVLB  1
04D02:  MOVWF  x82
04D04:  CLRF   19
04D06:  BTFSC  FF2.7
04D08:  BSF    19.7
04D0A:  BCF    FF2.7
.................... 	year_Display[1] = year%10 + 48; 
04D0C:  MOVFF  1E7,672
04D10:  MOVLW  0A
04D12:  MOVLB  6
04D14:  MOVWF  x73
04D16:  MOVLB  0
04D18:  CALL   073C
04D1C:  BTFSC  19.7
04D1E:  BSF    FF2.7
04D20:  MOVLW  30
04D22:  ADDWF  00,W
04D24:  MOVLB  1
04D26:  MOVWF  x83
....................  
.................... 	lcd_goto_xy(6,1); 
04D28:  MOVLW  06
04D2A:  MOVLB  6
04D2C:  MOVWF  x46
04D2E:  MOVLW  01
04D30:  MOVWF  x47
04D32:  MOVLB  0
04D34:  CALL   1302
.................... 	//lcd_goto_xy(8,1); 
.................... 	display(dow+48); 
04D38:  MOVLW  30
04D3A:  MOVLB  1
04D3C:  ADDWF  xE8,W
04D3E:  MOVLB  3
04D40:  MOVWF  x19
04D42:  MOVFF  FE8,648
04D46:  MOVLB  0
04D48:  CALL   1408
.................... 	display(":"); 
04D4C:  MOVLW  A0
04D4E:  MOVWF  FF6
04D50:  MOVLW  0D
04D52:  MOVWF  FF7
04D54:  CALL   1438
....................  
.................... 	display(hour_Display[0]); 
04D58:  MOVFF  184,648
04D5C:  CALL   1408
.................... 	display(hour_Display[1]); 
04D60:  MOVFF  185,648
04D64:  CALL   1408
.................... 	display(":"); 
04D68:  MOVLW  A2
04D6A:  MOVWF  FF6
04D6C:  MOVLW  0D
04D6E:  MOVWF  FF7
04D70:  CALL   1438
.................... 	display(min_Display[0]); 
04D74:  MOVFF  186,648
04D78:  CALL   1408
.................... 	display(min_Display[1]); 
04D7C:  MOVFF  187,648
04D80:  CALL   1408
.................... 	display(":"); 
04D84:  MOVLW  A4
04D86:  MOVWF  FF6
04D88:  MOVLW  0D
04D8A:  MOVWF  FF7
04D8C:  CALL   1438
.................... 	display(sec_Display[0]); 
04D90:  MOVFF  188,648
04D94:  CALL   1408
.................... 	display(sec_Display[1]); 
04D98:  MOVFF  189,648
04D9C:  CALL   1408
04DA0:  GOTO   5336 (RETURN)
....................  
.................... 	/* 
.................... 	display("  "); 
.................... 	display(day_Display[0]); 
.................... 	display(day_Display[1]); 
.................... 	display("/"); 
.................... 	display(mth_Display[0]); 
.................... 	display(mth_Display[1]); 
.................... 	*/ 
.................... } 
....................  
....................  
.................... //====================================================================================================== 
.................... // 
.................... void Check_Timer() 
.................... { 
....................  
.................... 	int16 currentTrigDate = (year-2000)*10000 + mth*100 + day; 
....................  
.................... 	 
.................... 	int switchNumber; 
.................... 	char deviceType; 
.................... 	char *ptr; 
.................... 	char *ptr2; 
.................... 	int i; 
.................... 	int1 movePtr = 0; 
.................... 	char switchControlMode; 
.................... 	//int secondDuration; 
....................  
....................  
.................... 	if(timerTrigger > 0){ 
.................... 		timerTrigger--; 
.................... 		return; 
.................... 	}	 
....................  
.................... 	timerTrigger = 7; 
....................  
.................... 	ptr = activeTimerSwitch; 
.................... 	 
.................... 	//fprintf(WIFI,"PTR IS %u \n",ptr[0]); 
.................... 	//fprintf(WIFI,"activeTimerSwitch IS %u \n",activeTimerSwitch[0]); 
....................  
.................... 	while(ptr[0] != 0){ 
....................  
.................... 		 
.................... 		i = ptr[0] - 1; 
.................... 		//fprintf(WIFI,"CHECKING TIMER FOR %u \n",ptr[0]); 
....................  
.................... 		if(timerProcessing[i] == 1){ 
.................... 			continue; 
.................... 		} 
....................  
.................... 		movePtr = 1; 
.................... 		//fprintf(WIFI,"ON:%u:%u OFF:%u:%u",timerOnHour[i], timerOnMinute[i],timerOffHour[i], timerOffMinute[i]); 
.................... /* 
.................... 		//check date if not reach trig date then skip 
.................... 		if(timerMonth[i]*100 + timerDate[i] > mth*100 + day){ 
.................... 			ptr++; 
.................... 			continue; 
.................... 		} 
.................... */ 
.................... 		//fprintf(WIFI,"TIMER %u Date check pass\n",ptr[0]); 
....................  
....................  
.................... 		//if not recurrent (one time) do not check day 
.................... 		if(bit_test(timerRecurrent[i], 7)){ 
.................... 			//check day 
.................... 			//sun = 1 
.................... 			if(dow == 1 && !bit_test(timerRecurrent[i], 6)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 	 
.................... 			if(dow == 2 && !bit_test(timerRecurrent[i],5)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 	 
.................... 			if(dow == 3 && !bit_test(timerRecurrent[i],4)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 	 
.................... 			if(dow == 4 && !bit_test(timerRecurrent[i],3)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 	 
.................... 			if(dow == 5 && !bit_test(timerRecurrent[i],2)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 	 
.................... 			if(dow == 6 && !bit_test(timerRecurrent[i],1)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 	 
.................... 			if(dow == 7 && !bit_test(timerRecurrent[i],0)){ 
.................... 				ptr++; 
.................... 				continue; 
.................... 			} 
.................... 		} 
.................... 		 
.................... 		 
.................... 		//fprintf(WIFI,"TIMER %u Day of Week to run pass\n",ptr[0]); 
....................  
....................  
.................... 		//check time 
.................... 		if(timerHour[i] != hour || timerMinute[i] != min || timerSecond[i] != sec){ 
.................... 			ptr++; 
.................... 			continue; 
.................... 		} 
....................  
....................  
.................... 		 
....................  
.................... 		//fprintf(WIFI,"TIMER %u Time to run pass\n",ptr[0]); 
....................  
.................... 		//check trig 
.................... 		if(lastTrigDate[i] > currentTrigDate){ 
.................... 			ptr++; 
.................... 			continue; 
.................... 		} 
.................... 		 
.................... 		 
.................... 			 
.................... 		switchNumber = timerSwitchNumber[i]; 
.................... 		deviceType = timerDeviceType[i]; 
.................... 		switchControlMode = timerControlMode[i]; 
.................... //		secondDuration = timerSecondDuration[i]; 
....................  
.................... 		//fprintf(WIFI,"Time to %c Switch %u \n",switchControlMode, switchNumber); 
....................  
....................  
.................... 		if(deviceType == WIRELESS){		 
.................... 			fprintf(WIFI,"$MQSWCS;%u;%c;MASTER*", switchNumber, switchControlMode); 
.................... 			//WaitingWireless_Flag = true; 
.................... 			waitingSlaveCounter[switchNumber-1] = 1; 
.................... 		}else if(deviceType == LIVOLO){ 
.................... 			fprintf(ESP8266,"$MQSWCL;%u;%c;MASTER*", switchNumber, switchControlMode); 
.................... 			if(livoloSwitchStatus[i] == 0){ 
.................... 				livoloSwitchStatus[i] = 1; 
.................... 			}else{ 
.................... 				livoloSwitchStatus[i] = 0; 
.................... 			} 
.................... 			write_eeprom(saveLivoloSwitchStatusAddress[i], livoloSwitchStatus[i]); 
.................... 		}else{ 
....................  
.................... 			if(switchControlMode == SWITCH_ON){ 
.................... 				output_high(internalSwitch[switchNumber-1]); 
.................... 				delay_ms(200); 
.................... 				internalSwitchStatus[switchNumber-1] = 1; 
.................... 				 
.................... 			}else if(switchControlMode == SWITCH_OFF){ 
.................... 				output_low(internalSwitch[switchNumber-1]); 
.................... 				delay_ms(200); 
.................... 				internalSwitchStatus[switchNumber-1] = 0; 
.................... 				fprintf(ESP8266,"$MQSWSTATUSN;%u;1*", switchNumber); 
.................... 			}else if(switchControlMode == SWITCH_TOGGLE){ 
.................... 				output_high(internalSwitch[switchNumber-1]); 
.................... 				delay_ms(200); 
.................... 				output_low(internalSwitch[switchNumber-1]); 
.................... 				internalSwitchStatus[switchNumber-1] = 0; 
.................... 				fprintf(ESP8266,"$MQSWSTATUSN;%u;0*", switchNumber); 
....................  
.................... 			} 
.................... 		 
.................... 			write_eeprom(saveInternalSwitchStatusAddress[i], internalSwitchStatus[i]); 
.................... 				 
.................... 	 
.................... 			 
.................... 		} 
.................... 		 
....................  
.................... 		timerProcessing[i] = 0; 
.................... 		 
.................... 		if(bit_test(timerRecurrent[i],7) == 0){ 
.................... 			//fprintf(WIFI,"Remove Switch %u From timer Queue\n", switchNumber); 
.................... 			timerEnable[i] = 0; 
.................... 			 
.................... 			//remove from active list 
.................... 			ptr2 = strchr (activeTimerSwitch,  i+1); 
.................... 			while(ptr2[0] != 0){ 
.................... 				ptr2[0] = ptr2[1]; 
.................... 				ptr2++; 
.................... 			} 
.................... 			ptr2[0] = 0; 
.................... 			ptr2 = NULL; 
.................... 			movePtr = 0; 
.................... 		} 
....................  
.................... 		currentTrigDate = lastTrigDate[i]; 
.................... 		write_eeprom (timerEnableEEPROM[i], timerEnable[i]);  
....................  
.................... 		//move to next Active 
....................  
....................  
.................... 		if(movePtr == 1){ 
.................... 			ptr++; 
.................... 		} 
.................... 		 
.................... 	} 
....................  
....................  
.................... } 
.................... // End Program 
.................... //================================================================================================================================================================== 
....................  
....................  
....................  
.................... #include "touch.c"  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                        Dallas Touch Driver                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////  data = touch_read_bit()     Reads one bit from a touch device    //// 
.................... ////                                                                   //// 
.................... ////  data = touch_read_BYTE()    Reads one byte from a touch device.  //// 
.................... ////                                                                   //// 
.................... ////  ok = touch_write_bit(data)  Writes one bit to a touch device     //// 
.................... ////                              and returns true if all went ok.     //// 
.................... ////                              A false indicates a collision with   //// 
.................... ////                              another device.                      //// 
.................... ////                                                                   //// 
.................... ////  ok = touch_write_byte(data) Writes one byte to a touch device    //// 
.................... ////                              and returns true if all went ok.     //// 
.................... ////                              A false indicates a collision with   //// 
.................... ////                              another device.                      //// 
.................... ////                                                                   //// 
.................... ////  present = touch_present()   Issues a reset and returns true      //// 
.................... ////                              if the touch device is there.        //// 
.................... ////                                                                   //// 
.................... ////  reset_pulse()               Issues a reset and waits for a       //// 
.................... ////                              present pulse.                       //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef  TOUCH_C 
.................... #define  TOUCH_C 
....................  
.................... #ifndef TOUCH_PIN 
....................    #define TOUCH_PIN  PIN_C0 
.................... #endif 
....................  
.................... #define TOUCH_PIN_LOW()   		output_drive(TOUCH_PIN); output_low(TOUCH_PIN) 
.................... #define TOUCH_PIN_HIGH()    	output_drive(TOUCH_PIN); output_high(TOUCH_PIN) 
.................... #define TOUCH_PIN_FLOAT()  		output_float(TOUCH_PIN) 
.................... #define TOUCH_PIN_READ()      	input_state(TOUCH_PIN) 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... /* 
.................... int1 touch_read_bit() 
.................... This will read back a bit from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A bit from the DS1993 
.................... */ 
.................... int1 touch_read_bit(); 
....................  
.................... /* 
.................... BYTE touch_read_byte() 
.................... This will read back a byte from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A byte from the DS1993 
.................... */ 
.................... BYTE touch_read_byte(); 
....................  
.................... /* 
.................... BOOLEAN touch_write_bit(int1 data) 
.................... This will write a bit to the DS1993 
.................... PARAMS: The bit to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_bit(int1 data); 
....................  
.................... /* 
.................... BOOLEAN touch_write_byte(BYTE data) 
.................... This will write a byte to the DS1993 
.................... PARAMS: The byte to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_byte(BYTE data); 
....................  
.................... /* 
.................... BOOLEAN touch_present() 
.................... This will evaluate whether or not there is a touch present on the DS1993 
.................... PARAMS: none 
.................... RETURNS: True if a touch is present, false if otherwise 
.................... */ 
.................... BOOLEAN touch_present(); 
....................  
.................... /* 
.................... void reset_pulse() 
.................... This will send the DS1993 a reset pulse 
.................... PARAMS: none 
.................... RETURNS: none 
.................... */ 
.................... void reset_pulse(); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... /* 
.................... int1 touch_read_bit() 
.................... This will read back a bit from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A bit from the DS1993 
.................... */ 
.................... int1 touch_read_bit() 
.................... { 
....................    int1 data; 
....................  
....................    TOUCH_PIN_LOW(); 
....................    delay_us(14); 
....................    TOUCH_PIN_FLOAT(); 
....................    delay_us(5); 
....................    data = TOUCH_PIN_READ(); 
....................    delay_us(100); 
....................  
....................    return data; 
.................... } 
....................  
.................... /* 
.................... BYTE touch_read_byte() 
.................... This will read back a byte from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A byte from the DS1993 
.................... */ 
.................... BYTE touch_read_byte() 
.................... { 
....................    BYTE i,data; 
....................  
....................    for(i=1; i <= 8; ++i) 
....................       shift_right(&data, 1, touch_read_bit()); 
....................  
....................    return data; 
.................... } 
....................  
.................... /* 
.................... BOOLEAN touch_write_bit(int1 data) 
.................... This will write a bit to the DS1993 
.................... PARAMS: The bit to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_bit(int1 data) 
.................... { 
....................    TOUCH_PIN_LOW(); 
....................    delay_us(10); 
....................    if(data) 
....................    { 
....................       TOUCH_PIN_HIGH(); 
....................       delay_us(10); 
....................       if(!TOUCH_PIN_READ()) 
....................          return FALSE; 
....................    } 
....................    else 
....................    { 
....................       TOUCH_PIN_LOW(); 
....................       delay_us(10); 
....................       if(TOUCH_PIN_READ()) 
....................          return FALSE; 
....................    } 
....................    delay_us(50); 
....................    TOUCH_PIN_HIGH(); 
....................    delay_us(50); 
....................    return TRUE; 
.................... } 
....................  
.................... /* 
.................... BOOLEAN touch_write_byte(BYTE data) 
.................... This will write a byte to the DS1993 
.................... PARAMS: The byte to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_byte(BYTE data) 
.................... { 
....................    BYTE i; 
....................  
....................    for(i=1; i<=8; ++i) 
....................       if(!touch_write_bit(shift_right(&data, 1, 0))) 
....................          return FALSE; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /* 
.................... BOOLEAN touch_present() 
.................... This will evaluate whether or not there is a touch present on the DS1993 
.................... PARAMS: none 
.................... RETURNS: True if a touch is present, false if otherwise 
.................... */ 
.................... BOOLEAN touch_present() 
.................... { 
....................    BOOLEAN present; 
....................    TOUCH_PIN_LOW(); 
....................    delay_us(500); 
....................    TOUCH_PIN_FLOAT(); 
....................    delay_us(5); 
....................  
....................    if(!TOUCH_PIN_READ()) 
....................       return FALSE; 
....................  
....................    delay_us(65); 
....................    present = !TOUCH_PIN_READ(); 
....................    delay_us(240); 
....................    return present; 
.................... } 
....................  
.................... /* 
.................... void reset_pulse() 
.................... This will send the DS1993 a reset pulse 
.................... PARAMS: none 
.................... RETURNS: none 
.................... */ 
.................... void reset_pulse() 
.................... { 
....................    TOUCH_PIN_LOW(); 
....................    delay_us(500); 
....................    TOUCH_PIN_FLOAT(); 
....................    delay_us(5); 
....................    while(!touch_present()); 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "AccessoryService.c" 
....................  
.................... #ifndef DS1820_PIN  
.................... #define DS1820_PIN PIN_C0 
.................... #endif  
....................  
.................... #define TOUCH_PIN DS1820_PIN  
.................... #include "touch.c"  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                        Dallas Touch Driver                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////  data = touch_read_bit()     Reads one bit from a touch device    //// 
.................... ////                                                                   //// 
.................... ////  data = touch_read_BYTE()    Reads one byte from a touch device.  //// 
.................... ////                                                                   //// 
.................... ////  ok = touch_write_bit(data)  Writes one bit to a touch device     //// 
.................... ////                              and returns true if all went ok.     //// 
.................... ////                              A false indicates a collision with   //// 
.................... ////                              another device.                      //// 
.................... ////                                                                   //// 
.................... ////  ok = touch_write_byte(data) Writes one byte to a touch device    //// 
.................... ////                              and returns true if all went ok.     //// 
.................... ////                              A false indicates a collision with   //// 
.................... ////                              another device.                      //// 
.................... ////                                                                   //// 
.................... ////  present = touch_present()   Issues a reset and returns true      //// 
.................... ////                              if the touch device is there.        //// 
.................... ////                                                                   //// 
.................... ////  reset_pulse()               Issues a reset and waits for a       //// 
.................... ////                              present pulse.                       //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef  TOUCH_C 
.................... #define  TOUCH_C 
....................  
.................... #ifndef TOUCH_PIN 
....................    #define TOUCH_PIN  PIN_C0 
.................... #endif 
....................  
.................... #define TOUCH_PIN_LOW()   		output_drive(TOUCH_PIN); output_low(TOUCH_PIN) 
.................... #define TOUCH_PIN_HIGH()    	output_drive(TOUCH_PIN); output_high(TOUCH_PIN) 
.................... #define TOUCH_PIN_FLOAT()  		output_float(TOUCH_PIN) 
.................... #define TOUCH_PIN_READ()      	input_state(TOUCH_PIN) 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... /* 
.................... int1 touch_read_bit() 
.................... This will read back a bit from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A bit from the DS1993 
.................... */ 
.................... int1 touch_read_bit(); 
....................  
.................... /* 
.................... BYTE touch_read_byte() 
.................... This will read back a byte from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A byte from the DS1993 
.................... */ 
.................... BYTE touch_read_byte(); 
....................  
.................... /* 
.................... BOOLEAN touch_write_bit(int1 data) 
.................... This will write a bit to the DS1993 
.................... PARAMS: The bit to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_bit(int1 data); 
....................  
.................... /* 
.................... BOOLEAN touch_write_byte(BYTE data) 
.................... This will write a byte to the DS1993 
.................... PARAMS: The byte to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_byte(BYTE data); 
....................  
.................... /* 
.................... BOOLEAN touch_present() 
.................... This will evaluate whether or not there is a touch present on the DS1993 
.................... PARAMS: none 
.................... RETURNS: True if a touch is present, false if otherwise 
.................... */ 
.................... BOOLEAN touch_present(); 
....................  
.................... /* 
.................... void reset_pulse() 
.................... This will send the DS1993 a reset pulse 
.................... PARAMS: none 
.................... RETURNS: none 
.................... */ 
.................... void reset_pulse(); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... /* 
.................... int1 touch_read_bit() 
.................... This will read back a bit from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A bit from the DS1993 
.................... */ 
.................... int1 touch_read_bit() 
.................... { 
....................    int1 data; 
....................  
....................    TOUCH_PIN_LOW(); 
....................    delay_us(14); 
....................    TOUCH_PIN_FLOAT(); 
....................    delay_us(5); 
....................    data = TOUCH_PIN_READ(); 
....................    delay_us(100); 
....................  
....................    return data; 
.................... } 
....................  
.................... /* 
.................... BYTE touch_read_byte() 
.................... This will read back a byte from the DS1993 
.................... PARAMS: none 
.................... RETURNS: A byte from the DS1993 
.................... */ 
.................... BYTE touch_read_byte() 
.................... { 
....................    BYTE i,data; 
....................  
....................    for(i=1; i <= 8; ++i) 
....................       shift_right(&data, 1, touch_read_bit()); 
....................  
....................    return data; 
.................... } 
....................  
.................... /* 
.................... BOOLEAN touch_write_bit(int1 data) 
.................... This will write a bit to the DS1993 
.................... PARAMS: The bit to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_bit(int1 data) 
.................... { 
....................    TOUCH_PIN_LOW(); 
....................    delay_us(10); 
....................    if(data) 
....................    { 
....................       TOUCH_PIN_HIGH(); 
....................       delay_us(10); 
....................       if(!TOUCH_PIN_READ()) 
....................          return FALSE; 
....................    } 
....................    else 
....................    { 
....................       TOUCH_PIN_LOW(); 
....................       delay_us(10); 
....................       if(TOUCH_PIN_READ()) 
....................          return FALSE; 
....................    } 
....................    delay_us(50); 
....................    TOUCH_PIN_HIGH(); 
....................    delay_us(50); 
....................    return TRUE; 
.................... } 
....................  
.................... /* 
.................... BOOLEAN touch_write_byte(BYTE data) 
.................... This will write a byte to the DS1993 
.................... PARAMS: The byte to write 
.................... RETURNS: True if completed successfully, false if otherwise 
.................... */ 
.................... BOOLEAN touch_write_byte(BYTE data) 
.................... { 
....................    BYTE i; 
....................  
....................    for(i=1; i<=8; ++i) 
....................       if(!touch_write_bit(shift_right(&data, 1, 0))) 
....................          return FALSE; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /* 
.................... BOOLEAN touch_present() 
.................... This will evaluate whether or not there is a touch present on the DS1993 
.................... PARAMS: none 
.................... RETURNS: True if a touch is present, false if otherwise 
.................... */ 
.................... BOOLEAN touch_present() 
.................... { 
....................    BOOLEAN present; 
....................    TOUCH_PIN_LOW(); 
....................    delay_us(500); 
....................    TOUCH_PIN_FLOAT(); 
....................    delay_us(5); 
....................  
....................    if(!TOUCH_PIN_READ()) 
....................       return FALSE; 
....................  
....................    delay_us(65); 
....................    present = !TOUCH_PIN_READ(); 
....................    delay_us(240); 
....................    return present; 
.................... } 
....................  
.................... /* 
.................... void reset_pulse() 
.................... This will send the DS1993 a reset pulse 
.................... PARAMS: none 
.................... RETURNS: none 
.................... */ 
.................... void reset_pulse() 
.................... { 
....................    TOUCH_PIN_LOW(); 
....................    delay_us(500); 
....................    TOUCH_PIN_FLOAT(); 
....................    delay_us(5); 
....................    while(!touch_present()); 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //============================================================================ 
.................... // 
.................... /************************************************************ ReadTemp_DS1820 */ 
.................... //Description : Read Temperature (use RB0 read temp) 
.................... void ReadTemp_DS1820(void) 
.................... { 
....................  
.................... 		byte i, buffer[9]; 
.................... 		 
.................... 		if (touch_present()) { // get present (reset) (2) 
.................... 				touch_write_byte(0xCC); // Skip ROM (3) 
.................... 				touch_write_byte (0x44); // Start Conversion 
.................... 				delay_ms(20); // delay 200 ms (4) 
.................... 				touch_present(); // get present (reset) (5) 
.................... 				touch_write_byte(0xCC); // Skip ROM (6) 
.................... 				touch_write_byte (0xBE); // Read Scratch Pad 
.................... 				 
.................... 				for(i=0; i<9;i++) // read 9 bytes (7) 
.................... 				buffer[i] = touch_read_byte(); 
.................... 		} 
.................... 		temp = (buffer[1]<<4)|(buffer[0]>>4); // Temperature (8) 
.................... 		raw_temp = buffer[1]; 
.................... 		raw_temp <<= 8; 
.................... 		raw_temp += buffer[0]; 
....................  
.................... 		temp_Display[0] = temp/10 + 48; 
.................... 		temp_Display[1] = temp%10 + 48; 
....................  
.................... 		//temperature = ds1820_read();  
....................  
.................... 		lcd_goto_xy(8,2);				//Line 3 
....................         printf(display," T:%u ",temp); 
.................... 	    //display(" T:"); 
.................... 	    //display(temp_Display[0]); 
....................         //display(temp_Display[1]); 
.................... 		//printf(display,"T:%3.1f ", temperature);  
.................... 		display(223); 
....................         display("C  "); 
.................... } 
....................  
.................... //========================================================================== 
....................  
.................... void CheckBattery() 
.................... { 
.................... 		long adc; 
.................... 			 
.................... 		set_adc_channel(0);									//RA1_ANALOG 
....................         delay_us(10); 
....................  
.................... 		adc = read_adc();                         			// Read a value from the ADC 
....................  
.................... 		voltage = (float)adc*0.0169;						// Defaul 0.0186   Debug 0.02185 
....................  
.................... 		lcd_goto_xy(0,2); 
.................... 		printf(display,"B:%2.2fV",voltage); 
....................  
.................... } 
....................  
.................... //========================================================================== 
....................  
.................... void CheckIntrusion() 
.................... { 
.................... //check alert flag 
....................  
.................... } 
.................... //========================================================================== 
....................  
.................... #include "ISR_Process.c" 
....................  
.................... #define INTS_PER_SECOND 38 //Processor and clock specific 
....................  
.................... int8 int_count=0;  
.................... int8 data = 0; 
.................... int WaitingTimer = 0; 
....................  
.................... //======================================================================================= 
.................... #int_rtcc  
.................... clock_isr() {  
....................  
....................    //this block maintains timer variables with a resolution of a ~ 1 s  
....................    if(--int_count==0)  
*
00EF6:  MOVLB  3
00EF8:  DECFSZ x16,F
00EFA:  BRA    1000
....................    {  
....................       int_count=INTS_PER_SECOND; //reset  
00EFC:  MOVLW  26
00EFE:  MOVWF  x16
....................  
....................       if(data == 0)  
00F00:  MOVF   x17,F
00F02:  BNZ   0F0A
....................       {  
....................          data = 1;  
00F04:  MOVLW  01
00F06:  MOVWF  x17
.................... 		 //output_high(LED); 
....................       }  
00F08:  BRA    1000
....................       else  
....................       { 
.................... 			data = 0;  
00F0A:  CLRF   x17
....................  
....................  
.................... 	  	for(int i = 0; i < sizeof(waitingSlaveCounter); i++){ 
00F0C:  MOVLB  6
00F0E:  CLRF   x6C
00F10:  MOVF   x6C,W
00F12:  SUBLW  09
00F14:  BNC   0FC2
.................... 			if(waitingSlaveCounter[i] > 0){ 
00F16:  CLRF   03
00F18:  MOVF   x6C,W
00F1A:  ADDLW  8B
00F1C:  MOVWF  FE9
00F1E:  MOVLW  00
00F20:  ADDWFC 03,W
00F22:  MOVWF  FEA
00F24:  MOVF   FEF,F
00F26:  BZ    0F38
.................... 				waitingSlaveCounter[i]++; 
00F28:  CLRF   03
00F2A:  MOVF   x6C,W
00F2C:  ADDLW  8B
00F2E:  MOVWF  FE9
00F30:  MOVLW  00
00F32:  ADDWFC 03,W
00F34:  MOVWF  FEA
00F36:  INCF   FEF,F
.................... 			} 
....................  
.................... 			if(waitingSlaveCounter[i] > 3){ 
00F38:  CLRF   03
00F3A:  MOVF   x6C,W
00F3C:  ADDLW  8B
00F3E:  MOVWF  FE9
00F40:  MOVLW  00
00F42:  ADDWFC 03,W
00F44:  MOVWF  FEA
00F46:  MOVF   FEF,W
00F48:  SUBLW  03
00F4A:  BC    0FBE
.................... 				fprintf(ESP8266,"$MQSWERR;%u;%s*",i+1, uuids[i]); 
00F4C:  MOVLW  01
00F4E:  ADDWF  x6C,W
00F50:  MOVWF  x6D
00F52:  CLRF   03
00F54:  MOVFF  66C,02
00F58:  BCF    FD8.0
00F5A:  RLCF   02,F
00F5C:  RLCF   03,F
00F5E:  MOVF   02,W
00F60:  ADDLW  95
00F62:  MOVWF  FE9
00F64:  MOVLW  00
00F66:  ADDWFC 03,W
00F68:  MOVWF  FEA
00F6A:  MOVFF  FEC,66F
00F6E:  MOVF   FED,F
00F70:  MOVFF  FEF,66E
00F74:  MOVLW  08
00F76:  MOVWF  FF6
00F78:  MOVLW  10
00F7A:  MOVWF  FF7
00F7C:  MOVLW  09
00F7E:  MOVWF  x70
00F80:  MOVLB  0
00F82:  RCALL  0E06
00F84:  MOVFF  66D,670
00F88:  MOVLW  1B
00F8A:  MOVLB  6
00F8C:  MOVWF  x71
00F8E:  MOVLB  0
00F90:  RCALL  0E30
00F92:  MOVLW  3B
00F94:  BTFSS  FA4.4
00F96:  BRA    0F94
00F98:  MOVWF  F73
00F9A:  MOVFF  66F,FEA
00F9E:  MOVFF  66E,FE9
00FA2:  RCALL  0EAE
00FA4:  MOVLW  2A
00FA6:  BTFSS  FA4.4
00FA8:  BRA    0FA6
00FAA:  MOVWF  F73
.................... 				waitingSlaveCounter[i] = 0; 
00FAC:  CLRF   03
00FAE:  MOVLB  6
00FB0:  MOVF   x6C,W
00FB2:  ADDLW  8B
00FB4:  MOVWF  FE9
00FB6:  MOVLW  00
00FB8:  ADDWFC 03,W
00FBA:  MOVWF  FEA
00FBC:  CLRF   FEF
.................... 			} 
00FBE:  INCF   x6C,F
00FC0:  BRA    0F10
.................... 		} 
....................  
.................... 			Request_Update_Info++; 
00FC2:  MOVLB  0
00FC4:  INCF   xC2,F
00FC6:  BTFSC  FD8.2
00FC8:  INCF   xC3,F
.................... 			if(Request_Update_Info == 5) 
00FCA:  MOVF   xC2,W
00FCC:  SUBLW  05
00FCE:  BNZ   0FE2
00FD0:  MOVF   xC3,F
00FD2:  BNZ   0FE2
.................... 			{ 
.................... 				if(MQTTConnect_Flag) 
00FD4:  BTFSS  xC4.0
00FD6:  BRA    0FE2
.................... 				{ 
.................... 					fprintf(ESP8266,"$BOXMQTT*"); 
00FD8:  MOVLW  18
00FDA:  MOVWF  FF6
00FDC:  MOVLW  10
00FDE:  MOVWF  FF7
00FE0:  RCALL  0ED4
.................... 				} 
.................... 			} 
....................  
.................... 			if(Request_Update_Info == 7) 
00FE2:  MOVF   xC2,W
00FE4:  SUBLW  07
00FE6:  BNZ   0FFE
00FE8:  MOVF   xC3,F
00FEA:  BNZ   0FFE
.................... 			{ 
.................... 				Request_Update_Info = 0; 
00FEC:  CLRF   xC3
00FEE:  CLRF   xC2
....................  
.................... 				if(UpdateRTC_flag) 
00FF0:  BTFSS  xC4.1
00FF2:  BRA    0FFE
.................... 				{ 
.................... 					//$BOXRTC* 
.................... 					fprintf(ESP8266,"$BOXRTC*"); 
00FF4:  MOVLW  22
00FF6:  MOVWF  FF6
00FF8:  MOVLW  10
00FFA:  MOVWF  FF7
00FFC:  RCALL  0ED4
00FFE:  MOVLB  3
.................... 				} 
.................... 			} 
....................  
.................... 	  } 
.................... 	 
....................  
....................  
....................  
.................... 	} 
....................  
01000:  BCF    FF2.2
01002:  MOVLB  0
01004:  GOTO   0484
.................... } 
....................  
.................... //========================================================================================*/ 
....................  
....................  
.................... void main() 
*
04F7E:  CLRF   FF8
04F80:  BCF    FD0.7
04F82:  BSF    07.7
04F84:  CLRF   1A
04F86:  BSF    FB8.3
04F88:  MOVLW  08
04F8A:  MOVWF  FAF
04F8C:  MOVLW  02
04F8E:  MOVWF  FB0
04F90:  MOVLW  A6
04F92:  MOVWF  FAC
04F94:  MOVLW  90
04F96:  MOVWF  FAB
04F98:  BSF    F70.3
04F9A:  MOVLW  56
04F9C:  MOVWF  F75
04F9E:  MOVLW  00
04FA0:  MOVWF  F76
04FA2:  MOVLW  A6
04FA4:  MOVWF  F72
04FA6:  MOVLW  90
04FA8:  MOVWF  F71
04FAA:  CLRF   xC1
04FAC:  CLRF   xC0
04FAE:  CLRF   xBF
04FB0:  CLRF   xBE
04FB2:  CLRF   xC3
04FB4:  CLRF   xC2
04FB6:  BSF    xC4.0
04FB8:  BSF    xC4.1
04FBA:  CLRF   xD1
04FBC:  CLRF   xD0
04FBE:  CLRF   xCF
04FC0:  CLRF   xCE
04FC2:  BCF    xC4.2
04FC4:  BCF    xC4.3
04FC6:  BCF    xC4.4
04FC8:  CLRF   xD2
04FCA:  CLRF   xD4
04FCC:  CLRF   xD3
04FCE:  CLRF   xD6
04FD0:  CLRF   xD5
04FD2:  CLRF   xD8
04FD4:  CLRF   xD7
04FD6:  CLRF   xD9
04FD8:  CLRF   xDA
04FDA:  CLRF   xDB
04FDC:  BCF    xC4.5
04FDE:  BCF    xC4.6
04FE0:  MOVLW  4E
04FE2:  MOVLB  1
04FE4:  MOVWF  x94
04FE6:  MOVLB  0
04FE8:  BCF    xC4.7
04FEA:  MOVLW  32
04FEC:  MOVLB  1
04FEE:  MOVWF  xF6
04FF0:  CLRF   xF7
04FF2:  BSF    xF8.0
04FF4:  BSF    xF8.1
04FF6:  BSF    xF8.2
04FF8:  BSF    xF8.3
04FFA:  BSF    xF8.4
04FFC:  BSF    xF8.5
04FFE:  BCF    xF8.6
05000:  MOVLB  2
05002:  CLRF   x04
05004:  CLRF   x03
05006:  MOVLB  1
05008:  BCF    xF8.7
0500A:  MOVLB  2
0500C:  BCF    x62.0
0500E:  CLRF   x64
05010:  CLRF   x63
05012:  BCF    x62.1
05014:  BCF    x62.2
05016:  MOVLB  3
05018:  CLRF   x12
0501A:  MOVLW  05
0501C:  MOVWF  x11
0501E:  CLRF   x16
05020:  CLRF   x17
05022:  CLRF   x18
05024:  MOVLB  F
05026:  CLRF   x38
05028:  CLRF   x39
0502A:  CLRF   x3A
0502C:  CLRF   x3B
0502E:  CLRF   x3C
05030:  CLRF   F77
05032:  CLRF   F78
05034:  CLRF   F79
05036:  BRA    515C
05038:  DATA 02,00
0503A:  DATA 1B,00
0503C:  DATA 00,06
0503E:  DATA 00,21
05040:  DATA 18,19
05042:  DATA 1A,13
05044:  DATA 14,15
05046:  DATA 1E,C0
05048:  DATA 00,1E
0504A:  DATA 80,15
0504C:  DATA 16,17
0504E:  DATA 18,19
05050:  DATA 1A,1B
05052:  DATA 1C,1D
05054:  DATA 1E,1F
05056:  DATA 20,21
05058:  DATA 22,23
0505A:  DATA 24,25
0505C:  DATA 26,27
0505E:  DATA 28,29
05060:  DATA 2A,2B
05062:  DATA 2C,2D
05064:  DATA 2E,2F
05066:  DATA 30,31
05068:  DATA 32,32
0506A:  DATA C0,00
0506C:  DATA 8C,00
0506E:  DATA DC,F5
05070:  DATA F6,F7
05072:  DATA F8,F9
05074:  DATA FA,FB
05076:  DATA FC,FD
05078:  DATA FE,FF
0507A:  DATA 00,01
0507C:  DATA 02,03
0507E:  DATA 04,05
05080:  DATA 06,07
05082:  DATA 08,09
05084:  DATA 0A,0B
05086:  DATA 0C,0D
05088:  DATA 0E,0F
0508A:  DATA 10,11
0508C:  DATA 12,13
0508E:  DATA 14,15
05090:  DATA 16,17
05092:  DATA 18,19
05094:  DATA 1A,1B
05096:  DATA 1C,1D
05098:  DATA 1E,1F
0509A:  DATA 20,21
0509C:  DATA 22,23
0509E:  DATA 24,25
050A0:  DATA 26,27
050A2:  DATA 28,29
050A4:  DATA 2A,2B
050A6:  DATA 2C,2D
050A8:  DATA 2E,2F
050AA:  DATA 30,31
050AC:  DATA 32,33
050AE:  DATA 34,35
050B0:  DATA 36,37
050B2:  DATA 38,39
050B4:  DATA 3A,3B
050B6:  DATA 3C,3D
050B8:  DATA 3E,3F
050BA:  DATA 40,41
050BC:  DATA 42,43
050BE:  DATA 44,45
050C0:  DATA 46,47
050C2:  DATA 48,49
050C4:  DATA 4A,4B
050C6:  DATA 4C,4D
050C8:  DATA 4E,4F
050CA:  DATA 50,51
050CC:  DATA 52,53
050CE:  DATA 54,55
050D0:  DATA 56,57
050D2:  DATA 58,59
050D4:  DATA 5A,5B
050D6:  DATA 5C,5D
050D8:  DATA 5E,5F
050DA:  DATA 60,61
050DC:  DATA 62,63
050DE:  DATA 64,65
050E0:  DATA 66,67
050E2:  DATA 68,69
050E4:  DATA 6A,6B
050E6:  DATA 6C,6D
050E8:  DATA 6E,6F
050EA:  DATA 70,71
050EC:  DATA 72,73
050EE:  DATA 74,75
050F0:  DATA 76,77
050F2:  DATA 78,79
050F4:  DATA 7A,7B
050F6:  DATA 7C,7D
050F8:  DATA 7E,7F
050FA:  DATA 80,16
050FC:  DATA C0,00
050FE:  DATA 50,01
05100:  DATA 95,80
05102:  DATA 81,82
05104:  DATA 83,84
05106:  DATA 85,86
05108:  DATA 87,88
0510A:  DATA 89,8A
0510C:  DATA 8B,8C
0510E:  DATA 8D,8E
05110:  DATA 8F,90
05112:  DATA 91,92
05114:  DATA 93,C0
05116:  DATA C1,C2
05118:  DATA C3,C4
0511A:  DATA C5,C6
0511C:  DATA C7,C8
0511E:  DATA C9,CA
05120:  DATA CB,CC
05122:  DATA CD,CE
05124:  DATA CF,D0
05126:  DATA D1,D2
05128:  DATA D3,94
0512A:  DATA 95,96
0512C:  DATA 97,98
0512E:  DATA 99,9A
05130:  DATA 9B,9C
05132:  DATA 9D,9E
05134:  DATA 9F,A0
05136:  DATA A1,A2
05138:  DATA A3,A4
0513A:  DATA A5,A6
0513C:  DATA A7,D4
0513E:  DATA D5,D6
05140:  DATA D7,D8
05142:  DATA D9,DA
05144:  DATA DB,DC
05146:  DATA DE,DF
05148:  DATA E0,E1
0514A:  DATA E2,E3
0514C:  DATA E4,E5
0514E:  DATA E6,E7
05150:  DATA E8,A8
05152:  DATA 42,65
05154:  DATA 00,03
05156:  DATA 03,13
05158:  DATA 00,00
0515A:  DATA 00,00
0515C:  MOVLW  00
0515E:  MOVWF  FF8
05160:  MOVLW  50
05162:  MOVWF  FF7
05164:  MOVLW  38
05166:  MOVWF  FF6
05168:  TBLRD*+
0516A:  MOVF   FF5,W
0516C:  MOVWF  00
0516E:  XORLW  00
05170:  BZ    5198
05172:  TBLRD*+
05174:  MOVF   FF5,W
05176:  MOVWF  01
05178:  BTFSC  FE8.7
0517A:  BRA    5186
0517C:  ANDLW  0F
0517E:  MOVWF  FEA
05180:  TBLRD*+
05182:  MOVFF  FF5,FE9
05186:  BTFSC  01.6
05188:  TBLRD*+
0518A:  BTFSS  01.6
0518C:  TBLRD*+
0518E:  MOVFF  FF5,FEE
05192:  DCFSNZ 00,F
05194:  BRA    5168
05196:  BRA    518A
05198:  CLRF   FF8
.................... { 
.................... 	 set_tris_a(0b00001111);					// A0 = BATT 
0519A:  MOVLW  0F
0519C:  MOVWF  F92
....................      set_tris_b(0b10000001);                    // B4 = OP4,B2 = I/O, B1 = XPORT_RESET, B0 = IR Remote 
0519E:  MOVLW  81
051A0:  MOVWF  F93
....................    	 set_tris_c(0b10000010);					// RC7 = O/P, RC6 = I/P , C1 Remote LED 
051A2:  MOVLW  82
051A4:  MOVWF  F94
....................      set_tris_d(0b10000000);                    // D 
051A6:  MOVLW  80
051A8:  MOVWF  F95
....................      set_tris_e(0b00000100);					// E2 = Connection, E1 = ESP8266_Reset, E0 = WiFi_Reset 
051AA:  BCF    F96.0
051AC:  BCF    F96.1
051AE:  BSF    F96.2
051B0:  BCF    F96.3
....................  
.................... 	 write_eeprom (UPGRADE_ADDRESS, 0x39);		// Clear Upgrade New Firmware 
051B2:  MOVFF  FF2,00
051B6:  BCF    FF2.7
051B8:  CLRF   FAA
051BA:  SETF   FA9
051BC:  MOVLW  39
051BE:  MOVWF  FA8
051C0:  BCF    FA6.6
051C2:  BCF    FA6.7
051C4:  BSF    FA6.2
051C6:  MOVLW  55
051C8:  MOVWF  FA7
051CA:  MOVLW  AA
051CC:  MOVWF  FA7
051CE:  BSF    FA6.1
051D0:  BTFSC  FA6.1
051D2:  BRA    51D0
051D4:  BCF    FA6.2
051D6:  MOVF   00,W
051D8:  IORWF  FF2,F
.................... 	 write_eeprom (FWVERSIONADDR1, '0');  
051DA:  MOVFF  FF2,00
051DE:  BCF    FF2.7
051E0:  CLRF   FAA
051E2:  MOVLW  01
051E4:  MOVWF  FA9
051E6:  MOVLW  30
051E8:  MOVWF  FA8
051EA:  BCF    FA6.6
051EC:  BCF    FA6.7
051EE:  BSF    FA6.2
051F0:  MOVLW  55
051F2:  MOVWF  FA7
051F4:  MOVLW  AA
051F6:  MOVWF  FA7
051F8:  BSF    FA6.1
051FA:  BTFSC  FA6.1
051FC:  BRA    51FA
051FE:  BCF    FA6.2
05200:  MOVF   00,W
05202:  IORWF  FF2,F
.................... 	 write_eeprom (FWVERSIONADDR2, '0'); 
05204:  MOVFF  FF2,00
05208:  BCF    FF2.7
0520A:  CLRF   FAA
0520C:  MOVLW  02
0520E:  MOVWF  FA9
05210:  MOVLW  30
05212:  MOVWF  FA8
05214:  BCF    FA6.6
05216:  BCF    FA6.7
05218:  BSF    FA6.2
0521A:  MOVLW  55
0521C:  MOVWF  FA7
0521E:  MOVLW  AA
05220:  MOVWF  FA7
05222:  BSF    FA6.1
05224:  BTFSC  FA6.1
05226:  BRA    5224
05228:  BCF    FA6.2
0522A:  MOVF   00,W
0522C:  IORWF  FF2,F
.................... 	 write_eeprom (FWVERSIONADDR3, '.'); 
0522E:  MOVFF  FF2,00
05232:  BCF    FF2.7
05234:  CLRF   FAA
05236:  MOVLW  03
05238:  MOVWF  FA9
0523A:  MOVLW  2E
0523C:  MOVWF  FA8
0523E:  BCF    FA6.6
05240:  BCF    FA6.7
05242:  BSF    FA6.2
05244:  MOVLW  55
05246:  MOVWF  FA7
05248:  MOVLW  AA
0524A:  MOVWF  FA7
0524C:  BSF    FA6.1
0524E:  BTFSC  FA6.1
05250:  BRA    524E
05252:  BCF    FA6.2
05254:  MOVF   00,W
05256:  IORWF  FF2,F
.................... 	 write_eeprom (FWVERSIONADDR4, '9'); 
05258:  MOVFF  FF2,00
0525C:  BCF    FF2.7
0525E:  CLRF   FAA
05260:  MOVLW  04
05262:  MOVWF  FA9
05264:  MOVLW  39
05266:  MOVWF  FA8
05268:  BCF    FA6.6
0526A:  BCF    FA6.7
0526C:  BSF    FA6.2
0526E:  MOVLW  55
05270:  MOVWF  FA7
05272:  MOVLW  AA
05274:  MOVWF  FA7
05276:  BSF    FA6.1
05278:  BTFSC  FA6.1
0527A:  BRA    5278
0527C:  BCF    FA6.2
0527E:  MOVF   00,W
05280:  IORWF  FF2,F
.................... 	 write_eeprom (FWVERSIONADDR5, '0'); 
05282:  MOVFF  FF2,00
05286:  BCF    FF2.7
05288:  CLRF   FAA
0528A:  MOVLW  05
0528C:  MOVWF  FA9
0528E:  MOVLW  30
05290:  MOVWF  FA8
05292:  BCF    FA6.6
05294:  BCF    FA6.7
05296:  BSF    FA6.2
05298:  MOVLW  55
0529A:  MOVWF  FA7
0529C:  MOVLW  AA
0529E:  MOVWF  FA7
052A0:  BSF    FA6.1
052A2:  BTFSC  FA6.1
052A4:  BRA    52A2
052A6:  BCF    FA6.2
052A8:  MOVF   00,W
052AA:  IORWF  FF2,F
.................... 	  
....................  
....................      //setup_adc_ports(0); 
....................      //setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................      int_count=INTS_PER_SECOND;  
052AC:  MOVLW  26
052AE:  MOVLB  3
052B0:  MOVWF  x16
....................      setup_counters( RTCC_INTERNAL, RTCC_DIV_256);  
052B2:  BCF    FD1.0
052B4:  MOVLW  87
052B6:  MOVWF  FD5
....................      setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_BIT); //Timer 0 for System Clock 
052B8:  MOVLW  C7
052BA:  MOVWF  FD5
....................  
.................... 	 enable_interrupts(INT_RTCC); 
052BC:  BSF    FF2.5
....................  
.................... 	 /*/ IR Remote ========================== 
.................... 	 setup_counters(RTCC_INTERNAL,RTCC_DIV_1);    // get high 
.................... 	 setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................  
.................... 	 ext_int_edge(H_TO_L);      // init interrupt triggering for button press 
.................... 	 enable_interrupts(INT_EXT);// turn on interrupts 
....................  
.................... 	//======================================*/ 
....................  
.................... 	 //set_timer3(0); 
.................... 	 //setup_timer_3 (T3_INTERNAL|T3_DIV_BY_1);	// 	เลข 1 คือให้ over flow 1 รอบ 
....................  
.................... 	 enable_interrupts(INT_RDA); 
052BE:  BSF    F9D.5
.................... 	 clear_interrupt(INT_RDA); 
052C0:  MOVF   FAE,W
....................  
.................... 	 enable_interrupts(INT_RDA2);              	// enable RDA 2 interrupts 
052C2:  BSF    FA3.5
.................... 	 clear_interrupt(INT_RDA2); 
052C4:  MOVF   F74,W
....................  
.................... 	 
....................  
.................... 	 enable_interrupts(GLOBAL);                 // enable global ints 
052C6:  MOVLW  C0
052C8:  IORWF  FF2,F
....................  
....................  
.................... 	 output_high(WIFI_RESET); 
052CA:  BSF    F8D.0
....................      output_high(ESP8266_RESET); 
052CC:  BSF    F8D.1
....................  
.................... 	 output_low(SIREN); 
052CE:  BCF    F89.4
....................  
....................   	 delay_ms(20); 
052D0:  MOVLW  14
052D2:  MOVLB  6
052D4:  MOVWF  x4B
052D6:  MOVLB  0
052D8:  CALL   1062
....................   	 lcd_init(); 
052DC:  GOTO   118A
....................  
.................... 	 rtc_init();															// Innitail ตัวเรียลไทม์คล็อค IC เบอร์ DS1302 
052E0:  GOTO   12AE
....................  
....................      lcd_goto_xy(0,2); 
052E4:  MOVLB  6
052E6:  CLRF   x46
052E8:  MOVLW  02
052EA:  MOVWF  x47
052EC:  MOVLB  0
052EE:  CALL   1302
....................      display("HomeControl V4.0"); 
052F2:  MOVLW  2C
052F4:  MOVWF  FF6
052F6:  MOVLW  10
052F8:  MOVWF  FF7
052FA:  CALL   1438
....................  
.................... 	 fprintf(WIFI,"\r\nHome Control Plus - MQTT V00.90\r\n"); 
052FE:  MOVLW  3E
05300:  MOVWF  FF6
05302:  MOVLW  10
05304:  MOVWF  FF7
05306:  CALL   1458
.................... 	 HardResetESP8266(); 
0530A:  CALL   147A
....................  
....................      Last_Switch_State();													//โหลด สถานะสวิตซ์ ครั้งก่อนหน้านี้ 
0530E:  GOTO   14DA
.................... 	 //Load_IR_DATA(); 
....................  
....................   
....................  
.................... 	 while(1) 
.................... 	 { 
....................  
....................  
.................... 				if(WIFI_Flag) 
05312:  MOVLB  1
05314:  BTFSS  xF8.7
05316:  BRA    5320
.................... 				{ 
.................... 					WiFi_Receive();											//เรียกฟังก์ชั่นอ่านข้อมูลจาก Xport 
05318:  MOVLB  0
0531A:  GOTO   1F0C
.................... 				} 
0531E:  BRA    5338
.................... 				else if(MQTTDataReadyFlag) 
05320:  MOVLB  2
05322:  BTFSS  x62.1
05324:  BRA    5330
.................... 				{ 
.................... 					ProcessMQTTData(); 
05326:  MOVLB  0
05328:  GOTO   2C6A
.................... 				}	 
0532C:  BRA    5338
0532E:  MOVLB  2
.................... 				else{ 
.................... 					Show_RTC();												//เรียกฟังก์ชั่นอ่านสัญญาณนาฬิกา 
05330:  MOVLB  0
05332:  GOTO   4AA4
.................... 					//Check_Timer();	 
.................... 					Check_Connecttion(); 
05336:  BRA    4EB0
.................... 					/*if(Boot_Flag) 
.................... 					{ 
.................... 						ReadTemp_DS1820(); 
.................... 						CheckBattery(); 
.................... 						CheckIntrusion(); 
.................... 					}*/ 
.................... 				} 
05338:  BRA    5312
....................  
.................... 	 } 
.................... } 
0533A:  BRA    533A

Configuration Fuses:
   Word  1: F200   HSH PLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1C19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
